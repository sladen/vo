Description: Retrieve missing cds/astro/* directory from earlier release
 The 'cds.astro.*' package provides backend library functions which
 Aladin uses for projection.  This directory was accidentally deleted
 between Aladin 7.533<=version<=8.040, and only the corresponding
 binary continued to be included in the upstream source release.
 This was raised with the upstream authors in June 2016, who
 confirmed the issue and have stated in the intention to make a new
 upstream source release, re-including this directory.  In the
 mean-time this patch re-adds the contents of this directory as
 found in the Aladin 7.533 source release; based on the result
 of performing $ git checkout upstream/7.533+dfsg -- cds/astro
Forwarded: yes
Author: Paul Sladen <debian@paul.sladen.org>
Last-Update: 2016-06-16
Encoding: cp1252
Index: aladin/cds/astro/AstroMath.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/AstroMath.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,238 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/**
+ * Trigonometric and a few other functions used in the astronomical context. 
+ * This class includes also 3x3 matrix manipulation.
+ * Extracted from Class Coo
+ * @author Francois Ochsenbein
+ * @version 1.0: 20-Apr-2004
+ */
+
+public class AstroMath {
+   public static final double[] powers = { 1., 1.e1, 1.e2, 1.e3,
+     1.e4, 1.e5, 1.e6, 1.e7, 1.e8, 1.e9 };
+
+   public static final double DEG = 180.0/Math.PI ;	// Degrees to radians
+   public static final double ARCSEC = 3600.*DEG ;	// Arcsec to radians
+   static final double ln10 = Math.log(10.) ;		// log10 to natural log
+
+    //  ===========================================================
+    //		Trigonometry in Degrees
+    //  ===========================================================
+
+    /*  Static methods (functions) in Java are very close to C ones;
+    	 they do not require any object instanciation.
+    	 Typical example of static methods are in the Math class
+    	 Note that the functions toDegrees and toRadians can be used
+    	 in JDK1.2 -- we stick here strictly to JDK1.1
+    */
+
+   /** 
+    * Cosine when argument in degrees
+    * @param x angle in degrees
+    * @return	the cosine
+    */
+    public static final double cosd(double x) {
+    	return Math.cos( x/DEG );
+    }
+
+   /** 
+    * Sine  when argument in degrees
+    * @param x angle in degrees
+    * @return	the sine
+    */
+    public static final double sind(double x) {
+    	 return Math.sin( x/DEG );
+    }
+
+   /** 
+    * sin-1 (inverse function of sine), gives argument in degrees
+    * @param	x argument
+    * @return	y value such that sin(y) = x
+    */
+    public static final double asind(double x) {
+    		 return Math.asin(x)*DEG;
+    }
+
+   /** 
+    * tan-1 (inverse function of tangent), gives argument in degrees
+    * @param x argument
+    * @return	angle in degrees
+    */
+    public static final double atand(double x) {
+    		 return Math.atan(x)*DEG;
+    }
+
+   /** 
+    * get the polar angle from 2-D cartesian coordinates
+    * @param y cartesian y coordinate
+    * @param x cartesian x coordinate
+    * @return	polar angle in degrees
+    */
+    public static final double atan2d(double y,double x) {
+    		 return Math.atan2(y,x)*DEG;
+    }
+
+    //  ===========================================================
+    //		Hyperbolic Functions (not in Math ??)
+    //  ===========================================================
+
+   /** 
+    * Hyperbolic cosine cosh = (exp(x) + exp(-x))/2
+    * @param  x argument
+    * @return	corresponding hyperbolic cosine (>= 1)
+    */
+    public static final double cosh (double x) {
+    	 double ex ;
+    		  ex = Math.exp(x) ;
+    		return 0.5 * (ex + 1./ex) ;
+    }
+
+   /** 
+    * Hyperbolic tangent = (exp(x)-exp(-x))/(exp(x)+exp(-x))
+    * @param x argument
+    * @return	corresponding hyperbolic tangent (in range ]-1, 1[)
+    */
+    public static final double tanh (double x) {
+    	 double ex, ex1 ;
+    ex = Math.exp(x) ;
+    ex1 = 1./ex ;
+    return (ex - ex1) / (ex + ex1) ;
+    }
+
+   /** 
+    * tanh-1 (inverse function of tanh)
+    * @param x argument, in range ]-1, 1[ (NaN returned otherwise)
+    * @return	corresponding hyperbolic inverse tangent
+    */
+    public static final double atanh (double x) {
+    		return (0.5*Math.log((1.+(x))/(1.-(x))));
+    }
+
+    //  ===========================================================
+    //		sin(x)/x and Inverse
+    //  ===========================================================
+
+   /** 
+    * Function sinc(x) = sin(x)/x
+    * @param x argument (radians)
+    * @return	corresponding value
+    */
+    public static final double sinc(double x) {
+    	 double ax, y;
+    		 ax = Math.abs(x);
+    		 if (ax <= 1.e-4) {
+    			 ax *= ax;
+    			 y = 1 - ax*(1.0-ax/20.0)/6.0;
+    		 }
+    else y = Math.sin(ax)/ax;
+    		 return y;
+    }
+
+   /** Reciprocal */
+   /** 
+    * Function asinc(x), inverse function of sinc
+    * @param	x argument
+    * @return	y such that sinc(y) = x
+    */
+    public static final double asinc(double x) {
+    	 double ax,y;
+    		 ax = Math.abs(x);
+    		 if( ax <= 1.e-4) {
+    			 ax *= ax;
+    			 y = 1.0 + ax*(6.0 + ax*(9.0/20.0))/6.0;
+    		 }
+    else y = Math.asin(ax)/ax;
+    		 return (y);
+    }
+
+    //  ===========================================================
+    //		Exponential/Logarithm base 10
+    //  ===========================================================
+
+   /** 
+    * Compute just 10<sup>n</sup>
+    * @param	n Power to which to compute the value
+    * @return	10<sup>n</sup>
+    */
+    public static final double dexp(int n) {
+     int i = n;
+     int m = powers.length-1;
+     double x = 1;
+     boolean inv = false;
+       	if (n < 0) { inv = true; i = -n; }
+	while (i > m) { x *= powers[m]; i -= m; }
+	x *= powers[i];
+	if (inv) x = 1./x ;
+	return(x);
+    }
+
+
+   /** 
+    * Compute just 10<sup>x</sup>
+    * @param	x Power to which to compute the value
+    * @return	10<sup>x</sup>
+    */
+    public static final double dexp(double x) {
+     	return(Math.exp(x*ln10));
+    }
+
+   /** 
+    * Compute the log base 10
+    * @param	x Number (positive)
+    * @return	log<sub>10</sub>(x)
+    */
+    public static final double log(double x) {
+     	return(Math.log(x)/ln10);
+    }
+
+    //  ===========================================================
+    //		Matrices and Vectors 3x3
+    //  ===========================================================
+    
+    /**
+     * 3-Matrices Products
+     * @param  A 3x3 matrix
+     * @param  B 3x3 matrix
+     * @return R    = A * B
+     */
+    public static final double[][] m3p(double A[][], double B[][]) {
+      double[][] R = new double[3][3];
+    	int i, j;
+    	for (i = 0; i < 3; i++) for (j = 0; j < 3; j++)
+    	    R[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + A[i][2] * B[2][j];
+    	return (R);
+    }
+    
+    /** Transposed of a Matrix
+     * @param  A input matric
+     * @return R  = <sup>t</sup>(A)
+     */
+    public static final double[][] m3t(double A[][]) {
+    	double R[][] = new double[3][3];
+    	int i, j;
+    	for (i = 0; i < 3; i++) for (j = 0; j < 3; j++)
+    	    R[i][j] = A[j][i];
+    	return (R);
+    }
+
+}
Index: aladin/cds/astro/Astrocoo.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Astrocoo.java	2012-09-27 15:30:32.000000000 +0200
@@ -0,0 +1,945 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro ;
+
+/*==================================================================
+                Astrocoo class
+ *==================================================================*/
+
+import java.io.*;
+import java.text.*; 	 // for parseException
+
+/**
+ * This class defines the spherical coordinates used in Astronomy.
+ * It associates the coordinates on the sphere (defined in the
+ * <b>Coo</b> class) with the system (<b>Astroframe</b>) in which
+ * they are expressed. It also includes the accuracy (number of digits) 
+ * in which the coordinates are expressed, and the epoch of the position.
+ * <P> The typical usage of the Astrocoo class consists in:<OL>
+ * <LI> Define an astronomical coordinate frame by means of one of
+ *	the constructors;
+ * <LI> Assign a position in this frame via one of the <B>set</B> 
+ *       methods
+ * <LI> Convert to another frame via the  <B>convertTo</B> method
+ * <LI> The angles (in degrees) are best extracted via <B>getLon</B> and
+ *	<B>getLat</B> methods
+ * </OL>
+ * The edition of the position in an Astrocoo can be done in a StringBuffer
+ * (<B>edit</B> methods) with options like sexagesimal or decimal edition,
+ * or as a String with one of the available <B>toString</B> methods.
+ * @author Francois Ochsenbein, Pierre Fernique [CDS].
+ * Constants from slaLIB (P.T. Wallace)
+ * @see Astroframe
+ * @see Astroformat
+ * @version 1.0 : 03-Mar-2000<br>
+ * @version 1.1 : 24-Mar-2000 (Bug in ICRS Edition)<br>
+ * @version 1.2 : 14-Nov-2002 (Sylvaine Jaehn (Stage UTBM)) :
+ *                 Ajout methodes getLatPrec(),getLonPrec() et getPoint()<br>
+ * @version 1.3 : Jan 2004 (BB) : ajout de la methode equals.<br>
+ * @version 1.4 : Apr 2006 (FO) : Epoch may be within ()
+ * @version 1.4a: Apr 2006 (FO) : Be sure sexagesimal hours at least h m
+ * @version 1.5 : Oct 2006 (FO) : Be sure precision not larger than frame 
+ * 				   intrinsic precision
+ * @version 1.6 : Dec 2006 (FO) : Add <b>convert</b> method
+ */
+
+public class Astrocoo extends Coo implements Serializable {
+   final static public boolean DEBUG = false; // true;
+  //* One Coo consists in lon lat x y z (see Coo class)
+  /** The associated frame */
+    public Astroframe frame;
+  /** Epoch (Jyr) of the position */
+    public double epoch ;	// Epoch in Jyr.
+  /** The precision (number of decimals+1) of the longitude */
+    protected byte dlon;	// Original decimals for lon
+  /** The precision (number of decimals+1) of the latitude */
+    protected byte dlat;	// Original decimals for lat
+  /** 
+   * The precision is 0=unknown, 1=DEG, 3=ARCMIN, 5=ARCSEC, 8=MAS, etc .
+   * There is also an intrinsic precision associated to the frame. 
+   **/
+    protected byte precision ;	// 0 = unknown, 1=deg, 3=arcmin, 5=arcsec, 8=mas
+  /** How RA was entered, see {@link Astroformat} */
+    protected byte formRA;	// Entered format of RA / Longitude */
+
+    /** The editing option includes basic options described in 
+     * {@link Astroformat}, plus the EDIT_FRAME, EDIT_FULL and EDIT_2 options.
+     * It can be changed via the {@link #setEditing} method.
+    **/
+    protected short editing;
+
+    /** Definitions of Precisions for the angles */
+    static public final byte NONE = 0, DEG = 1, ARCMIN=3, ARCSEC=5, MAS=8 ;
+
+    /** Editing option to insert the name of the frame */
+    static public final short EDIT_FRAME = 0x100;
+    /** Editing option to separate the 2 components by a blank */
+    static public final short EDIT_2NUMBERS  = 0x200;
+    /** Editing option to write the Epoch */
+    static public final short EDIT_EPOCH = 0x400;
+    /** Editing option to write the MeanEpoch */
+    static public final short EDIT_MEAN_EPOCH = 0x800;
+    /** Editing option to show all decimals */
+    static public final short EDIT_FULL  = 0x1000;
+    /** The default edition options */
+    static public final short EDIT_DEFAULT = 
+	EDIT_FRAME|EDIT_EPOCH|EDIT_MEAN_EPOCH;
+
+    static final private String[] explain_precision = {
+	"unknown", "1degree", "0.1degree", "1arcmin", "0.1arcmin", "1arcsec",
+	"0.1arcsec", "10mas", "1mas", "0.1mas", "10여s",
+	"1여s", "0.1여s"
+    } ;
+    static final private String[] explain_edition = {
+	"frame", "separate_components", "epoch", "meanEpoch",
+	"full_precision"
+    };
+
+    /** Definitions of the symbols for the Edition of Coordinates */
+    static final char[] editing_options = {
+	's', 	// Sexagesimal edition
+	'd', 	// Decimal edition
+	':', 	// Sexagesimal edition with :
+	'u', 	// Sexagesimal edition with units
+	'f',	// Edit the Frame
+	'F',	// Edit with Full precision
+	'2',	// Edit with a blank between numbers
+	'E',	// Edit the epoch
+	'M',	// Edit the Mean Epoch 
+    };
+    static final String string_options = new String(editing_options);
+    static final short[] Editing_options = {
+	Editing.SEXA3, 		// 's'
+	Editing.DECIMAL,	// 'd'
+	Editing.SEXA3c,		// ':'
+	Editing.SEXA3h,		// 'u'
+	EDIT_FRAME,		// 'f'
+	EDIT_FULL,		// 'F'
+	EDIT_2NUMBERS,		// '2'
+	EDIT_EPOCH,		// 'E'
+	EDIT_MEAN_EPOCH,	// 'M'
+    };
+    /** 
+     * Explain the editing option of the coordinate
+     * @return A printable variant of format.
+    **/
+    static public final String explain(int editing) {
+      String xplain1 = Astroformat.explain(editing);
+      int flags = editing >> 8;
+      int i;
+       	if (flags == 0) return (xplain1);
+	StringBuffer buf = new StringBuffer(xplain1);
+	for (i=0; flags != 0; i++, flags >>= 1) {
+	    if ((flags&1) == 0) continue;
+	    if(buf.length()>0) buf.append(',');
+	    buf.append(explain_edition[i]);
+	}
+	return(buf.toString());
+     }
+
+    /**
+     * Interpret a text representing a frame
+     * @return A frame (null if not undestood)
+    **/
+    static public Astroframe parseFrame(Parsing txt) {
+      int posini = txt.pos;
+      Astroframe frame = null;
+      boolean bracketed, has_par=false, is_ok = true;
+      double equinox;
+      char c;
+        txt.gobbleSpaces();
+	bracketed = txt.match("(");
+	c = Character.toUpperCase(txt.currentChar());
+	if (c == 'I') {
+	    if (is_ok = txt.match("ICRS")) 
+	        frame = (Astroframe) new ICRS();
+	}
+	else if (c == 'G') {	// Galactic: accept G Gal, etc
+	    while (Character.isLetter(txt.currentChar()))
+		txt.advance(1);
+	    frame = (Astroframe) new Galactic();
+	}
+	else if (c == 'S') {	// Supergalactic
+	    while (Character.isLetter(txt.currentChar()))
+		txt.advance(1);
+	    frame = (Astroframe) new Supergal();
+	}
+	else if (c == 'F') {	// FK4 or FK5 ?
+	    if (txt.match("FK4")) {
+		if (has_par = txt.match('(')) {
+		    equinox = getEpoch(txt);
+		    frame = (Astroframe) new FK4(Astrotime.J2B(equinox));
+		}
+		else frame = (Astroframe) new FK4();
+	    }
+	    else if (txt.match("FK5")) {
+		if (has_par = txt.match('(')) {
+		    equinox = getEpoch(txt);
+		    frame = (Astroframe) new FK5(equinox);
+		}
+		else frame = (Astroframe) new FK5();
+	    }
+	    else is_ok = false;
+	}
+	else if (c == 'B') {	// B1950
+	    txt.match('B');
+	    if (Character.isDigit(txt.currentChar())) {
+		equinox = getEpoch(txt);
+		frame = (Astroframe) new FK4(Astrotime.J2B(equinox));
+	    }
+	    else is_ok = false;
+	}
+	else if (c == 'J') {	// J2000
+	    txt.match('J');
+	    if (Character.isDigit(txt.currentChar())) {
+		equinox = getEpoch(txt);
+		frame = (Astroframe) new FK5(equinox);
+	    }
+	    else is_ok = false;
+	}
+	else if (c == 'E') {	// Ecliptic
+	    while (Character.isLetter(txt.currentChar()))
+		txt.advance(1);
+	    if (has_par = txt.match('(')) {
+	        equinox = getEpoch(txt);
+	        frame = (Astroframe) new Ecliptic(equinox);
+	    }
+	    else if (Character.isDigit(txt.currentChar())) {
+		equinox = getEpoch(txt);
+		frame = (Astroframe) new Ecliptic(equinox);
+	    }
+	    else frame = (Astroframe) new Ecliptic();
+	}
+	else is_ok = false;
+	if (!is_ok) {
+	    txt.set(posini);
+	    return(null);
+	}
+
+	// Get Epoch, may be written ,Ep= or , or (...)
+	equinox = 0./0.;
+	if (!has_par) has_par = txt.match('(');
+	if (!has_par) txt.match(',');
+	if (Character.toUpperCase(txt.currentChar()) == 'E') {
+	    txt.advance(1);
+	    if (txt.currentChar() == 'p') {
+		while (Character.isLetter(txt.currentChar())) txt.advance(1);
+		if (txt.match('=')) {
+		    equinox = getEpoch(txt);
+		}
+		else is_ok = false;
+	    }
+	    else is_ok = false;
+	}
+	if (Double.isNaN(equinox)) 
+	    equinox = getEpoch(txt);
+	if (has_par) is_ok |= txt.match(')');
+	if (bracketed) is_ok |= txt.match(')');
+
+	if (is_ok) {
+	    txt.match(':');	// Frame may be followed by :
+	    if (!Double.isNaN(equinox)) {
+		if (DEBUG) System.out.println(
+		  "....parseFrame: calling setFrameEpoch(" + equinox + ")");
+		frame.setFrameEpoch(equinox);
+		if (DEBUG) System.out.println(
+		  "....parseFrame: epoch=" + frame.epoch);
+	    }
+	    return (frame);
+	}
+	txt.set(posini);
+	return(null);
+    }
+
+    //  ===========================================================
+    //			Constructors
+    //  ===========================================================
+
+    /**
+     * Create the default ICRS Astrocoo
+     */
+     public Astrocoo() {
+	this(new ICRS()) ;
+     }
+
+    /**
+     * Create an Astrocoo object: specify just frame, equinox, precision.
+     * Actual positions are normally specified by the <B>set</B> method.
+     * @param frame	one of the possible Astroframes
+     */
+     public Astrocoo(Astroframe frame) {
+       	this.frame = frame;
+	epoch = 0./0.;				// Unspecified epoch
+	dlon = dlat = precision = 0;
+	editing = (short)(frame.ed_lon|EDIT_DEFAULT);
+    	super.set();
+     }
+
+    /**
+     * Create an Astrocoo object with a known position.
+     * @param frame	one of the possible Astroframes
+     * @param lon Longitude of the position (degrees)
+     * @param lat Latitude of the position (degrees)
+     */
+     public Astrocoo(Astroframe frame, double lon, double lat) {
+	this(frame, lon, lat, 0./0.);
+    }
+
+    /**
+     * Create an Astrocoo object with a known position.
+     * @param frame	one of the possible Astroframes
+     * @param coo	the position.
+     --- Too many constructors !
+     public Astrocoo(Astroframe frame, Coo coo) {
+	this(frame, coo, 0./0.);
+    }
+     */
+
+    /**
+     * Create an Astrocoo object from an existing one.
+     * It is equivalent to (<em>coo</em>.clone()).convertTo(<em>frame</em>)
+     * @param frame	one of the possible Astroframes
+     * @param coo	the position in some other frame.
+     */
+    /* --- Useless
+     public Astrocoo(Astroframe frame, Astrocoo coo) {
+       	this.frame = frame;
+	editing = (short)(frame.ed_lon|EDIT_FRAME|EDIT_EPOCH);
+	this.convertFrom(coo);
+    o}
+    --- */
+
+    /**
+     * Create an Astrocoo object with a known position + Epoch
+     * @param frame	one of the possible Astroframes
+     * @param coo	the position.
+     * @param epoch 	Epoch of the position, in Jyr (see Astrotime)
+     --- Too many constructors !
+     public Astrocoo(Astroframe frame, Coo coo, double epoch) {
+       	this.frame = frame;
+	editing = (short)(frame.ed_lon|EDIT_FRAME|EDIT_EPOCH);
+    	this.set(coo, epoch);
+    }
+     */
+
+    /**
+     * Create an Astrocoo object with a known position at given epoch.
+     * @param frame	one of the possible Astroframes
+     * @param lon Longitude of the position (degrees)
+     * @param lat Latitude of the position (degrees)
+     * @param epoch Epoch of the position, in Jyr (see Astrotime)
+     */
+    public Astrocoo(Astroframe frame, double lon, double lat, double epoch) {
+    	this.frame = frame;
+	editing = (short)(frame.ed_lon|EDIT_FRAME|EDIT_EPOCH);
+	this.epoch = epoch;		// Specified epoch
+	dlon = dlat = precision = 0; 	// Precision unknown
+    	super.set(lon, lat);
+    }
+
+    /**
+     * Create an Astrocoo object from a position (Epoch)
+     * @param frame	one of the possible Astroframes
+     * @param text Text with position, possibly followed by an epoch.
+     * 		Valid texts are e.g.
+     * 		"12 34 12.45 -42 12 76.4 J1991.25"    or
+     * 		"12 34 12.45 -42 12 76.4 (J1991.25)"
+     */
+    public Astrocoo(Astroframe frame, String text) throws ParseException {
+    	this.frame = frame;
+	this.set(text);
+    }
+
+    /**
+     * Create an Astrocoo object from just a string.
+     * @param text Text with frame, position, possibly followed by an epoch.
+     * 		Valid texts are e.g.
+     * 		"J2000: 12 34 12.45 -42 12 76.4 J1991.25"    or
+     * 		"(ICRS) 12 34 12.45 -42 12 76.4 (J1991.25)"
+     */
+    public Astrocoo(String text) throws ParseException {
+      Parsing txt = new Parsing(text);
+    	this.frame = parseFrame(txt);
+	if (frame == null) throw new ParseException
+	    ("****Astrocoo: argument '" + text + "' (no frame)", txt.pos);
+	this.set(txt.toString());
+    }
+
+    public Object clone() {
+       	Astrocoo c = (Astrocoo) super.clone();
+    	return c;
+    }
+
+
+    //  ===========================================================
+    //			Interpretation of text (Parsing)
+    //  ===========================================================
+    //
+
+    /**
+     * Interpret an epoch, eventually within ( ).
+     * We accept JD, MJD, J or B times.
+     * @param txt Text to interpret
+     * @return    the epoch in Jyr, NULL if not found
+    **/
+    public static double getEpoch(Parsing txt) {
+      Astrotime t = new Astrotime();
+      int posini = txt.pos;
+      boolean bracketed, has_epoch;
+      double epoch = 0./0.;
+      	txt.gobbleSpaces();
+	if (bracketed = txt.match("(") ) txt.gobbleSpaces();
+	else if (Character.isLetter(txt.currentChar())) ;
+	else {
+	    txt.set(posini);
+	    return(0./0.);
+	}
+	if (has_epoch = t.parsing(txt)) {
+	    epoch = t.getJyr();
+	    if (bracketed) 		// Must match the )
+		has_epoch = txt.match(")");
+	}
+	if (!has_epoch) {		// Epoch not matched, ignore...
+	    epoch = 0./0.;
+	    txt.set(posini);
+	}
+	return(epoch);
+    }
+
+    /**
+     * Interpret the string and convert to Coo + Epoch.
+     * Called from set and parse routines.
+     * @param txt to interpret as a Parsing object "12 34.5 -72 54 J1991.25"
+     * @return true if OK (2 coordinates found, and possibly an epoch).
+     * 	If false, no mouvement in txt.
+    **/
+     public boolean parsing(Parsing txt) {
+      boolean f15 = frame.hms;
+      boolean sexa;
+      double lon, lat;
+      precision = dlon = dlat = 0;
+      int posini = txt.pos;
+      int pos, form;
+        set(); this.epoch = 0./0.;
+
+	// Extract the longitude or RA
+	txt.gobbleSpaces();
+	lon = txt.parseSexa();
+	if (txt.inError()) { txt.set(posini); return(false); }
+	dlon = (byte)(1+txt.decimals());
+	sexa = txt.isSexa();
+	formRA = (byte)txt.format();	// Tells how RA/Longitude was coded.
+	// Modify time to angle if necessary, e.g. "12h38m-27&deg;23'
+	if (txt.isTime()) f15 = true;
+	else if (txt.isAngle()) f15 = false;
+	else if (sexa) ;	// Stick to default hms
+	else if (dlon>0)	// Decimal values are always degrees.
+	    f15 = false;
+	if (f15) { lon *= 15.; if (dlon>0) dlon--; }
+	// Extract the Latitude or Dec
+	txt.gobbleSpaces();
+	lat = txt.parseSexa();
+	if (txt.inError()) { txt.set(posini); return(false); }
+	dlat = (byte)(1+txt.decimals());// Don't accept latitude in time...
+	sexa |= txt.isSexa();
+	// Precision is the highest number of decimals
+	// The actual precision should be the lowest, but...
+	precision = dlon>dlat ? dlon : dlat;
+	/*+++  Don't touch at the Editing options !
+	// Set the editing options.
+ 	editing = (editing&(~0xff)) | formRA; 	// The RA way of edition.
+	if (sexa && !Astroformat.isSexa(editing)) 
+	    editing = (short)Editing.SEXA3c;
+	---*/
+	// Complete the coordinate
+	super.set(lon, lat);
+	// Position may be followed by an epoch -- the epoch may be within ()
+	pos = txt.pos;
+	txt.gobbleSpaces();
+	if (txt.pos < txt.length) { 
+	  Astrotime t = new Astrotime(); 
+	  boolean has_epoch, bracketed;
+	    if (bracketed = txt.match("(") ) txt.gobbleSpaces();
+	    if (has_epoch = t.parsing(txt)) {
+		this.epoch = t.getJyr();
+		if (bracketed) 		// Must match the )
+		     has_epoch = txt.match(")");
+	    }
+	    if (!has_epoch) {		// Epoch not matched...
+		this.epoch = 0./0.;
+		txt.set(pos);
+	    }
+	}
+	return(true);
+     }
+
+    /**
+     * Parsing method: interpret a String.
+     * @param txt to interpret.
+     * @param offset starting position in text
+     * @return new position.
+    **/
+     public int parse (String txt, int offset) {
+      Parsing t = new Parsing(txt, offset);
+	if (parsing(t)) return(t.pos);
+	return(offset);
+     }
+
+  //  ===========================================================
+  //			Set in Astrocoo
+  //  ===========================================================
+
+  /**
+    * Inherited from super class (Coo): 
+    *     set(lon, lat)  
+    *     set(x, y, z) 
+    *     set(Coo)
+   **/
+
+   /**
+    * Set a position from an existing one (copy).
+    * @param coo  the Astrocoo to copy.
+   **/
+    public void set(Astrocoo coo) {
+	super.set((Coo)coo);
+	this.frame = coo.frame;
+	this.epoch = coo.epoch;
+	this.dlon  = coo.dlon;
+	this.dlat  = coo.dlat;
+	this.precision = coo.precision;
+    }
+
+   /**
+    * Set a position from a text which may contain position and Epoch.
+    * The precision is adapted to the number of significant digits
+    * existing in the input text string.
+    * @param text  Longitude + latitude in text
+   **/
+    public void set(String text) throws ParseException {
+      Parsing t = new Parsing(text);
+      	if (parsing(t))		// Various items found.
+	    t.gobbleSpaces();
+	if (t.pos != t.length) throw new ParseException
+	    ("****Astrocoo: argument '" + text + "'", t.pos);
+    }
+
+   /**
+    * The following 'set' methods are inherited from the parent
+    * set(lon, lat); set(x, y, z); set(Coo); set();
+    * For these methods, the Epoch is kept.
+   **/
+
+   /**
+    * Set position + epoch.
+    * The precision is not changed.
+    * @param coo   the lon+lat
+    * @param epoch the epoch.
+   **/
+    public void set(Coo coo, double epoch) {
+	this.epoch = epoch;
+	super.set(coo);
+    }
+
+   /**
+    * Change the precision of the data
+    * @param  precision integer number, typically one of the values NONE (0),
+    * 	DEG (1), ARCMIN (3), ARCSEC (5),  MAS (8);
+    * 	use ARCSEC+1 for 0.1arcsec, MAS-1 for 10mas, etc...
+   **/
+    public void setPrecision(int precision) {
+	this.precision = (byte)precision;
+    }
+
+   /**
+    * Change the precision of the data
+    * @param  dlon Precision number on longitude (RA).
+    * @param  dlat Precision number on latitude (Dec).
+   **/
+    public void setPrecision(int dlon, int dlat) {
+	this.dlon = (byte)dlon;
+	this.dlat = (byte)dlat;
+	this.precision = this.dlon>this.dlat ? this.dlon : this.dlat;
+    }
+
+   /**
+    * Change the default way of edition
+    * @param  edit_option  A mixture of {@link Astroformat} options,
+    * 			and EDIT_FRAME EDIT_FULL.
+   **/
+    public void setEditing(int edit_option) {
+	this.editing = (short)(edit_option&0xffff);
+	if ((edit_option&EDIT_FULL)!=0) 	// Full precision ~ 0.01여s
+		setPrecision(12);
+    }
+
+   /**
+    * Change the Epoch of the data
+    * @param  epoch the epoch of the coordinates 
+    * @return true when OK.
+   **/
+    public boolean setEpoch(double epoch) {
+       this.epoch = epoch;
+       return(true);
+    }
+
+  //  ===========================================================
+  //			Get parts of Astrocoo
+  //  ===========================================================
+
+   /**
+    * Get an explicit designation of the frame
+    * @return	the explanation as a string
+   **/
+    public final Astroframe getFrame() {
+	return(frame);
+    }
+
+   /**
+    * Get the precision of the current value
+    * @return	the value.
+   **/
+    public final int getPrecision() {
+	return precision;
+    }
+
+   /**
+     * Get the precision on the latitude
+     * @return the number representing the precision of the latitude
+     */
+    public byte getLonPrec() {
+    	return (dlon);
+    }
+
+    /**
+     * Get the precision on the longitude
+     * @return the number representing the longitude precision
+     */
+    public byte getLatPrec() {
+    	return (dlat);
+    }
+
+   /**
+    * Get the defaut editing option.
+    * Can be edited via e.g. Astroformat.explain()
+    * @return	the value.
+   **/
+    public final int getEditing() {
+	return editing;
+    }
+
+  //  ===========================================================
+  //			Dump the coordinates
+  //  ===========================================================
+
+    /**
+     * Dump the contents of an Astrocoo.
+     * @param title A title to precede the dump
+    **/
+     public void dump(String title) {
+      StringBuffer b = new StringBuffer(256);
+      int i; double e;
+        // Subtitle = same length as title, but blank.
+	for (i=title.length();--i>=0;) b.append(' ');
+	String blanks = b.toString(); b.setLength(0);
+      	b.append(title); b.append("Astroframe="); b.append(this.frame);
+	b.append(", def.Ep=J");
+	b.append(this.frame.base_epoch);
+	/* Edit epoch below 
+	b.append(";");
+	if (Double.isNaN(this.epoch)) { 
+	    b.append(" defEp=J"); 
+	    e = this.frame.base_epoch; 
+	}
+	else { b.append(" epoch=J"); e = this.epoch; }
+	b.append(e); 
+	*/
+	b.append('\n'); b.append(blanks);
+	b.append("editing=0x"); b.append(Integer.toHexString(editing));
+	b.append('='); b.append(explain(editing));
+	b.append('\n'); b.append(blanks);
+	b.append("precision="); b.append(precision);
+	b.append(", dlon="); b.append(dlon);
+	b.append(", dlat="); b.append(dlat);
+	b.append(", formRA=0x"); b.append(Integer.toHexString(formRA));
+	b.append('('); b.append(Astroformat.explain(formRA)); b.append(')'); 
+	// Add the position + Epoch
+	b.append('\n'); b.append(blanks); b.append("  "); super.editCoo(b, 12);
+	b.append("  Epoch=J"); b.append(this.epoch);
+	System.out.println(b.toString());
+	super.dump(blanks);
+     }
+
+  //  ===========================================================
+  //			Compare two Coordinates
+  //  ===========================================================
+
+   /**
+    * Compare 2 coordinates.
+    * @param o Objet a comparer.
+    * @return Vrai si o est identique a this.
+   **/
+    public boolean equals(Object o) {
+	boolean res = false;
+	if(o instanceof Astrocoo) {
+      	    Astrocoo a = (Astrocoo)o;
+      	    res = this.frame.equals(a.frame)	// Must have same frame
+	       && super.equals(a);		// and same position
+    	}
+    	return res;
+    }
+
+  //  ===========================================================
+  //			Edit the Coordinates
+  //  ===========================================================
+
+  /**
+   * Convert the String of editing options into an integer
+   * @param text List of options:<PRE>
+   *	d = edit in Decimal
+   *	s = edit in Sexagesimal
+   *	: = separate sexagesimal parts with the colon
+   *	u = separate sexagesimal parts with the relevant unit (h m s d m s)
+   *	f = edit also the frame (system+equinox)
+   *	F = edit in full precision (ignore the precision of the system)
+   * 	2 = edit with a blank between numbers
+   *	E = edit the epoch
+   *	M = edit the Mean Epoch 
+   *	* = default edition options
+   *</PRE>
+  **/
+    public static int editingOptions(String text) 
+	throws IllegalArgumentException
+    {
+	char b[] = text.toCharArray();
+	int i, j, n; int o = 0;
+	for (i=0; i<b.length; i++) {
+	    if (b[i] == '*') { o |= EDIT_DEFAULT; continue; }
+	    for (j=0; j<editing_options.length; j++) {
+		if (b[i] == editing_options[j]) break;
+	    }
+	    if (j==editing_options.length) throw new IllegalArgumentException
+		("****Astrocoo: '" + text + "'; accepted="
+		 + string_options);
+	    if (Editing_options[j] < 0x10) o &= ~0xf;
+	    o |= Editing_options[j];
+	}
+	return(o);
+    }
+
+   /**
+    * Function to edit one number representing an apoch in Jyr
+    * @param buf  Buffer where the result is appended as Jxxx or Bxxx
+    * @param Jyr The epoch, in Julian Years. A NaN value is edited as null.
+    * @return	the StringBuffer
+   **/
+    protected final StringBuffer editEpoch(StringBuffer buf, double Jyr) {
+	double ep = epoch;
+	if (Double.isNaN(ep)) 
+	    buf.append(' ');
+	else if (this.frame instanceof FK4) {
+	    buf.append('B');
+	    ep =  Astrotime.J2B(epoch);
+	}
+	else buf.append('J');
+	// Edit number Up to 3 decimals
+	ed.editDecimal(buf, ep, 4, -3, Editing.ZERO_FILL);
+	return(buf);
+    }
+
+   /**
+    * Method to edit the Coordinates in a StringBuffer
+    * @param buf  Buffer where the result is appended
+    * @param opt  A mixture of the options ED_COLON, ED_DECIMAL,
+    *			EDIT_FULL, EDIT_SEXA, EDIT_FRAME, EDIT_2NUMBERS
+    * @return	the StringBuffer
+   **/
+
+    public final StringBuffer edit(StringBuffer buf, int opt) {
+      boolean f15 = false;
+      int prec = precision&15;
+      if (prec == 0) 	// Precision unknown: up to precision of frame.
+	  prec = frame.precision;
+      else if (prec > frame.precision) 	// Limit to intrinsic precision
+	  prec = frame.precision;
+      int o = opt&(~(EDIT_FULL|EDIT_FRAME));
+    	if (DEBUG) System.out.println(
+		"....edit(opt=0x" + Integer.toHexString(opt) 
+		+ "), epoch=" + epoch + ", precision=" + prec 
+		+ ", dlon=" + dlon + ", dlat=" + dlat + ", lon=" + lon);
+	if ((opt&EDIT_FULL) != 0) 	// Edit full precision
+	    prec=12;
+//System.out.println("....Astrocoo.edit(prec=" + prec + ")");
+	// Edit the Frame
+	if ((opt&EDIT_FRAME) != 0) {
+	    buf.append(frame.toString());
+	    buf.append(' ');
+	}
+	// Edit the RA or Longitude
+	double x = this.getLon();
+	int nint = 3;
+	int nd = prec;
+	// Must it be expressed in time ?
+	if (Astroformat.isSexa(o))       f15 = frame.hms;
+	/*--- old code:
+	if (Astroformat.isTime(o))       f15 = true;
+	else if (Astroformat.isAngle(o)) f15 = false;
+	else if (Astroformat.isSexa(o))  f15 = frame.hms;
+	--- */
+	if (f15) {
+	    nint--; x /= 15.0;
+	    if (nd>0) { 	// v1.4a: Sexagesimal at least h min 
+		nd++; 
+		if (nd<3) nd=3;
+	    }
+	    else {
+		nd--;
+		if (nd>-3) nd=-3;
+	    }
+	}
+	// editDecimal does edit in Sexagesimal if this option is set.
+	ed.editDecimal(buf, x, nint, nd-1, Editing.ZERO_FILL|o);
+	// Separate the numbers if wished
+	if ((opt&EDIT_2NUMBERS) != 0) buf.append(' ');
+	// Edit the Dec or Latitude
+	if (Astroformat.isTime(o)) {
+	    if (Astroformat.isSexa(o)) o -= 2;	// Replace h m s by d m s
+	    else o++;
+	}
+	ed.editDecimal(buf, this.getLat(), 3, prec-1,
+	    Editing.ZERO_FILL| Editing.SIGN_EDIT|o);
+
+    	// Add the Epoch within parentheses
+    	if (((opt&EDIT_EPOCH)!=0) && (!Double.isNaN(epoch))) {
+	    buf.append(" (");
+	    editEpoch(buf, epoch);
+    	    buf.append(')');
+    	 }
+    	 return (buf);
+     }
+
+  /**
+   * Customized edition of Coordinates to a String
+   * @param  edit_option  A mixture of {@link Astroformat} options,
+   * 			and EDIT_FRAME EDIT_FULL.
+   * @return the edited coordinates in a string
+   */
+   public String toString(int edit_option) {
+      StringBuffer buf = new StringBuffer(80) ;
+ 	this.edit(buf, edit_option) ;
+ 	return buf.toString();
+   }
+
+  /**
+   * Customized edition of Coordinates to a String
+   * @param options  a string with the option letters (see edit)
+   * @see   Astrocoo#editingOptions
+   * @return the edited coordinates in a string
+   */
+   public String toString(String options) throws IllegalArgumentException {
+      StringBuffer buf = new StringBuffer(80) ;
+ 	this.edit(buf, editingOptions(options)) ;
+ 	return buf.toString();
+   }
+
+   /**
+    * Default edition: use what's stored
+    * @return the edited string
+   **/
+   public String toString() {
+      // System.out.println("equinox==" + equinox) ;
+      // System.out.println("z=" + z) ;
+      StringBuffer buf = new StringBuffer(80) ;
+      	this.edit(buf, editing) ;	// Frame Edition
+      	return buf.toString();
+   }
+
+  //  ===========================================================
+  //			Convert Coordinates
+  //  ===========================================================
+
+   /**
+    * Transform the position into another frame.
+    * @param new_frame	The frame of the resulting position.
+   **/
+    public void convertTo(Astroframe new_frame) {
+	/* Verify first if frames identical -- then nothing to do ! */
+	if (this.frame.equals(new_frame)) {
+	    if(DEBUG) System.out.println("....Frame " + this.frame 
+		    + "=" + new_frame);
+	    return;
+	}
+
+	// Move via ICRS
+	if(DEBUG) System.out.println("....Astrocoo.convert: via ICRS:  "
+		+ this.frame + " => ICRS => " + new_frame);
+	this.frame.toICRS((Coo)this);	// Position now in ICRS
+	if(DEBUG) this.dump("#ICRS: ");
+	new_frame.fromICRS((Coo)this);	// Position now in new_frame
+	if(DEBUG) this.dump("#NewF: ");
+	this.frame = new_frame;
+	this.lon = this.lat = 0./0.;	// Actual angles not recomputed
+  }
+
+   /**
+    * Transform the celestial position.
+    * @param source	Source position (with its frame)
+    * @param target	Target position (coordinates part replaced)
+   **/
+    public static void convert(Astrocoo source, Astrocoo target) {
+	Coo coo = (Coo) target;
+	coo.set((Coo)source);		// Sets x y z lon lat
+	if (target.frame.equals(source.frame)) {
+	    if(DEBUG) System.out.println("....Astrocoo.convert: Frame " 
+		    + source.frame + "=" + target.frame);
+	    return;
+	}
+	source.frame.toICRS(coo);	// now in ICRS
+	if(DEBUG) target.dump("#ICRS: ");
+	target.frame.fromICRS(coo);
+	if(DEBUG) target.dump("#NewF: ");
+    }
+
+
+   /**
+    * Transform the celestial position given in the argument into
+    * 	its own frame.
+    * @param coo	Position expressed in some other frame (not modified)
+   **/
+   /* -- Removed (use convertTo)
+    public void convertFrom(Astrocoo coo) {
+      Astroframe new_frame = this.frame;
+
+	// Copy the epoch & precision definitions.
+	this.epoch = coo.epoch;
+	this.dlon  = coo.dlon;
+	this.dlat  = coo.dlat;
+	this.precision = coo.precision;
+	this.formRA = coo.formRA;
+	// Editing options: no change.
+
+	// Copy coordinate details.
+	super.set((Coo)coo);
+	this.frame = coo.frame;
+
+	this.convertTo(new_frame);
+  }
+  -- */
+
+}
Index: aladin/cds/astro/Astroformat.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Astroformat.java	2012-09-27 15:30:32.000000000 +0200
@@ -0,0 +1,316 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                Astroformat class
+ *==================================================================*/
+
+/**
+ * This class contains definitions used in Parsing and Editing of numbers,
+ * and the default representation of the <b>NaN</b> <em>(null)</em> value.
+ * @author Francois Ochsenbein -- francois@astro.u-strasbg.fr
+ * @version 1.0 : 12-Aug-2004 as a separate entiry
+ * @version 1.1 : 12-Aug-2006 added DATE_MJD
+ * @version 1.2 : 30-Oct-2006 added DATE_DIFF
+ */
+
+public class Astroformat {
+    /** The default way of representing the NULL (unknown) numbers .
+     * The first element of the array contains the default_null.
+     * Implicitely the last character of any NULL representation 
+     * may be repeated.
+    **/
+     public String[] nulls;
+
+    	/** Format of number is <em>decimal</em> */
+    static public final int DECIMAL=0;
+    	/** Format of number contains the <em>E</em> notation */
+    static public final int EFORMAT=1;
+    	/** Format of number is of the form 
+     	 *  <em>mantissa</em><tt>x10</tt><em>&pm;exp</em> */
+    static public final int FACTOR=10;
+    	/** Format of number is sexagesimal (2 components h m) */
+    static public final int SEXA2=2;
+    	/** Format of number is sexagesimal (3 components h m s) */
+    static public final int SEXA3=3;
+    	/** Format of number is sexagesimal (2 components h:m) */
+    static public final int SEXA2c=4;
+    	/** Format of number is sexagesimal (3 components h:m:s) */
+    static public final int SEXA3c=5;
+    	/** Format of number is sexagesimal angle (2 components dm) */
+    static public final int SEXA2d=6;
+    	/** Format of number is sexagesimal angle (3 components dms) */
+    static public final int SEXA3d=7;
+    	/** Format of number is sexagesimal time  (2 components hm) */
+    static public final int SEXA2h=8;
+    	/** Format of number is sexagesimal time  (3 components hms) */
+    static public final int SEXA3h=9;
+    	/** Format of number is sexagesimal 1 component (with : or d)*/
+    static public final int SEXA1d=11;
+    	/** Format of number is sexagesimal 1 component (with h)     */
+    static public final int SEXA1h=12;
+    	/** Format of number is sexagesimal 1 component (with &deg;)     */
+    static public final int SEXA1o=13;
+    	/** Format of number is sexagesimal 2 component (with &deg; ')   */
+    static public final int SEXA2o=14;
+    	/** Format of number is sexagesimal 3 component (with &deg; ' ") */
+    static public final int SEXA3o=15;
+    	/** The number represents a date; variants follow */
+    static public final int DATE      =128;
+    	/** Format of date contains alphabetical month */
+    static public final int DATE_alpha=1|128;
+    	/** Format of date   is Year and Month */
+    static public final int DATE_YM   =0|128;
+    	/** Format of date   is Year and Month */
+    static public final int DATE_MY   =2|128;
+    	/** Format of date   is Year and Day, day in range [1..366] */
+    static public final int DATE_YD   =4|128;
+    	/** Format of date   is Day and Year, day in range [1..366] */
+    static public final int DATE_DY   =6|128;
+    	/** Format of date   is Year Month Day */
+    static public final int DATE_YMD  =8|128;
+    	/** Format of date   is Day Month Year */
+    static public final int DATE_DMY  =10|128;
+    	/** Format of date   is Month Day Year */
+    static public final int DATE_MDY  =12|128;
+    	/** Format of date   is Month Year Day */
+    static public final int DATE_MYD  =14|128;
+    	/** Time expressed as days (elapsed time) */
+    static public final int DATE_DIFF =5|128;
+    	/** Number must be signed (contains a '+' sign  if positive) */
+    static public final int SIGN_EDIT=16;
+    	/** Number must be left-filled with zeroes  */
+    static public final int ZERO_FILL=32;
+    	/** Numbers are truncated in their edition  */
+    static public final int TRUNCATE =64;
+    	/** Number represents a date (returned as MJD) */
+    static public final int DATE_COMP =128;
+
+    /** The interesting pictures for Complex numbers */
+    static protected final String pic1 = "YMDhmsymDdMS";
+    /** Explanation of the meaning */
+    static protected final String[] pic1_explain = {
+	"Year", "Month", "Day", "hour",   "minute", "second", 
+	"year", "month", "day", "degree", "Minute", "Second"
+    };
+
+    /** The standard edition of month names */
+    static public String[] month_list = {
+	"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
+	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
+    /** Characteristics of the formats as bit patterns, where
+     *  0x10 = is Sexa
+     *  0x01 = is Time
+     *  0x02 = is Angle
+    **/
+    static private final byte[] properties = {
+	0x00, 	// 0 = DECIMAL -- edited in editDouble
+	0x00,	// 1 = EFORMAT -- edited in editDouble
+	0x10, 	// 2 = SEXA2   -- hh mm
+	0x10,	// 3 = SEXA3   -- hh mm ss
+	0x10,	// 4 = SEXA2c  -- hh:mm
+	0x10,	// 5 = SEXA3c  -- hh:mm:ss
+	0x12,	// 6 = SEXA2d
+	0x12,	// 7 = SEXA3d  -- d m s separator
+	0x11,	// 8 = SEXA2h
+	0x11,	// 9 = SEXA3h  -- h m s separator
+	0x00,	//10 = FACTOR  -- not sexa
+	0x02,	//11 = SEXA1d  -- a single number followed by d
+	0x01,	//12 = SEXA1h  -- a single number followed by h
+	0x02,	//13 = SEXA1o  -- a single number followed by &deg;
+	0x12,	//14 = SEXA2o  -- 2 components &deg; '
+	0x12,	//15 = SEXA3o  -- 3 components &deg; ' "
+    };
+    /** Arrays used by Parsing.form() to explain the input */
+    static private final String[] explain_form = {
+      "decimal",    "E-format", 
+      "sexa(h,m)",  "sexa(h,m,s)", "sexa(h:m)",     "sexa(h:m:s)",
+      "sexa_d_m",   "sexa_d_m_s",  "sexa_h_m",      "sexa_h_m_s",
+      "x10-format",                "decimal_d",     "decimal_h",
+                "decimal_\u00B0",  "sexa_\u00B0_'", "sexa_\u00B0_'_\""
+    };
+    static private final String[] explain_date = {
+      "date(YM)",   "date(Ymon)",  "date(MY)",  "date(monY)", 	// Year+Month
+      "date(YD)",   "#mjd-5#",     "date(DY)",	"#mjd-7#", 	// year + yday
+      "date(YMD)",  "date(YmonD)", "date(DMY)", "date(DmonY)",	// 3 components
+      "date(MDY)",  "date(monDY)", "date(MYD)", "date(monYD)",	// 3 components
+    };
+    static private final String[] explain_pec = {
+      "", ",signed", ",zero-filled", ",signed,zero-filled"
+    };
+
+    /** 
+     * Explain the 'form' of the last parsed number
+     * @return A printable variant of format.
+     */
+    static public final String explain(int bin_form) {
+      int k = (bin_form)&0xff;
+      String s;
+      // System.out.println("....form: flags=0x"+Integer.toHexString(flags)
+      //                   +", k="+k);
+        s = (k&DATE_COMP)!=0 ? explain_date[k&0xf] :  explain_form[k&0xf];
+        return (s + explain_pec[(k>>4)&3]);
+    }
+
+    /** 
+     * Test whether a format indicates a Sexagesimal coding.
+     * @return true if it does.
+     */
+    static public final boolean isSexa(int bin_form) {
+	return((properties[bin_form&0xf]&0x10)!=0);
+    }
+
+    /** 
+     * Test whether a format indicates a Date (YMD).
+     * Units are days (a date is expressed as MJD)
+     * @return true if it does.
+     */
+    static public final boolean isDate(int bin_form) {
+	return(((bin_form&DATE)!=0) && (!isDays(bin_form)));
+    }
+
+    /** 
+     * Test whether a format indicates a number of days.
+     * Similar to isTime, but units are days.
+     * @return true if it does.
+     */
+    static public final boolean isDays(int bin_form) {
+	return((bin_form&(DATE_DIFF|0xf)) == DATE_DIFF);
+    }
+
+    /** 
+     * Test whether a format indicates Time (hms). 
+     * Units are then hours.
+     * @return true if it does.
+     */
+    static public final boolean isTime(int bin_form) {
+	return((properties[bin_form&0xf]&1)!=0);
+    }
+
+    /** 
+     * Test whether a format indicates Angle (dms or &deg;'"). 
+     * Units are then degrees
+     * @return true if it does.
+     */
+    static public final boolean isAngle(int bin_form) {
+	return((properties[bin_form&0xf]&2)!=0);
+    }
+
+    /*==================================================================
+      			Explain the pictures
+     *==================================================================*/
+
+    /** 
+     * Explain the conventions of "complex" templates.
+     * 		Letters are Y y (years) M (month) D (day) h (hour) m (minutes)
+     * 		s (seconds) d (degrees) f (fractions), and punctuations like
+     * 		: (colon) / (slash), etc. 
+     * @param	pic "picture" which specifies the format
+     * @return  the explanations
+     */
+     public static final String explainComplex(String pic) {
+      StringBuffer buf = new StringBuffer(128);
+      char[] typ6 = new char[6];
+      char[] apic = pic.toCharArray();
+      int epic = pic.length();
+      int ipic = 0;
+      int len, k;
+      char c;
+
+	typ6[0] = typ6[1] = typ6[2] = typ6[3] = typ6[4] = typ6[5] = 
+	    Character.MIN_VALUE;
+	while (ipic<epic) {
+	    c = apic[ipic++]; 
+	    k = pic1.indexOf(c);
+	    if (k<0) continue;
+	    for (len=1; (ipic<epic) && apic[ipic] == c; ipic++) len++;
+	    typ6[k%6] = Character.toLowerCase(c);
+	}
+	buf.append("Complex ");
+	if (typ6[0] != Character.MIN_VALUE) buf.append("date");
+	else if ((typ6[2] != Character.MIN_VALUE) || (typ6[3] == 'h'))
+	     buf.append("time");
+	else buf.append("angle");
+	buf.append(" made of:") ;
+
+	for(ipic=0; ipic<epic; ) {
+	    c = apic[ipic++];
+	    k = pic1.indexOf(c);
+	    if ((k<0) && (c != 'f')) continue;
+	    buf.append(' ');
+	    if (k<0) buf.append("and fraction");
+	    else buf.append(pic1_explain[k]);
+	    for (len=1; (ipic<epic) && apic[ipic] == c; ipic++) len++;
+     	}
+	return(buf.toString());
+     }
+
+    /*==================================================================
+      			Constructors
+     *==================================================================*/
+
+    /**
+     * Create an Astroformat with the defaut "---" edition for NULL values.
+    **/
+    public Astroformat() {
+	setNaN("---");
+    }
+
+    /**
+     * Create an Astroformat with the defaut "---" edition for NULL values.
+    **/
+    public Astroformat(String default_null) {
+	setNaN(default_null);
+    }
+
+    /*==================================================================
+     * 			Additional acceptances
+     *==================================================================*/
+
+    /**
+     * Change the default edition of NULL.
+     * All alternative representations are removed.
+     * @param default_null The default <em>null</em> representation
+    **/
+    public void setNaN(String default_null) {
+	nulls = new String[2];
+	nulls[0] = default_null;
+	nulls[1] = null;
+    }
+
+    /**
+     * Give alternative representation of nulls.
+     * @param representation An additional possible representation of
+     * 		a <em>null</em>. The last character may be repeated.
+    **/
+    public void acceptAsNaN(String representation) {
+	int i = nulls.length-1;
+	if (nulls[i] != null) {		// Need an extension
+	    ++i;
+	    String[] array = new String[i+2];
+	    System.arraycopy(nulls, 0, array, 0, i);
+	    nulls = array;
+	    nulls[i+1] = null;
+	}
+	nulls[i] = representation;
+    }
+
+}
Index: aladin/cds/astro/Astroframe.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Astroframe.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,227 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+import java.io.Serializable;
+
+/**
+ * This abstract class defines the required methods to instanciate the
+ * definition of a frame used for astronomical coordinates.
+ * @author Francois Ochsenbein
+ * @version 1.1 23-Apr-2006: addition of toICRS(6-D vector), and ICRSmatrix.
+ * @version 1.2 06-Jun-2006: simplified version, only 2 abstract methods
+ *          required: toICRSmatrix() and toICRS()
+ *
+ */
+public abstract class Astroframe implements Serializable {
+    static private final boolean DEBUG=false;
+    static private Editing edframe = new Editing("?frame?");
+    /** 
+     * The name of the frame (normally assigned at instanciation) 
+    **/
+    public String name = "*undefined*" ;
+
+   /** 
+    * The defaut epoch, a constant which cannot be changed for a frame.
+    **/
+    public double base_epoch = 2000.;
+
+   /** 
+    * The epoch, expressed in Julian Year.
+    * This epoch may be changed by setFrameEpoch.
+    **/
+    public double epoch = 2000.;
+
+    /**
+     * The conversion to ICRS, if it is a simple rotation.
+    **/
+    public double[][] ICRSmatrix = null;
+
+    /** 
+     * The defaut precision (0=unknown, 3=1', 5=1").
+     * The precision value is expressed as the number of decimals (+1), i.e.
+     * 0=unknown, 1=deg 3=1' 5=1" 8=1mas 11=1여s, etc...
+    **/
+    public byte precision = 8;	// Default edition to 1mas
+
+    /**
+     * To a frame is attached a usage in the edition of coordinates.
+     * See {@link Astroformat}. The default edition is in decimal degrees.
+     * In equatorial systems, the default is sexagesimal, with RA in time units.
+    **/
+    /** 
+     * Default edition of Longitude/Right Ascention *
+    **/
+     public byte ed_lon = Editing.DECIMAL|Editing.ZERO_FILL;
+    /** 
+     * Default edition of Latitude/Declination
+    **/
+     public byte ed_lat = Editing.DECIMAL|Editing.ZERO_FILL|Editing.SIGN_EDIT;
+
+    /**
+     * The sexagesimal representation of the longitude may be expressed 
+     * in time unit. This is the case of the Equatorial frames,
+     * but also in the ICRS.
+    **/
+     public boolean hms = false;
+
+    /**
+     * Edition of an Astroframe.
+     * The name contains the epoch when the epoch is non-standard.
+     * @return the name of the Astroframe.
+    **/
+    public String toString() {
+	if (base_epoch == epoch) return(this.name);
+	return (this.toString(epoch));
+    }
+
+    /**
+     * Edition of an Astroframe with specification of the epoch.
+     * @return the name of the Astroframe.
+    **/
+    public String toString(double epoch) {
+	StringBuffer b = new StringBuffer(this.name);
+	int i = this.name.length()-1;
+	if (b.charAt(i) == ')') {
+	    b.setLength(i);
+	    b.append(',');
+	}
+	else b.append('(');
+	b.append("Ep=J"); i = b.length();
+	b.append(epoch);
+	if ((b.length() - i) > 6) {	// Don't give too many decimals! 
+	     b.setLength(i-1);
+	     b.append('B');
+	     edframe.editDecimal(b, Astrotime.J2B(epoch), 4, -3, 0);
+	}
+	if ((b.length() - i) > 6) {	// Don't give too many decimals! 
+	     b.setLength(i-1);
+	     b.append('J');
+	     edframe.editDecimal(b, epoch, 4, -3, 0);
+	}
+	b.append(')');
+	return(b.toString());
+    }
+
+    /**
+     * Make the required verifications to install the ICRS matrix.
+    **/
+    public final void setICRSmatrix() {
+	if ((ICRSmatrix == null) && (toICRSmatrix() == null)) 
+	    System.err.println("****Astroframe " + this
+		    + ": linkage to ICRS undefined!");
+    }
+
+    /**
+     * The setFrameEpoch method just set the default epoch.
+     * @param epoch epoch of the frame, in Julian year.
+    **/
+    public void setFrameEpoch(double epoch) {
+	this.epoch = epoch;
+    }
+
+    /** 
+     * Equality of frames -- name + epoch are assumed fully represent
+     * any frame. Note that the equinox is part of the frame name, hence
+     * 		  an equality of names imples the same equinox.
+     * @param o Another object
+     * @return True if same Astroframe 
+     *
+    **/
+    public boolean equals(Object o) {
+	boolean res = false;
+	if (o instanceof Astroframe) {
+	    Astroframe a = (Astroframe)o;
+	    res = this.epoch == a.epoch &&
+		  this.name.equals(a.name);
+	}
+	return(res);
+    }
+
+    /** 
+     * Getting the matrix to rotate to ICRS system.
+     * This method should return null when the change to ICRS can't be done 
+     * by a simple rotation.
+     * @return The rotation matrix from current frame to ICRS.
+    **/
+    public abstract double[][] toICRSmatrix() ;
+
+    /** 
+     * Conversion to ICRS.
+     * This conversion must be installed only if toICRSmatrix() returns 
+     * <tt>null</tt> (as in FK4).
+     * The conversion is straightforward if just a rotation is involved:
+     * <tt>coo.rotate(toICRSmatrix());</tt>
+     * @param coo a Coordinate assumed to express a position in my frame.
+     * On return, coo contains the corresponding coordinate in the ICRS.
+    **/
+    public void toICRS(Coo coo) {
+     	if (ICRSmatrix == null) setICRSmatrix();
+	coo.rotate(ICRSmatrix);
+    }
+
+    /** 
+     * Conversion from ICRS. 
+     * This conversion must be installed only if toICRSmatrix() returns 
+     * <tt>null</tt> (as in FK4).
+     * @param coo a Coordinate assumed to express a position in ICRS.
+     * On return, coo gives the corresponding coordinate in my frame.
+    **/
+     public void fromICRS(Coo coo) {
+     	if (ICRSmatrix == null) setICRSmatrix();
+	coo.rotate_1(ICRSmatrix);
+     }
+
+    /** 
+     * Conversion to ICRS with derivatives.
+     * The code contained here assumes a simple rotation. It has to be
+     * overloaded if this assertion is false (see e.g. FK4)
+     * @param u6   a 6-vector (phase vector) of position + velocity.
+     * 			Velocity in Jyr<sup>-1</sup>
+     * 			Note that u6 can restricted be a 3-vector.
+    **/
+     public void toICRS(double u6[]) {
+	if (ICRSmatrix == null) setICRSmatrix();
+	if (DEBUG) {
+	    System.out.println("....Astroframe.to:   ICRSmatrix");
+	    System.out.println(Coo.toString("    ", ICRSmatrix));
+	}
+	Coo.rotateVector(this.ICRSmatrix, u6);
+     }
+
+    /** 
+     * Conversion from ICRS with derivatives.
+     * The code contained here assumes a simple rotation. It has to be
+     * overloaded if this assertion is false (see e.g. FK4)
+     * @param u6   a 6-vector (phase vector) of position + velocity.
+     * 			Velocity in Jyr<sup>-1</sup>
+     * 			Note that u6 can restricted be a 3-vector.
+     * @return true/false if the operation is possible.
+    **/
+     public void fromICRS(double u6[]) {
+	if (ICRSmatrix == null) setICRSmatrix();
+	if (DEBUG) {
+	    System.out.println("....Astroframe.from: ICRSmatrix(transposed):");
+	    System.out.println(Coo.toString("    ", ICRSmatrix));
+	}
+	Coo.rotateVector_1(this.ICRSmatrix, u6);
+     }
+
+}
Index: aladin/cds/astro/Astropos.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Astropos.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,1702 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro ;
+
+/*==================================================================
+                Astropos Class  (Coo -> Astrocoo -> Astropos)
+ *==================================================================*/
+
+import java.io.*;
+import java.text.*; 	 // for parseException
+
+/**
+ * The class <b>Astropos</b> adds to <b>Astrocoo</b> the notions 
+ * of <i>mouvement</i> (proper motions, velocity) and <i>error</i> ellipses.
+ * <P>The edition of the position in an Astropos can be done in a StringBuffer
+ * (<B>edit</B> methods) with options like sexagesimal or decimal edition,
+ * or as a String with one of the available <B>toString</B> methods.
+ * In string format, an astropos looks like:<br>
+ * <i>longitude  +/- latitude</i> <b>(</b><i>epoch</i><b>)</b>
+ * <b>[</b><i>errorEllipse_mas</i> <b>(</b><i>meanEpoch</i><b>)</b><b>]</b>
+ * <i>pm_lon pm_lat</i>  <b>[</b><i>errorEllipse_mas/yr</i> <b>]</b>
+ * <i>parallax_mas</i> <b>[</b><i>error</i><b>]</b>
+ * <i>radialVelocity_km/s</i> <b>[</b><i>error</i><b>]</b></i>
+ * <P>The values are expressed internally as cartesian components in the
+ * associated frame. Errors are expressed internally as a 6x6 covariance matrix,
+ * (multinormal error distribution is asumed), also aligned with the frame
+ * main axes.
+ * Errors in other frames are computed using the property that,
+ * if <b>x</b> is multinormal with covariance matrix <b>V</b>
+ * then <b>Tx</b> is multinormal with covariance matrix <b>TV<sup>t</sup>T</b>.
+ * For instance, the variation of the 6-vector (x,y,x,xd,yd,zd) with time 
+ * is linear with the following <b>T(t)</b> matrix:<PRE>
+ *      1   0   0   t   0   0
+ *      0   1   0   0   t   0
+ *      0   0   1   0   0   t
+ *      0   0   0   1   0   0
+ *      0   0   0   0   1   0
+ *      0   0   0   0   0   1
+ * </PRE>
+ * (notice that <b>T<sup>-1</sup>(t) = T(-t)</b> and 
+ * <b>T(t<sub>1</sub>) T(t<sub>2</sub>) = T(t<sub>1</sub> + t<sub>2</sub>)</b>)
+ * and the error propagations are easily computed by this method.
+ * <P>Conversions into other frames ({@link #convertTo} method) imply a
+ * change of all parameters (position, proper motions, errors). A change
+ * of the epoch is achieved with the {@link #toEpoch} method.
+ * @author Francois Ochsenbein [CDS]
+ * @version 1.0 03-Aug-2004
+ * @version 1.1 03-Sep-2006
+ */
+
+public class Astropos extends Astrocoo implements Serializable {
+    static private boolean DEBUG = false; 
+  /** Derivative of <b>x</b> cartesian component (in Jyr<sup>-1</sup>) */
+    protected double xd;
+  /** Derivative of <b>y</b> cartesian component (in Jyr<sup>-1</sup>) */
+    protected double yd;
+  /** Derivative of <b>z</b> cartesian component (in Jyr<sup>-1</sup>) */
+    protected double zd;
+  /** Elements of rotation matrix. Notice that R00=x, R01=y, R02=z
+    	This is a duplication of part of the data already stored
+	but array manipulations is not really flexible in java...
+   **/
+    private double R[][];		// localMatrix.
+  /*
+    private double 
+	// R00=x R01=y R02=z
+	   R10,  R11, // R12=0 
+           R20,  R21,  R22;
+  /** The velocity vector is a rotation of the Unit derivative:
+   *  v0 is radial, v1 and v2 are the proper motions (alpha) and (delta),
+   *  and are expressed in mas/yr (mas = milli-arcsec).
+  **/
+  /** The epoch of the position with minimal uncertainty (mean epoch).
+    * Unit = Jyr
+   **/
+    protected double epocho;
+  /** Parallax in mas */
+    public double plx;	
+  /** Radial velocity in km/s */
+    public double rv;	
+  /** Mean error on parallax in mas */
+    public double e_plx;
+  /** Mean error on radial Velocity in km/s */
+    public double e_rv;
+  // Permanent values
+    //public double permanent_epos;	// Permanent error on pos, in mas
+    //public double permanent_epm ;	// Permanent error on pm , in mas
+    // Components of Astropos may have a permanent status, e.g. epocho, epoch...
+    // 1=plx, 2=RV, 4=pm, 8=epocho, 0x10=cov.pos, 0x20=cov.pm, 0x80=Epoch,
+    //                              0x40=cov.pos from precision
+    private byte permanent;	// Status of permanent parameters
+    private byte specified;
+    private boolean ready;	// when all elements computed.
+    
+    private static String partnames[] = { "plx", "rv", "pm", "meanEp", 
+	"cov.pos", "cov.pm", "cov.from.prec",  "epoch" };
+  /** Covariance matrix between all components (angles in mas, time in Jyr).
+   * it includes errors as well as correlations between position 
+   * and proper motions.
+  **/
+    protected double[][] cov;
+   /**
+    * Estimation of the errors on position, from the precision.
+   **/
+    static private double[] def_err = {
+	180.*3.6e6,	// 0: no position
+	2.1*3.6e6,	// 1: deg
+	2.1*3.6e5,	// 2: 0.1deg
+	2.1*6e4,	// 3: 1'
+	2.1*6e3,	// 4: 0.1'
+	2.1*1000.,	// 5: 1"
+	2.1*100.,	// 6: 0.1"
+	2.1*10.,	// 7: 0.01"
+	2.1,		// 8: 1mas
+	2.1/10.,	//10: 0.1mas
+	2.1/100.,	//11: 0.01mas
+	2.1/1000.,	//12: 1여s
+    };
+    //static private double[]  def_rv  = { 0., 50. };	// Default RV
+    //static private double[]  def_plx = { 9., 10. };	// Default plx (mas)
+
+  //  ===========================================================
+  //			In-line utilities
+  //  ===========================================================
+
+    /* Transpose a 3x3 matrix */
+    private static final void tr3(double m[][]) {
+	double v;
+	//System.out.println(Coo.toString("...tr3(0)", m));
+	v = m[0][1]; m[0][1] = m[1][0]; m[1][0] = v;
+	v = m[0][2]; m[0][2] = m[2][0]; m[2][0] = v;
+	v = m[1][2]; m[1][2] = m[2][1]; m[2][1] = v;
+	//System.out.println(Coo.toString("   tr3(1)", m));
+    }
+    /* Compute the product R.u = v */
+    private final void rot2local(double u[], double v[]) {
+	v[0] = R[0][0]*u[0] + R[0][1]*u[1] + R[0][2]*u[2];
+	v[1] = R[1][0]*u[0] + R[1][1]*u[1] ;	
+	v[2] = R[2][0]*u[0] + R[2][1]*u[1] + R[2][2]*u[2];
+    }
+    /* Compute the product tR.v = u */
+    private final void rot2fixed(double v[], double u[]) {
+	u[0] = R[0][0]*v[0] + R[1][0]*v[1] + R[2][0]*v[2];
+	u[1] = R[0][1]*v[0] + R[1][1]*v[1] + R[2][1]*v[2];
+	u[2] = R[0][2]*v[0]                + R[2][2]*v[2];
+    }
+
+    private final void rot3(double R[][], double v[]) {
+      int i; double x,y,z;
+        x = v[0]; y = v[1]; z = v[2];
+	for(i=0; i<3; i++)
+	     v[i]   = R[i][0]*x + R[i][1]*y + R[i][2]*z;
+    }
+
+    /* Rotate the 6x6 covariance (symetrical) matrix.
+     * If Y=RX, then var(Y)=R.var(X).tR.
+     * Element  =  Sum(k,l) Rik.Vkl.Rjl.
+     * Product |R 0| |V00 V01| |tR 0| = |R.V00.tR R.V01.tR|
+     *         |0 R| |V10 V11| |0 rR| = |R.V10.tR R.V11.tR|
+     **/
+    private final static void rotate_cov (double[][] R, double[][] cov) {
+	if (cov == null) return;
+	double t3[][] = new double[3][3];	// Temporary
+	double t; int i,j,k,l;
+	//if(DEBUG) pr_cov("   rot6(0) ", cov);
+	// 1. Upper left
+	for (i=0; i<3; i++) for (j=0; j<3; j++)
+	    t3[i][j] = cov[i][j];
+	for (i=0; i<3; i++) for (j=0; j<3; j++) {
+	    t=0.;
+	    for (k=0; k<3; k++) for (l=0; l<3; l++)
+	        t += R[i][k]*R[j][l]*t3[k][l];
+	    cov[i][j] = t;
+	}
+	//if(DEBUG) pr_cov("   rot6(1) ", cov);
+	// When only 3-D, that's all!
+	if (cov[0].length == 3) return;
+
+	// 2. Lower right
+	for (i=0; i<3; i++) for (j=0; j<3; j++)
+	    t3[i][j] = cov[i+3][j+3];
+	for (i=0; i<3; i++) for (j=0; j<3; j++) {
+	    t=0.;
+	    for (k=0; k<3; k++) for (l=0; l<3; l++)
+	        t += R[i][k]*R[j][l]*t3[k][l];
+	    cov[i+3][j+3] = t;
+	}
+	//if(DEBUG) pr_cov("   rot6(2) ", cov);
+
+	// 3. Off-diagonal (symetrical):
+	k = 0;		// Counter non-null values
+	for (i=0; i<3; i++) for (j=0; j<3; j++) {
+	    t3[i][j] = cov[i][j+3];
+	    if (t3[i][j] != 0) k++;
+	}
+	if (k!=0) for (i=0; i<3; i++) for (j=0; j<3; j++) {
+	    t=0.;
+	    for (k=0; k<3; k++) for (l=0; l<3; l++)
+	        t += R[i][k]*R[j][l]*t3[k][l];
+	    cov[i][j+3] = cov[i+3][j] = t;
+	}
+	//if(DEBUG) pr_cov("   rot6(3) ", cov);
+    }
+
+    /** 
+     * Rotate one specific variance/covariance.
+     *           Sum(i).Sum(j) { R[i1,i] . R[i2,j] . cov[i,j]
+     * @param i1 Index of param.1 (1=RA, 2=Dec, 4=mu1, 5=mu2)
+     * @param i2 Index of param.2 (1=RA, 2=Dec, 4=mu1, 5=mu2)
+     */
+    private final double getVar(int i1, int i2) {
+	if ((cov == null) || (R == null))
+	    return(0./0.);
+	int o1, o2, k1, k2, i, j;
+	o1 = 3*(i1/3); o2 = 3*(i2/3); 
+	k1 = i1%3;     k2 = i2%3;
+	double t = 0;	// Sum(i).Sum(j) { R[i1,i] . R[i2,j] . cov[i,j] }
+	for (i=0; i<3; i++) for (j=0; j<3; j++)
+	    t += R[k1][i]*R[k2][j]*cov[o1+i][o2+j];
+	//System.out.print("....getVar(" + i1 + "," + i2 + ")" );
+	//System.out.print("; k1=" + k1 + ", k2=" + k2);
+	//System.out.print("; o1=" + o1 + ", o2=" + o2);
+	//System.out.println(" ==> " + t);
+	return(t);
+    }
+
+    private static final void propagate_error(double var[][], double t) {
+    /* Compute the error propagation as 
+ 	   | 1  0  0  t  0  0 |           | 1  0  0  0  0  0 |
+	   | 0  1  0  0  t  0 |           | 0  1  0  0  0  0 |
+	   | 0  0  1  0  0  t | *  var  * | 0  0  1  0  0  0 |
+	   | 0  0  0  1  0  0 |           | t  0  0  1  0  0 |
+	   | 0  0  0  0  1  0 |           | 0  t  0  0  1  0 |
+	   | 0  0  0  0  0  1 |           | 0  0  t  0  0  1 |
+    */
+      int i,j;
+	for (j=0; j<3; j++) for (i=0; i<6; i++)
+	    var[i][j] += t*var[i][j+3];
+	for (i=0; i<3; i++) for (j=0; j<6; j++)
+	    var[i][j] += t*var[i+3][j];
+    }
+
+    /* Compute Product Matrix(3x3) applied to 6-vector: v = R  u */
+    private static final void rot6(double R[][], double[] u, double[] v) {	
+      int i;
+        for(i=0; i<3; i++) {
+	    v[i]   = R[i][0]*u[0] + R[i][1]*u[1] + R[i][2]*u[2];
+	    v[i+3] = R[i][0]*u[3] + R[i][1]*u[4] + R[i][2]*u[5];
+	}
+    }
+
+    /* Compute T  V  tT product of matrices */
+    /* Note that the matrices must be in different locations ! */
+    /** Finally unused... 
+    private static final void TVtT(int n, double T[][], double V[][], 
+	    double out[][]) {
+      double t; int i,j,k,l;
+	// Simple computation
+        for (i=0; i<n; i++) for (j=0; j<n; j++) {
+	    t=0.;
+	    for (k=0; k<n; k++) for (l=0; l<n; l++) 
+		t += T[i][k]*T[j][l]*V[k][l] ;
+	    out[i][j] = t;
+	}
+    }
+    **/
+
+  //  ===========================================================
+  //			Error ellipses and Variances
+  //  ===========================================================
+
+   /**
+    * Renormalize the vectors
+   **/
+    public double  normalize() {
+      double norm = x*x+y*y+z*z;
+      	if (norm <= 0) return (norm);
+      	if (norm == 1) return (norm);
+	if (cov != null) { int i, j;
+	    for(i=0; i<6; i++) for (j=0; j<6; j++)
+		cov[i][j] /= norm;
+	}
+	norm = Math.sqrt(norm);
+	x  /= norm;  y /= norm;  z /= norm;
+	xd /= norm; yd /= norm; zd /= norm;
+	plx /= norm; e_plx /= norm;
+	if (R != null) { 
+	    R[0][0] /= norm; R[0][1] /= norm; R[0][2] /= norm;
+	    R[2][0] /= norm; R[2][1] /= norm; R[2][2] /= norm;
+	}
+	return(norm);
+    }
+
+    /**
+     * Rotate an Astropos. Its changes position, proper motions and errors
+     * @param R [3][3] matrix
+    **/
+    public final void rotate (double[][] R) {
+      double v[] = new double[3];
+        super.rotate(R); 	// Rotate x, y, z
+	/* Rotate derivatives: */
+        v[0] = xd; v[1] = yd; v[2] = zd;
+	xd = R[0][0]*v[0] + R[0][1]*v[1] + R[0][2]*v[2];
+	yd = R[1][0]*v[0] + R[1][1]*v[1] + R[1][2]*v[2];
+	zd = R[2][0]*v[0] + R[2][1]*v[1] + R[2][2]*v[2];
+	/* Rotate the variance: R  var  tR */
+	if (cov != null) 
+	    rotate_cov(R, cov);
+    }
+
+   /**
+    * Convert a variance matrix <i>(var(x), var(y), cov(x,y))</i>
+    * into an error ellipse <i>(a, b, posAngle)</i>.
+    * The axises of the error ellipse are the squared eigenvalues of variance
+    * matrix, i.e. <br> 
+    *     (var(x)-a)(var(y)-a) = cov(x,y) <br>
+    *     (var(x)-b)(var(y)-b) = cov(x,y) <br>
+    * a<sup>2</sup> and b<sup>2</sup> are solutions of a simple 2nd order equation.
+    *     The <i>posAngle</i> defines the eigenvector of the largest eigenvalue
+    * @param var  Vector {var(x)  var(y)  cov(x,y) }
+    * @param ee3  Vector {  a       b     theta }   axises+PA of ellipse
+    * The relation
+   **/
+    public static final void varianceToErrorEllipse(double[] var, double[] ee3){
+      	double delta, a2, b2, t;
+      //System.out.println(Coo.toString("   var: ", var));
+	t = (var[0]-var[1])/2.; delta = Math.sqrt(t*t+var[2]*var[2]);
+	t = (var[0]+var[1])/2.; a2 = t+delta; b2 = t-delta;
+	ee3[0] = Math.sqrt(a2);
+	ee3[1] = Math.sqrt(b2);
+	// Theta
+	if (var[2] == 0) ee3[2] = var[0]<=var[1] ? 0: 90.;
+	else ee3[2] = AstroMath.atand((a2-var[1])/var[2]);
+	if (ee3[2] < 0)      ee3[2] += 180. ;
+      //System.out.println(Coo.toString(" =>ell: ", ee3));
+    }
+
+   /**
+    * Convert an error ellipse <i>(a, b, posAngle)</i> into a 
+    * variance matrix <i>(var(x), var(y), cov(x,y))</i>.
+    * 	  X = sin(theta)*x - cos(theta)*y = st*x - ct*y<br>
+    * 	  Y = cos(theta)*x + sin(theta)*y = ct*x + st*y<br>
+    * the covariances of (X,Y) are:<br>
+    *     var(X) = st<sup>2</sup>*var(x) + ct<sup>2</sup>*var(y)<br>
+    *     var(Y) = ct<sup>2</sup>*var(x) + st<sup>2</sup>*var(y)<br>
+    *     cov(X,Y) = ct*st*(var(x)-var(y))
+    * @param ee3  Vector {  a       b     theta}   axises+PA of ellipse
+    * @param var  Vector {var(x)  var(y)  cov(x,y)}
+    * The relation
+   **/
+    public static final void errorEllipseToVariance(double[] ee3, double[] var){
+      double ct, st, a2, b2;
+      //System.out.println(Coo.toString("   ell: ", ee3));
+	a2 = ee3[0] * ee3[0] ; b2 = ee3[1] * ee3[1] ;
+      	ct = AstroMath.cosd(ee3[2]) ;   st = AstroMath.sind(ee3[2]) ;
+	var[0] = a2*st*st + b2*ct*ct ;
+	var[1] = a2*ct*ct + b2*st*st ;
+	var[2] = ct*st*(a2-b2) ;
+      //System.out.println(Coo.toString(" =>var: ", var));
+    }
+
+   /**
+    * Interpret an error ellipse written  
+    *     <b>[</b> <i>a b theta</i> <b>]</b>.
+    * If theta is missing, its value is defaulted to 90&deg; (i.e. 
+    * a and b represent the mean errors on RA*cos(Dec) and Dec).
+    * If a single number is found, it's assumed to be the error circle.
+    * @param txt  Text to interpret
+    * @param ee3  Vector (  a       b     theta)   axises+PA of ellipse
+    * @return true if error ellipse could be parsed.
+   **/
+    public static boolean parseErrorEllipse (Parsing txt, double[] ee3) {
+      int posini = txt.pos;
+      int pos, postart, n;
+        ee3[0] = ee3[1] = 0./0.;
+	ee3[2] = 90.;	// Default theta
+        // Text could start by the opening bracket.
+	txt.gobbleSpaces();
+	n = txt.parseArray(ee3);
+	if (n == 0) return(false);	// Not a single number found! 
+	if (Double.isNaN(ee3[2])) ee3[2] = 90.;		// Default theta
+	if (Double.isNaN(ee3[1])) ee3[1] = ee3[0];	// Default b=a
+	return(true);
+    }
+
+   /*===========================================================
+   			Compute all elements
+    *===========================================================*/
+
+    /**
+     * Debugging: print position + velocity
+     */
+     private final void pru6(String title) {
+      	double  u[] = new double[3];
+      	String tit2 = "                                           ";
+      	u[0] = x ; u[1] = y ; u[2] = z ;
+      	System.out.println(Coo.toString(title, u));
+      	u[0] = xd; u[1] = yd; u[2] = zd;
+      	System.out.println(Coo.toString(tit2.substring(0, title.length()), u));
+     }
+
+    /**
+     * Debugging: print covariance matrix
+     */
+     private final static void pr_cov(String title, double[][] cov) {
+       	StringBuffer b = new StringBuffer(256);
+       	int len0 = title.length();
+       	int i, j;
+	b.append(title);
+	for(i=0; i<6; i++) {
+	    for(j=0; j<6; j++) {
+		ed.editDouble(b, cov[i][j], 4, 3, 0);
+		b.append(' ');
+	    }
+	    System.out.println(b.toString());
+	    b.setLength(len0);
+	    if (i == 0) {
+		b.setLength(0);
+		for (j=0; j<len0; j++) b.append(' ');
+	    }
+	}
+     }
+
+    /**
+     * Compute all elements in an Astropos, and mark it as 'ready'.
+     * On input, the Astrocoo part is computed. 
+     * On output, the missing elements are computed or estimated.
+     */
+     private final void compute() {
+      double  u6[] = null;		// 6-vector (u, u'), all 0
+      double   v[] = new double[3];
+      double mu0, mu2;
+      int i, j, k, l;
+
+        if (ready) return;
+
+	if(DEBUG) dump("<<compute: ");
+	// Verify what's really specified.
+	// if (Double.isNaN(plx))    specified &= ~0x1;
+	// if (Double.isNaN(rv))     specified &= ~0x2;
+	// if (Double.isNaN(epocho)) specified &= ~0x8;
+	// if (Double.isNaN(epoch))  specified &= ~0x80;
+	// if (cov == null)	  specified &= ~0x30;	// No sigma pos,pm
+	// else {
+	//     if (Double.isNaN(cov[0][0])) specified &= ~0x10;
+	//     if (Double.isNaN(cov[3][3])) specified &= ~0x20;
+	// }
+
+	// Epoch of position.
+	if (((specified|permanent)&0x80) == 0)
+	    this.epoch = this.frame.epoch;
+	if (((specified|permanent)&0x08) == 0) 	// epocho not specified
+	    this.epocho = this.epoch;
+
+	// Get parallax 
+	if (((specified|permanent)&0x1) == 0) {	// Parallax not specified
+	    this.plx   = 0.;	// def_plx[0];
+	    this.e_plx = 0.;	// def_plx[1];
+	}
+
+	// Get Radial Velocity
+	if (((specified|permanent)&0x2) == 0) {	// Radial Velocity not specified
+	    this.rv   = 0; 	// def_rv[0];
+	    this.e_rv = 0; 	// def_rv[1];
+	}
+
+	// Proper motions: Estimate
+	if (((specified|permanent)&0x4) == 0) {	// Proper motion not specified
+	    if (this.frame instanceof FK4) {
+		if (u6 == null) u6 = new double[6];
+		u6[0] = x; u6[1] = y; u6[2] = z;
+		FK4.estimateFK4motion(u6);
+		xd = u6[3]; yd = u6[4]; zd = u6[5];
+	    }
+	    else xd = yd = zd = 0;
+	    // No proper motion ==> cov(mu) = 0
+	    if (cov != null) for (i=3; i<6; i++) for (j=3; j<6; j++)
+		cov[i][j] = 0;
+	}
+	mu2 = xd*xd + yd*yd + zd*zd;	// Total mu^2, in rad/yr
+
+	// When RV + plx supplied, change the velocity vector
+	if (((specified|permanent)&0x3) == 0x3) {
+	    mu0 = (plx * rv /4.740470446)	// in mas/yr
+	        / (180.*3.6e6/Math.PI) ;	// in rad/yr
+	    // Added 12 Oct 2006: if no error on position, 
+	    //       and no proper motion... cov can be nil!
+	    if (cov != null) cov[3][3] = e_plx * e_rv /4.740470446;
+	    // There is a problem when v[0] is too large compared to 
+	    // other components; in this case, set this parameter to
+	    // zero, but increase its error.
+	    if (mu0*mu0 >= 0.5*mu2) {
+	        mu0 = 0;
+		if (cov != null) cov[3][3] += mu0*mu0;
+	    }
+	    else {	// Assign the radial component to velocity
+		xd += x*mu0;
+		yd += y*mu0;
+		zd += z*mu0;
+	    }
+	}
+	if(DEBUG) pru6("   u+du(1) ");
+
+	// Error ellipse on position, compute or estimate when not given
+	if ((specified&0x50) == 0 && dlon>0 && dlat>0) {
+	    if ((permanent&0x10) == 0) {	// Estimate error ellipse
+	        i = dlon; if (i>=def_err.length) i = def_err.length-1;
+	        j = dlat; if (j>=def_err.length) j = def_err.length-1;
+	        this.setErrorEllipse(def_err[i], def_err[j], 90., 0./0.);
+		specified ^= 0x50;	// Was changed in setErrorEllipse
+	    }
+	    // else this.setErrorEllipse(permanent_epos, permanent_epos, 0);
+	}
+
+	// Error ellipse on proper motion.
+	if ((specified&0x20) == 0) {		// No error pm specified
+	    //if ((permanent&0x20) != 0) 
+	    //	setErrorProperMotion(permanent_epm, permanent_epm, 0);
+	    //specified &= ~0x20;			// Reset to zero
+	}
+
+	/* Progapate the error on proper motions */
+	if (this.epoch != this.epocho) {
+	    if(DEBUG) pr_cov("   cov6(0) ", this.cov);
+	    propagate_error(cov, this.epoch - this.epocho);
+	    if(DEBUG) pr_cov("   cov6(t) ", this.cov);
+	}
+
+	// 6-D covariance is now correcly set in the local frame.
+	// Rotate the 6-D covariance matrix to absolute frame, i.e.
+	// with inverse(R) = transposed(R).
+	if (this.R != null) {
+	    tr3(R);	// transpose R
+	    rotate_cov(this.R, cov);
+	    tr3(R);	// transpose again, i.e. return to original
+	}
+
+	if(DEBUG) dump(" >compute: ");
+	ready = true;
+     }
+
+
+   /*===========================================================
+   			Constructors
+    *===========================================================*/
+
+    /**
+     * Create the default (empty) Astropos (ICRS)
+     */
+     public Astropos() {
+	super(new ICRS());
+	cov = null;
+	permanent = 0;
+	epocho = 0./0.;	// No Mean Position
+	reset();
+    }
+
+    /**
+     * Create an empty Astropos.
+     * @param frame	in which frame
+     */
+     public Astropos(Astroframe frame) {
+	super(frame);
+	cov = null;
+	permanent = 0;
+	epocho = 0./0.;	// No Mean Position
+	reset();
+     }
+
+    /**
+     * Create a Astropos object with just longitude + latitude
+     * @param lon	longitude (RA), degrees
+     * @param lat	latitude (Dec), degrees
+     */
+     public Astropos(Astroframe frame, double lon, double lat) {
+	super(frame);
+	cov = null;
+	permanent = 0;
+	epocho = 0./0.;	// No Mean Position
+	reset();
+	this.set(lon, lat);
+     }
+
+    /**
+     * Create a Astropos object: coordinates + proper motion.
+     * @param lon	longitude (RA), degrees
+     * @param lat	latitude (Dec), degrees
+     * @param epoch	epoch of the longitude/latitude, year
+     * @param mu1	proper motion along longitude, mas/yr
+     * @param mu2	proper motion along latitude,  mas/yr
+     */
+     public Astropos(Astroframe frame, double lon, double lat, double epoch, 
+		   double mu1, double mu2) {
+	super(frame);
+	this.set(lon, lat, epoch, (double[])null, 
+		 mu1, mu2, epoch, (double[])null, 
+		(double[])null, (double[])null);
+     }
+
+    /**
+     * Create a Astropos object from an existing Astrocoo
+     * @param coo	Astrocoo object
+     */
+     public Astropos(Astrocoo coo) {
+	 this.set(coo);
+	// super(coo.getFrame());
+	// this.set(coo.getLon(), coo.getLat(), coo.epoch, null,
+	//      0./0., 0./0., 0./0., null, null, null);
+     }
+
+    /**
+     * Create a Astropos object from an existing Astrocoo
+     * @param coo	Astrocoo object
+     * @param eepos	Error ellipse on position (mas, mas, deg)
+     * @param epocho	epoch of the errors on position (minimal error)
+     * @param mu1	proper motion along longitude, mas/yr
+     * @param mu2	proper motion along latitude,  mas/yr
+     * @param eepm	Error ellipse on proper motion (mas/yr, mas/yr, deg)
+     * @param plx2	Parallax and its mean error (mas)
+     * @param rv2	Radial velocity and its error (km/s)
+     * ------ Not necessary
+     public Astropos(Astrocoo coo, double eepos[], double epocho,
+	     double mu1, double mu2, double eepm[], 
+	     double plx2[], double rv2[]) {
+	super(coo.getFrame());
+	this.set(coo.getLon(), coo.getLat(), coo.epoch, eepos,
+	     mu1, mu2, epocho, eepm, plx2, rv2);
+     }
+     */
+
+    /**
+     * Create an Astropos object from a position (Epoch)
+     * @param frame	one of the possible Astroframes
+     * @param text Text with position, possibly followed by an epoch
+     */
+     public Astropos(Astroframe frame, String text) throws ParseException {
+	super(frame);
+	epocho = 0./0.;	// No Mean Position
+	this.set(text);
+    }
+
+    /**
+     * Create an Astropos object from just a string.
+     * @param text Text with frame, position, possibly followed by an epoch
+     */
+    public Astropos(String text) throws ParseException {
+      	Parsing txt = new Parsing(text);
+      	frame = Astrocoo.parseFrame(txt);
+        if (frame == null) throw new ParseException
+	    ("****Astropos: argument '" + text + "' (no frame)", txt.pos);
+	epocho = 0./0.;	// No Mean Position
+	this.set(txt.toString());
+    }
+
+     public Object clone() {
+     	Astropos c = (Astropos) super.clone();
+    	return c;
+    }
+
+
+
+    /**
+     * Set a Astropos from position + proper motion.
+     * @param frame	one of the possible Astroframes
+     * @param lon	longitude (RA), degrees
+     * @param lat	latitude (Dec), degrees
+     * @param eepos	error ellipse, mas
+     * @param epoch	epoch of the longitude/latitude, Julian year
+     * @param mu1	proper motion along longitude,  mas/yr
+     * @param mu2	proper motion along latitude,  mas/yr
+     * @param eepm	error ellipse of proper motion, mas/yr
+     * @param epocho	epoch of position error (minimal error), Jyr
+     * @param plx2	parallax + its error (mas)
+     * @param rv2	radial velocity + its error (km/s)
+     */
+     public Astropos(Astroframe frame, 
+      double lon, double lat, double epoch, double[] eepos, 
+      double mu1, double mu2, double epocho, double[] eepm, 
+      double[] plx2, double[] rv2) {
+	super(frame);
+       	this.set(lon, lat, epoch, eepos, 
+		mu1, mu2, epocho, eepm, plx2, rv2);
+     }
+
+    //  ===========================================================
+    //			Dump (print object's contents)
+    //  ===========================================================
+
+    /**
+     * Dump the contents of an Astropos
+     * @param title title line
+    **/
+     public void dump(String title) {
+       StringBuffer b = new StringBuffer(256);
+       	int len0 = title.length();
+       	int i, j;
+       	// Subtitle = same length as title, but blank.
+       	for (i=len0;--i>=0;) b.append(' ');
+       	String blanks = b.toString(); b.setLength(0);
+	super.dump(title);		// Edit the coordinate
+	// Edit the derivatives
+	b.setLength(0); b.append(blanks);
+	ed.editDecimal(b, xd, 2, 15, Editing.SIGN_EDIT); b.append(' ');
+	ed.editDecimal(b, yd, 2, 15, Editing.SIGN_EDIT); b.append(' ');
+	ed.editDecimal(b, zd, 2, 15, Editing.SIGN_EDIT); b.append(' ');
+	b.append("(dot)");
+	if ((specified&4)==0)  b.append("::");
+	System.out.println(b.toString());
+	// Edit the R matrix
+	b.setLength(len0); System.out.println(Coo.toString(b.toString(), R));
+	// Edit the flags (specified + permanent)
+	b.setLength(len0); b.append("    Epoch=J"); b.append(this.epoch);
+	i = len0+20; while(b.length() < i) b.append(" ");
+	b.append("specified=0x"); b.append(Integer.toHexString(specified&0xff));
+	b.append('('); ed.editFlags(b, specified, partnames); 
+	b.append(')'); System.out.println(b);
+	b.setLength(len0); b.append("MeanEpoch=J"); b.append(this.epocho);
+	i = len0+20; while(b.length() < i) b.append(" ");
+	b.append("permanent=0x"); b.append(Integer.toHexString(permanent&0xff));
+	b.append('('); ed.editFlags(b, permanent, partnames); 
+	b.append(')');
+	System.out.println(b);
+	// Edit the  Pm Vr plx
+	b.setLength(len0); b.append("pm(mas/yr) ");
+	ed.editDecimal(b, this.getProperMotionLon(), 6, 5, Editing.SIGN_EDIT); 
+			      b.append(" ");
+	ed.editDecimal(b, this.getProperMotionLat(), 6, 5, Editing.SIGN_EDIT); 
+			      b.append(" ");
+	ed.editDecimal(b, this.plx, 4, 5, 0); b.append("mas");
+	ed.editDecimal(b, this.rv, 6, 5, Editing.SIGN_EDIT); b.append("km/s");
+	//b.append('['); b.append(e_plx); b.append(']');
+	//b.append('['); b.append(e_rv); b.append(']');
+	System.out.println(b.toString());
+	// Edit the Covariance Matrix
+	b.setLength(len0);
+	b.append("----6x6 Covariance Matrix ");
+	if (cov == null) {
+	    b.append("(NULL) [");
+	    if (!ready) b.append("NOT ");
+	    b.append("ready]");
+	    System.out.println(b.toString());
+	}
+	else {
+	    b.append("(mas , yr) [");
+	    if (!ready) b.append("NOT ");
+	    b.append("ready]");
+	    System.out.println(b.toString());
+	    b.setLength(len0);
+	    pr_cov(b.toString(), this.cov);
+	}
+     }
+
+    //  ===========================================================
+    //			Interpretation of text (Parsing)
+    //  ===========================================================
+
+   /**
+    * Duplicate an array
+    **/
+    static private final double[] dup(double[] v) {
+      double[] w = new double[v.length];
+	for (int i=0; i<v.length; i++) w[i] = v[i];
+	return(w);
+    }
+
+    /**
+     * Interpret the string and convert to Coo + Epoch.
+     * Called from set and parse routines. Interprets until mismatch.
+     * @param txt to interpret as a Parsing object e.g.
+     *  "12 34.5 -72 54 [30 20 65 (J1991.25)] J2000.0 +125.2 -35.2 [3.9 2.5 45] 123[4]km/s 10[5]"
+     * @return true if OK.
+    **/
+     public boolean parsing(Parsing txt) {
+      double[] v3 = new double[3];
+      double[] v2 = new double[2];
+      double[] eepos=null;	// Error ellipse on position
+      double[] eepm=null;	// Error ellipse on proper motion
+      double[] plx=null;	// Parallax + Error
+      double[] rv=null;		// Radial Velocity + Error
+      double mu1, mu2, val, ep, epo;
+      boolean bracketed;
+      int posini = txt.pos;
+      int pos, n;
+	if(DEBUG) System.out.println("....Parsing(0): " + txt);
+
+	reset();
+	// Use parent class to match the Coo + Epoch
+	if (!super.parsing(txt)) return(false);
+	ready = false;
+	epo = epocho;		// Mean epoch from defaults
+	ep = this.epoch;	// Epoch from Astrocoo result
+	if(DEBUG) System.out.println("....astrocoo => " + super.toString());
+	if(DEBUG) System.out.println("....Parsing(1): " + txt);
+
+	// Try to match the error ellipse
+	txt.gobbleSpaces();
+	if (bracketed = txt.match("[")) {
+	    txt.gobbleSpaces();
+	    if (parseErrorEllipse(txt, v3)) {	// Error ellipse given
+	        eepos = dup(v3);
+	        txt.gobbleSpaces();
+		val = getEpoch(txt);
+		if (!Double.isNaN(val)) 
+		    epo = val;
+	    }
+	    txt.gobbleSpaces();
+	    if (!txt.match("]")) {
+		txt.set(posini); 
+		return(false); 
+	    }
+	}
+	if(DEBUG) System.out.println("....Parsing(2): " + txt);
+	if(DEBUG) System.out.println("           epo= " + epo);
+
+	// The epoch, or mean epoch
+	txt.gobbleSpaces();
+	val = getEpoch(txt);
+	if (!Double.isNaN(val)) {
+	    if (Double.isNaN(ep)) ep = val;
+	    else epo = val;
+	}
+
+	// mean epoch could be given as a second epoch within [ ... ]
+	txt.gobbleSpaces();
+	if (Double.isNaN(epo) && (txt.currentChar() == '[')) {
+	    // Second epoch bracketed
+	    posini = txt.pos;
+	    txt.match('[');
+	    val = getEpoch(txt);
+	    if (Double.isNaN(val)) txt.set(posini);
+	    else if (txt.match(']')) epo = val;
+	    else txt.set(posini); 
+	}
+	if(DEBUG) System.out.println("....Parsing(3): " + txt);
+	if(DEBUG) System.out.println("           epo= " + epo);
+
+	// Get proper motions mu1 mu2 (in mas/year)
+	pos = txt.pos;
+	txt.gobbleSpaces();
+	n = txt.parseArray(v2);
+	if (n==2) { 			// Both proper motions required
+	    mu1 = v2[0]; 
+	    mu2 = v2[1]; 
+	}
+	else {
+	    mu1 = mu2 = 0./0.;
+	    txt.set(pos);
+	}
+	if(DEBUG) System.out.println("....Parsing(4): " + txt);
+
+	// Last change for mean epoch
+	if (Double.isNaN(epo) && (txt.pos < txt.length))
+	     epo = getEpoch(txt);
+	if(DEBUG) System.out.println("           epo= " + epo);
+
+	// Error ellipse of proper motion
+	pos = txt.pos;
+	txt.gobbleSpaces();
+	if (bracketed = txt.match("[")) {
+	    txt.gobbleSpaces();
+	    if (parseErrorEllipse(txt, v3)) 	// pm Error ellipse 
+	        eepm = dup(v3);
+	    if (!txt.match("]")) {
+		txt.set(posini); 
+		return(false); 
+	    }
+	}
+	// Last trial for mean epoch of error on position
+	if (Double.isNaN(epo) && (txt.pos < txt.length)) 
+	     epo = getEpoch(txt);
+	if(DEBUG) System.out.println("....Parsing(5): " + txt);
+	if(DEBUG) System.out.println("           epo= " + epo);
+
+	// Parallax
+	n = txt.parseWithError(v2);	// May return 0, 1, 2
+	if (n > 0) {
+	    txt.gobbleSpaces();
+	    if (txt.match("km/s")) {	// Mixed up RV and parallax !
+		 plx = rv;
+		 rv = dup(v2);
+	    }
+	    else {
+		plx = dup(v2);
+	        txt.match("mas");
+	    }
+	}
+	if(DEBUG) System.out.println("....Parsing(p): " + txt);
+	if(DEBUG) System.out.println("           epo= " + epo);
+
+	// Radial Velocity
+	n = txt.parseWithError(v2);	// May return 0, 1, 2
+	if (n > 0) {
+	    txt.gobbleSpaces();
+	    if (txt.match("mas")) {	// Mixed up RV and parallax !
+		plx = dup(v2);
+	    }
+	    else {
+	        rv = dup(v2);
+	        txt.match("km/s");
+	    }
+	}
+	if(DEBUG) System.out.println("....Parsing(V): " + txt);
+	if(DEBUG) System.out.println("           epo= " + epo);
+
+	// Install all parameters found.
+	set(this.lon, this.lat, ep, eepos, mu1, mu2, epo, eepm,
+		plx, rv);
+	return(true);
+     }
+
+    /**
+     * Parsing method: interpret a String.
+     * @param txt to interpret.
+     * @param offset starting position in text
+     * @return new position.
+    **/
+     public int parse (String txt, int offset) {
+      Parsing t = new Parsing(txt, offset);
+	if (parsing(t)) return(t.pos);
+	return(offset);
+     }
+
+  //  ===========================================================
+  //			Set in Astropos
+  //  ===========================================================
+
+
+    /**
+     * Clear up: unknown position
+     */
+     private final void reset() {
+	specified = 0;
+	xd = yd = zd = 0;
+	ready = false;
+     }
+
+  /**
+    * Reset position to unknown.
+   **/
+    public void set() {
+	super.set();
+	reset();
+    }
+
+  /**
+    * New position from a Coo
+    * @param coo  A coordinate
+   **/
+    public void set(Coo coo) {
+	reset();
+	super.set(coo);
+	if (R == null) R = super.localMatrix();
+	else super.localMatrix(R);
+	ready = false;
+    }
+
+  /**
+    * Set position from another Astrocoo
+    * @param coo  A coordinate
+   **/
+    public void set(Astrocoo coo) {
+	reset();
+	super.set(coo);
+	if (R == null) R = super.localMatrix();
+	else super.localMatrix(R);
+	ready = false;
+    }
+
+  /**
+    * Set position from Coordinate and Epoch.
+    * @param coo    A coordinate
+    * @param epoch  Epoch of position
+   **/
+    public void set(Coo coo, double epoch) {
+	reset();
+	super.set(coo, epoch);
+	if (R == null) R = super.localMatrix();
+	else super.localMatrix(R);
+	ready = false;
+    }
+
+  /**
+    * Set position from RA + Dec.
+   **/
+    public void set(double lon, double lat) {
+	reset();
+	super.set(lon, lat);
+	if (R == null) R = super.localMatrix();
+	else super.localMatrix(R);
+	ready = false;
+    }
+
+  /**
+    * Set position from RA + Dec and epoch
+   **/
+    public void set(double lon, double lat, double epoch) {
+	set(lon, lat);
+	if (Double.isNaN(epoch)) return;
+	specified |= 0x80;
+	this.epoch = epoch;
+    }
+
+  /**
+    * Set position from RA + Dec.
+   **/
+    public void set(double lon, double lat, double epoch,
+	    double mu1, double mu2) {
+	set(lon, lat, epoch);
+	if (Double.isNaN(mu1) || Double.isNaN(mu2)) ;
+	else setProperMotion(mu1, mu2);
+	if (R == null) R = super.localMatrix();
+	else super.localMatrix(R);
+	ready = false;
+    }
+
+    /**
+     * Set a Astropos from position + proper motion. To remove ?
+     * @param lon	longitude (RA), degrees
+     * @param lat	latitude (Dec), degrees
+     * @param epoch	epoch of the longitude/latitude, year
+     * @param eepos	error ellipse, mas
+     * @param mu1	proper motion along longitude,  mas/yr
+     * @param mu2	proper motion along latitude,  mas/yr
+     * @param epocho	epoch of proper motion (minimal position error)
+     * @param eepm	error ellipse of proper motion, mas/yr
+     * @param plx2	parallax + its error (mas)
+     * @param rv2	radial velocity + its error (km/s)
+     */
+     public void set (double lon, double lat, double epoch, double[] eepos, 
+	double mu1, double mu2, double epocho, double[] eepm, 
+	double[] plx2, double[] rv2) {
+
+	set(lon, lat, epoch, mu1, mu2);
+        setProperMotion(mu1, mu2);
+	if (eepos != null) 
+	    this.setErrorEllipse(eepos[0], eepos[1], eepos[2], epocho);
+	if (eepm != null)
+	    this.setErrorProperMotion(eepm[0], eepm[1], eepm[2]);
+	if (plx2 != null)
+	    this.setParallax(plx2[0], plx2[1]);
+	if (rv2 != null)
+	    this.setRadialVelocity(rv2[0], rv2[1]);
+     }
+
+   /**
+    * Set a particuliar set of positions in the Astropos.
+    * The precision is adapted to the number of significant digits
+    * existing in the input text string.
+    * @param text  Longitude + latitude in text
+   **/
+    public void set (String text) throws ParseException {
+      Parsing t = new Parsing(text);
+	reset();
+      	if (parsing(t))		// Various items found.
+	    t.gobbleSpaces();
+	if (t.pos != t.length) throw new ParseException
+	    ("****Astropos: argument '" + text + "'+" + t.pos, t.pos);
+    }
+
+  /**
+    * Overload Coo method (see set(String text) )
+   **/
+    public void set(String text, boolean equatorial) throws ParseException {
+	set(text);
+    }
+
+
+  //  ===========================================================
+  //			Set parts 
+  //  ===========================================================
+
+   /**
+    * Set the default epoch of the frame to current epoch
+   **/
+    public void setFrameEpoch() {
+	if (!Double.isNaN(this.epoch))
+	    this.frame.setFrameEpoch(this.epoch);
+    }
+
+   /**
+    * Set a Default Mean Epoch. (e.g. 1991.25 for Hipparcos data)
+    * @param epocho The default mean epoch, in Julian years.
+    * 		An <tt>NaN</tt>value remove the default mean epoch.
+   **/
+    public void setDefaultMeanEpoch(double epocho) {
+	this.epocho = epocho;
+	if (Double.isNaN(epocho))
+	     permanent &= ~0x8;
+	else permanent |= 0x8;
+    }
+
+   /**
+    * Set a Default Error on Position -- later !
+    * @param e_pos Error on position.
+    * 		An <tt>NaN</tt>value remove the default error on position.
+   **/
+    /*
+    public void setErrorPosition(double e_pos) {
+	permanent_epos = e_pos;
+	if (Double.isNaN(e_pos))
+	     permanent &= ~0x10;
+	else permanent |= 0x10;
+    }
+    */
+
+   /**
+    * Set a Default Error on Proper Motion. -- later !
+    * @param e_pm Error on position.
+    * 		An <tt>NaN</tt>value remove the default error on position.
+   **/
+    /*
+    public void setErrorProperMotion(double e_pm) {
+	permanent_epm = e_pm;
+	if (Double.isNaN(e_pm ))
+	     permanent &= ~0x20;
+	else permanent |= 0x20;
+    }
+    */
+
+   /**
+    * Set the Epoch of the position.
+    * @param epoch The epoch of the positions.
+    * 		An <tt>NaN</tt>value remove the default mean epoch.
+    * @return   true when parameter OK, false if ignored.
+   **/
+    public boolean setEpoch(double epoch) {
+        if (ready) return(false);
+	if (Double.isNaN(epoch)) 
+	    specified &= ~0x80;
+	else specified |= 0x80;
+	this.epoch = epoch;
+	return(true);
+    }
+
+   /**
+    * Set the Error Ellipse. Note that the position MUST have been set
+    * 			before, otherwise this parameter is ignored...
+    * @param e_maj Major axis of error ellipse (mas)
+    * @param e_min Minor axis of error ellipse (mas
+    * @param pa    Position angle of error ellipse (deg)
+    * @return   true when parameter OK, false if positions not known.
+    *
+   **/
+    public boolean setErrorEllipse(double e_maj, double e_min, double pa) {
+	return setErrorEllipse(e_maj, e_min, pa, 0./0.);
+    }
+
+   /**
+    * Set the Error Ellipse, with the epoch of this error (epocho, mean epoch)
+    * @param e_maj Major axis of error ellipse (mas)
+    * @param e_min Minor axis of error ellipse (mas
+    * @param pa    Position angle of error ellipse (deg)
+    * @param epocho  Mean epoch (epoch of the error)
+    * @return   true when parameter OK, false if positions not known.
+   **/
+    public boolean setErrorEllipse(double e_maj, double e_min, double pa, 
+	    double epocho) {
+      double[] ell = new double[3];
+      double[] var = new double[3];
+      int i, j;
+        if (ready) return(false);
+	if (Double.isNaN(epocho)) ;
+	else { this.epocho = epocho; specified |= 0x8; }
+	ell[0] = e_maj; ell[1] = e_min; ell[2] = pa;
+	this.errorEllipseToVariance(ell, var);
+	if (cov == null) 
+	    cov = new double[6][6];
+	// Reset to zero all positional parts in the covariance matrix
+	for (i=0; i<3; i++) for (j=i; j<6; j++) 
+	    cov[i][j] = cov[j][i] = 0;
+	cov[1][1] = var[0];		// RA variance
+	cov[2][2] = var[1];		// Dec variance
+	cov[2][1] = cov[1][2] = var[2];	// RA/Dec covariance
+	specified |= 0x10;
+	return(true);
+    }
+
+   /**
+    * Set the Proper Motion
+    * @param mu1   Proper motion along longitude or Right Ascension (mas/yr)
+    * @param mu2   Proper motion along latitude or Declination (mas/yr)
+    * @return   true when parameter OK, false if positions not known.
+   **/
+    public boolean setProperMotion (double mu1, double mu2) {
+        if (ready) return(false);
+	if (Double.isNaN(mu1) || Double.isNaN(mu2)) {
+	    specified &= ~4;	// No proper motion at all...
+	    return(true);
+	}
+	double v[] = new double[3];
+	double d[] = new double[3];
+	v[0] = 0; 
+	v[1] = mu1 / (180.*3.6e6/Math.PI);
+	v[2] = mu2 / (180.*3.6e6/Math.PI);
+	rot2fixed(v, d);
+	xd = d[0]; yd = d[1]; zd = d[2];
+	specified |= 0x04;
+	return(true);
+    }
+
+   /**
+    * Set the Error on Proper Motion
+    * @param e_mu1 Error on longitude or Right Ascension (mas/yr)
+    * @param e_mu2 Error on latitude or Declination (mas/yr)
+    * @return   true when parameter OK, false if positions not known.
+   **/
+    public boolean setErrorProperMotion(double e_mu1, double e_mu2) {
+	return this.setErrorProperMotion(e_mu1, e_mu2, 90.) ;
+    }
+
+   /**
+    * Set the Error on Proper Motions
+    * @param e_maj Major axis of error ellipse (mas)
+    * @param e_min Minor axis of error ellipse (mas
+    * @param pa    Position angle of error ellipse (deg)
+    * @return   true when parameter OK, false if positions not known.
+   **/
+    public boolean setErrorProperMotion(double e_maj, double e_min, double pa) {
+        if (ready) return(false);
+	double[] ell = new double[3];
+	double[] var = new double[3];
+	ell[0] = e_maj; ell[1] = e_min; ell[2] = pa;
+	errorEllipseToVariance(ell, var);
+	if (cov == null) 
+	    cov = new double[6][6];
+	cov[4][4] = var[0];		// mu1 variance
+	cov[5][5] = var[1];		// mu2 variance
+	cov[5][4] = cov[4][5] = var[2];	// mu1/mu2 covariance
+	specified |= 0x20;
+	return(true);
+    }
+
+   /**
+    * Set the Radial Velocity
+    * @param rv    Radial velocity  in km/s
+    * @param err   Error on radial velocity  in km/s
+    * @return   true when parameter OK, false if positions not known.
+   **/
+    public boolean setRadialVelocity (double rv, double err) {
+        if (ready) return(false);
+	this.rv   = rv;
+	this.e_rv = err;
+	specified |= 0x02;
+	return(true);
+    }
+
+   /**
+    * Set the Parallax
+    * @param plx   Parallax, in mas (kpc<sup>-1</sup>)
+    * @param err   Error on parallax (mas)
+    * @return   true when parameter OK, false if positions not known.
+   **/
+    public boolean setParallax (double plx, double err) {
+        if (ready) return(false);
+	this.plx   = plx;
+	this.e_plx = err;
+	specified |= 0x01;
+	return(true);
+    }
+
+  //  ===========================================================
+  //			Get parts of Astropos
+  //  ===========================================================
+
+   /**
+    * getFrame, getPrecision, getLon, getLat, getEditing -- inherited
+   **/
+
+   /**
+    * Get the Error Ellipse of the position
+    * @param ee3 Vector of 3 components <i>(a, b, posAngle)</i> 
+    *        (a and b in mas, posAngle in degrees)
+    * @return true for actual error ellipse, false for estimated one.
+   **/
+    public boolean copyErrorEllipse(double ee3[]) {
+      double var[] = new double[3];
+        if (!ready) compute();
+        var[0] = getVar(1, 1);
+        var[1] = getVar(2, 2);
+        var[2] = getVar(1, 2);
+	varianceToErrorEllipse(var, ee3);
+	return((specified&0x10) != 0);
+    }
+
+    /**
+     * Get the mean error on Longitude ({sigma}RA*cos(Dec))
+     * @return The mean error (estimated or actual) in mas
+    **/
+    public double sigmaLon() {
+        if (!ready) compute();
+	return(Math.sqrt(getVar(1, 1)));
+    }
+
+    /**
+     * Get the mean error on Latitude ({sigma}(Dec))
+     * @return The mean error (estimated or actual) in mas
+    **/
+    public double sigmaLat() {
+        if (!ready) compute();
+	return(Math.sqrt(getVar(2, 2)));
+    }
+
+
+   /**
+    * Get the proper motions (2 components)
+    * @param pm Vector of 2 components (pmRA*cos(Dec), pmDec)
+    * @return true for actual proper motion, false for estimated one.
+   **/
+    public boolean copyProperMotion(double pm[]) {
+	if (R == null) pm[0] = pm[1] = 0./0.;
+	else {
+	    pm[0] = (R[1][0]*xd + R[1][1]*yd)*180.*3.6e6/Math.PI; // R[1][2]=0
+	    pm[1] = (R[2][0]*xd + R[2][1]*yd + R[2][2]*zd)*180.*3.6e6/Math.PI;
+	}
+	return((specified&4) != 0);
+    }
+
+   /**
+    * Get the Longitude proper motion (mas/yr)
+    * @return Proper motion in Longitude (RA), in mas/yr
+   **/
+    public double getProperMotionLon() {
+	if (R == null) return(0);
+	return (R[1][0]*xd + R[1][1]*yd)*180.*3.6e6/Math.PI; // R[1][2]=0
+    }
+
+   /**
+    * Get the Latitude proper motion (mas/yr)
+    * @return Proper motion in Latitude (Dec), in mas/yr
+   **/
+    public double getProperMotionLat() {
+	if (R == null) return(0);
+	return (R[2][0]*xd + R[2][1]*yd + R[2][2]*zd)*180.*3.6e6/Math.PI;
+    }
+
+   /**
+    * Get the Error Ellipse of the Proper Motion
+    * @param ee3 Vector of 3 components <i>(a, b, posAngle)</i> 
+    *        (a and b in mas/Jyr, posAngle in degrees)
+    * @return true for actual error ellipse, false for estimated one.
+   **/
+    public boolean copyProperMotionErrorEllipse(double ee3[]) {
+      double var[] = new double[3];
+        if (!ready) compute();
+        var[0] = getVar(4, 4);
+	var[1] = getVar(5, 5);
+	var[2] = getVar(4, 5);
+	varianceToErrorEllipse(var, ee3);
+	return((specified&0x20) != 0);
+    }
+
+    /**
+     * Get the mean error on Longitude proper motion ({sigma}pmRA*cos(Dec))
+     * @return The mean error (estimated or actual) in mas/yr
+    **/
+    public double sigmaProperMotionLon() {
+        if (!ready) compute();
+	return(Math.sqrt(getVar(4, 4)));
+    }
+
+    /**
+     * Get the mean error on Latitude proper motion ({sigma}(Dec))
+     * @return The mean error (estimated or actual) in mas
+    **/
+    public double sigmaProperMotionLat() {
+        if (!ready) compute();
+	return(Math.sqrt(getVar(5, 5)));
+    }
+
+   /**
+    * Get the Parallax
+    * @param valerr Vector of 2 components <i>(plx, e_plx)</i> (mas)
+    * @return true for actual parallax, false for estimated one.
+   **/
+    public boolean copyParallax(double valerr[]) {
+        if (!ready) compute();
+        valerr[0] = plx;
+        valerr[1] = e_plx;
+	return((specified&1) != 0);
+    }
+
+   /**
+    * Get the Velocity
+    * @param valerr Vector of 2 components <i>(Rvel, e_Rvel)</i> (mas)
+    * @return true for actual parallax, false for estimated one.
+   **/
+    public boolean copyVelocity(double valerr[]) {
+        if (!ready) compute();
+        valerr[0] = rv;
+        valerr[1] = e_rv;
+	return((specified&2) != 0);
+    }
+
+  //  ===========================================================
+  //			Compare two Coordinates
+  //  ===========================================================
+
+   /**
+    * Compare 2 coordinates.
+    * @param o Objet a comparer.
+    * @return Vrai si o est identique a this.
+   **/
+    public boolean equals(Object o) {
+	boolean res = false;
+	if(!(o instanceof Astropos)) return(res);
+      	Astropos a = (Astropos)o;
+	if(!super.equals((Coo)o)) return(res);
+      	res = this.xd == a.xd && this.yd == a.yd && this.zd == a.zd
+	   && this.epocho == a.epocho;
+    	return res;
+    }
+
+  //  ===========================================================
+  //			Edit the Astropos
+  //  ===========================================================
+
+   /**
+    * Method to edit the Coordinates in a StringBuffer
+    * @param buf  Buffer where the result is appended
+    * @param opt  A mixture of the options ED_COLON, ED_DECIMAL,
+    *			ED_FULL, ED_SEXA, ED_FRAME
+    * @return	Number of bytes used in edition
+   **/
+
+    private final StringBuffer ed1 (StringBuffer buf, int opt) {
+	super.edit(buf, opt); 
+    	return (buf);
+     }
+
+
+   /**
+    * Default edition: use what's stored
+    * @return the edited string
+   **/
+   public String toString() {
+       return(toString(editing));
+   }
+
+   /**
+    * Default edition: use what's stored
+    * @param  opt Option, as in Astrocoo
+    * @return the edited string
+   **/
+   public String toString(int opt) {
+     boolean isactual;
+     double[] ee3 = new double[3];
+     double[]  pm = new double[2];
+     int nd;
+      // System.out.println("equinox==" + equinox) ;
+      // System.out.println("z=" + z) ;
+      StringBuffer buf = new StringBuffer(200) ;
+      int o = (precision&0x80) != 0 ? Editing.SEXA3 : Editing.DECIMAL;
+         if (!ready) compute();
+	 // System.out.println("...epocho here, specified="+specified + 
+	 //                    ", editing=" + editing);
+        if (!ready) compute();
+      	super.edit(buf, o|opt);	// Edit coo + Ep
+	// Edit the error ellipse
+	if (isactual = copyErrorEllipse(ee3)) {
+	    nd = precision - 6;
+	    if (nd <= 0) nd = -1;
+	    buf.append(" [");
+	    ed.editDecimal(buf, ee3[0], 0, nd, 0); 
+	    if (isactual) buf.append(' '); else buf.append(": ");
+	    ed.editDecimal(buf, ee3[1], 0, nd, 0); buf.append(' ');
+	    if (isactual) buf.append(' '); else buf.append(": ");
+	    ed.editDecimal(buf, ee3[2], 0, -2, 0); 
+	    // Mean Epoch
+	    if (((specified&8) != 0) || ((editing&EDIT_MEAN_EPOCH) != 0)) {	
+		buf.append(" (");
+		editEpoch(buf, epocho);
+		buf.append(")");
+	    }
+	    buf.append(']');
+	}
+	// Edit the proper motion (max = 6 decimales) and RV
+	if (isactual = copyProperMotion(pm)) {
+	    buf.append(" ");
+	    ed.editDecimal(buf, pm[0], 0, -6, Editing.SIGN_EDIT);
+	    buf.append(" ");
+	    ed.editDecimal(buf, pm[1], 0, -6, Editing.SIGN_EDIT);
+	    if (isactual = copyProperMotionErrorEllipse(ee3)) {
+		nd = -2;
+	        buf.append(" [");
+	        ed.editDecimal(buf, ee3[0], 0, nd, 0); 
+	        if (isactual) buf.append(' '); else buf.append(": ");
+	        ed.editDecimal(buf, ee3[1], 0, nd, 0); buf.append(' ');
+	        if (isactual) buf.append(' '); else buf.append(": ");
+	        ed.editDecimal(buf, ee3[2], 0, -2, 0); 
+	        buf.append(']');
+	    }
+	}
+	// Edit the Radial Velocity
+	if ((specified&2) != 0) {
+	    buf.append(" ");
+	    ed.editDecimal(buf, rv, 0, -6, Editing.SIGN_EDIT);
+	    buf.append('[');
+	    ed.editDecimal(buf, e_rv, 0, -6, 0);
+	    buf.append("]km/s");
+	}
+	// Edit the Parallax
+	if ((specified&1) != 0) {
+	    buf.append(" ");
+	    ed.editDecimal(buf, plx, 0, -6, 0);
+	    buf.append('[');
+	    ed.editDecimal(buf, e_plx, 0, -6, 0);
+	    buf.append("]");
+	}
+      	return buf.toString();
+   }
+  //  ===========================================================
+  //			Convert Astropos
+  //  ===========================================================
+
+   /**
+    * Change the epoch of the position (in the same frame)
+    * @param Jyr the new epoch
+   **/
+    public void toEpoch(double Jyr) {
+      double t = Jyr - this.epoch; 	// Epoch change
+      
+	if(DEBUG) {
+	    System.out.println("....toEpoch(" + this.epoch + ") => " + Jyr);
+	}
+        if (t == 0.) return;
+	if (!ready) compute();
+	x += t*xd;
+	y += t*yd;
+	z += t*zd;
+	if (cov != null)
+	    propagate_error(cov, t);
+	epoch = Jyr;		// This is my new epoch.
+	normalize();
+	return;
+    }
+
+   /**
+    * Transform the position into another frame.
+    * On return, all astrometric components are converted into the
+    * new frame specified, at the default epoch of new_frame.
+    * @param new_frame	The frame of the resulting position.
+   **/
+    public void convertTo(Astroframe new_frame) {
+      double new_epoch, t;
+      double inflation = 1;			// Change of scale
+      double Rmov[][] = null;
+      double u[] = null;
+
+	if (!ready) compute();
+        new_epoch = new_frame.epoch;
+	if(DEBUG) System.out.println("....Astropos convert from " 
+		+ this.getFrame() + ",Ep=" + this.epoch + " to " 
+		+ new_frame + ",Ep=" + new_epoch);
+
+	/* Verify first if frames identical -- then it's just changing Epoch */
+	if (this.frame.equals(new_frame)) {
+	    if(DEBUG) System.out.println("....(identical frames)");
+	    if (new_epoch != this.epoch)
+		toEpoch(new_epoch);
+	    return;
+	}
+
+	// Move via ICRS
+	if(DEBUG) System.out.println("....Astropos.convert via ICRS:  "
+		+ this.frame + " => ICRS => " + new_frame);
+
+	// Use a 6-vector for the conversions
+	u = new double[6];
+	u[0] = x;  u[1] = y;  u[2] = z;
+	u[3] = xd; u[4] = yd; u[5] = zd;
+	if(DEBUG) System.out.println(Coo.toString(".... convert(1): ", u));
+
+	// FK4 is a problem: must move to Epoch+Equinox B1950, 
+	//    then convert pos+pm to Equinox+Epoch J2000.
+	
+	/* Apply the change of epoch on the original frame... */
+	t = this.frame.base_epoch - this.epoch;
+	if (t!=0) {
+	    if(DEBUG) System.out.println("     Change epoch: " + this.epoch
+		    + " to " + this.frame.base_epoch + " on " + this.frame);
+	    u[0] += u[3] * t;
+	    u[1] += u[4] * t;
+	    u[2] += u[5] * t;
+	    inflation *= Coo.normalize(u);
+	    if(DEBUG) System.out.println(Coo.toString(".... base_ep(2): ", u));
+	}
+	// this.dump("  (1). ");
+
+	/* Convert to ICRS, J2000 */
+	this.frame.toICRS(u);	// now for Epoch+Equinox=J2000 */
+	if(DEBUG) System.out.println(Coo.toString(".... in.ICRS(3): ", u));
+
+	/* Convert now to what's asked */
+	new_frame.fromICRS(u);		// now in 'new' frame
+	if(DEBUG) System.out.println(Coo.toString(".... baseNew(4): ", u));
+
+	/* Apply the change of epoch on the final frame... */
+	t = new_epoch - new_frame.base_epoch;
+	if (t!=0) {
+	    if(DEBUG) System.out.println("     Change epoch: " 
+		    + new_frame.base_epoch + " to " 
+		    + new_epoch + " on " + new_frame);
+	    u[0] += u[3] * t;
+	    u[1] += u[4] * t;
+	    u[2] += u[5] * t;
+	    inflation *= Coo.normalize(u);
+	    if(DEBUG) System.out.println(Coo.toString(".... finalEp(5): ", u));
+	}
+	// this.dump("  (2). ");
+
+	// Propagate the errors
+	if (cov != null) {
+	    Coo tcoo = new Coo(u[0], u[1], u[2]);
+	    propagate_error(cov, new_epoch - epoch);
+	    Rmov = this.moveMatrix(tcoo);	// Matrix for rotation of errors
+	}
+	// this.dump("  (3). ");
+
+	// Copy the final result
+	if(DEBUG) System.out.println(Coo.toString(".... convEnd(6): ", u));
+	this.lon = this.lat = 0./0.;	// Actual angles yet computed
+	this.x  = u[0];
+	this.y  = u[1];
+	this.z  = u[2];
+	this.xd = u[3];
+	this.yd = u[4];
+	this.zd = u[5];
+	this.epoch = new_epoch;
+	this.frame = new_frame;
+	// this.dump("  (4). ");
+	inflation *= this.normalize();
+
+	// Propagate parallax change...
+	if(DEBUG) System.out.println(".... Total inflation=" + inflation);
+	this.plx   /= inflation;
+	this.e_plx /= inflation;
+	// this.dump("  res. ");
+	
+	// rotate the variance
+	if (Rmov != null) 
+	    rotate_cov(Rmov, cov);
+
+	// recompute the Rxx
+	this.localMatrix(R);
+    }
+
+   /**
+    * Express a celestial position in another Coordinate Frame
+    * @param coo	another frame to which convert the coordinates.
+    * "<tt>this</tt>" object is modified and will contain the new coordinates
+    * ----- NOT NECESSARY
+    public void convertFrom(Astropos coo) {
+      Astroframe new_frame = this.frame;
+      double t = this.epoch - coo.epoch;
+      int i, j;
+
+	if (!ready) compute();
+	if(DEBUG) System.out.println("....Astropos convert from " 
+		+ coo.getFrame() +" to " + this.getFrame());
+
+	// Copy the values
+	super.set((Astrocoo)coo);
+	this.formRA = coo.formRA;	// Is it really necessary ?
+	this.specified = coo.specified;
+	this.epocho = coo.epocho;
+	this.plx = coo.plx;
+	this.e_plx = coo.e_plx;
+	this.rv = coo.rv;
+	this.e_rv = coo.e_rv;
+	this.xd = coo.xd; this.yd = coo.yd; this.zd = coo.zd;
+
+	// Propagate the change of error ellipse
+	if ((this.cov == null) && (coo.cov != null))
+	    this.cov = new double[6][6];
+	if (this.cov != null) {
+	    for (i=0; i<6; i++) for (j=0; j<6; j++)
+	       this.cov[i][j] = coo.cov[i][j];
+	    propagate_error(this.cov, t);
+	}
+
+	this.convertTo(new_frame, true);
+    }
+   **/
+
+}
Index: aladin/cds/astro/Astrotime.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Astrotime.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,501 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                Astrotime class
+ *==================================================================*/
+
+import java.text.*;	// for parseException
+import java.util.Date;
+
+/**
+ * The astronomical time may be expressed in (Modified) Julian Days,
+ * Julian Years or Besselian years. The conversion to Calendar can use the
+ *       Calendar.setTimeInMillis(JD2Millis(date))
+ * @author Francois Ochsenbein [CDS]
+ * @version 1.0 : 21-Feb-2004: Imported from original Astroframe
+ * @version 1.1 : 15-Aug-2004: Method getByr getJyr getJD getMJD getTime
+ * @version 1.2 : 02-Sep-2006: Interpret date/time
+ *
+ */
+
+public class Astrotime {
+    /** The actual date/epoch is stored as MJD value (JD-2400000.5) */
+    protected double mjd;
+    /** The original choice of the date (index in 'prefix' table) */
+    protected byte unit;
+    /** The original precision  = number of decimals + 1 (in specified unit);
+      * it's 0 when only month is known.
+     **/
+    protected byte precision;
+    /** The default choices of the edition for this class */
+    static public Editing ed = new Editing("--");	// How to edit time
+    /* Default Equinoxes in Julian Years */
+    /** Value of Besselian Year in days */
+    static final public double Byr = 365.242198781e0 ;	// Besselian Year
+    /** Value of the Julian Year in days */
+    static final public double Jyr = 365.25e0 ;		// Julian Year
+    /** Julian date of J2000 epoch */
+    static final public double JD_J2000 = 2451545. ;	// Julian Date of J2000
+    /** Julian date of B1900 epoch */
+    static final public double JD_B1900 = 2415020.31352;// Julian Date of B1900
+    /** Julian date of 1 Jan 1970  */
+    static final public double JD_1970 = 2440587.5;	// Julian Date of Origin
+    /** Modified Julian date */
+    static final public double JD_MJD0 = 2400000.5;	// Origin of MJD
+    /** Conversion of time: time in unit = mjd*factor + offset */
+    static final public String[] prefix = {
+	"\"date\"", "MJD", "JD", "J", "B", "ms"
+    };
+    static final private double[] factor = {
+	1., 1., 1., 1./Jyr, 1./Byr, 86400.e3
+    };
+    /** Origin of the different time scales from MJD0 (1858-11-17T00:00:00) */
+    static final public double[] offset = {
+	0., 0., JD_MJD0, 
+	2000.-((JD_J2000-JD_MJD0)/Jyr), 
+	1900.-((JD_B1900-JD_MJD0)/Byr), 
+	-86400.e3*(JD_1970-JD_MJD0)
+    };
+    static final private byte[] ilen = {  // Default length of integer part
+	10, 5, 7, 4, 4, 12 
+    };
+
+  /*  Static methods (functions) in Java are very close to C ones;
+      they do not require any object instanciation.
+      Typical example of static methods are in the Math class
+  */
+
+   /* Conversions of Times between B(esselian Year) / J(ulian year) / JD  */
+   /**
+    * Conversion of a Julian epoch to a Julian Date
+    * @param y Julian epoch
+    * @return Julian Date
+   */
+   public static final double J2JD(double y) {
+      return JD_J2000 + (y-2000)*Jyr ;
+   }
+   /**
+    *  Conversion of a Besselian epoch to a Julian Date
+    * @param y Besselian epoch
+    * @return Julian date
+    */
+   public static final double B2JD(double y) {
+      return JD_B1900 + (y-1900)*Byr ;
+   }
+
+   /**
+    * Conversion of a calendar date into a Julian Date.
+    * Note that if month=0, day may represent the day-in-year.
+    * When month is outside range 0..11, it's assumed to be January.
+    * @param year  Year number
+    * @param month  Month number, range 0=January to 11=December
+    * @param day  Day number, range 1 to 31
+    * @return Julian Date
+    */
+   public static final double YMD2JD(int year, int month, int day) {
+     int i, jdi;
+     double jd;
+	/* Convert to a Julian Date */
+	if (year <= -4712) {
+	    i = 1 + (year + 4712)/400;
+	    jdi = -i * 146097;		// 146097 days = 400 yrs
+	    i = year + 400*i;
+	}
+	else { jdi = 0; i = year; }
+	if (day <= 0) day = 1;		// In case just year/month
+	if (month<0 || month>11) month = 0;
+	// if ((status&2)!=0) {		// Month is present
+	    i  -= (11 - month)/10;
+	    jdi += (1461* ( i + 4712))/4 + (306 * ((month+10)%12) + 5)/10
+		- (3* ((i + 4900)/100))/4 + day + 96 ;
+	// }
+	/* --- No problem if month not specified -- it's January...
+	else {	// Month not specified -- use 400-yr = 146097 days cycle 
+	    i = year % 400 ; year /= 400 ;
+	    if (i < 0) { i += 400 ; year-- ; }
+	    jdi = 365*i + (i+3)/4 - (i-1)/100 ;
+	    jdi += 1721059 + (year * 146097) ;
+	}
+        ---------------------------------------- */
+	jd = jdi;
+	return(jd+0.5);
+   }
+
+   /**
+    * Conversion of a Julian Date into a calendar year/month/day.
+    * When month is outside range 0..11, it's assumed to be January.
+    * @param jd    Julian date
+    * @param ymd   array on return with year month day.
+    * 		year=ymd[0], month=ymd[1](range 0..1), day=ymd[2](range 1..31).
+    * 		Day in year (range 1..366) is given as 
+    * 		ymd[1] if ymd has 2 elements, ymd[3] if 4 elements.
+    */
+   public static final void JD2YMD (double jd, int[] ymd) {
+     int j, n4, nd10, year;
+        j = (int)(jd+0.5);
+	year = -4712;
+	while (j <= 4480)   { j += 146097; year -= 400;}
+	n4 = 4*(j+((2*((4*j-17918)/146097)*3)/4+1)/2-37);
+	nd10=10*( ((n4-237)%1461)/4)+5;
+
+	ymd[0] = year + n4/1461;
+	if (ymd.length>1) {
+	    ymd[1] = (nd10/306+2)%12;
+	    ymd[2] = (nd10%306)/10+1;
+	}
+
+	/* Compute mday */
+	if (ymd.length!=3) {
+	    n4 = (j+32104)%146097;	// Day in 400-yr cycle, #0=01-Jan-2000
+	    if (n4 >= 36525)		// Century#0 is 25 leap years
+		n4 += (n4-366)/36524;
+	    n4 %= 1461;			// Day in 4-yr cycle
+	    if (n4 >= 731) n4 += (n4-366)/365;
+	    j = 1 + (n4%366);		// Day-in-year number
+	    if (ymd.length == 2) 
+		 ymd[1] = j;
+	    else ymd[3] = j;
+	}
+   }
+
+   /**
+    * Conversion of a calendar time expressed in Milliseconds to a Julian Date
+    * @param ms  UTC millisconds got e.g. via Calendar.getTimeInMillis()
+    * @return Julian Date
+    */
+   public static final double ms2JD(long ms) {
+      return JD_1970 + ((double)ms/86400.e3);
+   }
+
+   /**
+    * Conversion of a MJD to JD
+    * @param mjd Modified Julian Date
+    * @return Milliseconds e.g. to set date via Calendar.setTimeInMillis()
+    * @return corresponding Julian Date
+    */
+   public static final double MJD2JD(double mjd) {
+      return JD_MJD0 + mjd;
+   }
+
+   /**
+    * Conversion of a Julian Date to a Julian  epoch
+    * @param jd Julian Date
+    * @return Julian epoch
+    */
+   public static final double JD2J(double jd) {
+      return 2000 + (jd-JD_J2000)/Jyr ;
+   }
+
+   /**
+    * Conversion of a Julian Date to a Besselian epoch
+    * @param jd Julian Date
+    * @return Besselian epoch
+    */
+   public static final double JD2B(double jd) {
+      return 1900 + (jd-JD_B1900)/Byr ;
+   }
+
+   /**
+    * Conversion of a Julian Date to a Milliseconds since 1 January 1970
+    * @param jd Julian Date
+    * @return Milliseconds e.g. to set date via Calendar.setTimeInMillis()
+    */
+   public static final long JD2ms(double jd) {
+      return (long)((jd-JD_1970)*86400e3);
+   }
+
+   /**
+    * Conversion of a JD to MJD
+    * @param jd Julian Date
+    * @return Modified Julian Date = JD - 2400000.5
+    */
+   public static final double JD2MJD(double jd) {
+      return jd - JD_MJD0;
+   }
+
+   /**
+    * Conversion of a Besselian epoch to a Julian  epoch
+    * @param y Besselian epoch
+    * @return Julian epoch
+    */
+   public static final double B2J(double y) {
+      return JD2J(B2JD(y)) ;
+   }
+
+   /**
+    * Conversion of a Julian epoch to a Besselian epoch
+    * @param y Julian epoch
+    * @return Besselian epoch
+    */
+   public static final double J2B(double y) {
+      return JD2B(J2JD(y)) ;
+   }
+
+  //  ===========================================================
+  //                    Constructors
+  //  ===========================================================
+
+   /**
+    * Default contructor (undefined time)
+    */
+    public Astrotime () {
+	mjd = 0./0.;
+	unit = 0;
+	precision = 8;
+    }
+    
+   /**
+    * Constructor from a String.
+    * @param text Sting expression of an Astrotime.
+    * 	Valid input values can be "Byyyy...", "Jyyyy...", "JDxxx" or "MJD..."
+    * @throws ParseException when <em>text</em> can't be interpreted.
+    */
+    public Astrotime (String text) throws ParseException {
+      	this.set(text);
+    }
+
+   /**
+    * Dump the time contents.
+    */
+    public final void dump (String title) {
+	System.out.println(title + " unit=" + unit + ", precision=" + precision
+		+ ", mjd=" + mjd);
+    }
+
+   /**
+    * Interpret a string for a time.
+    * @param t	Text to interpret as a Parsing object
+    * @return true if something could be interpretated.
+    */
+    public boolean parsing (Parsing t) {
+      int posini = t.pos;
+      int k, pos1, prec;
+      double x;
+      	t.gobbleSpaces();
+	prec = 0;		// Lowest precision, i.e. year/month
+      	k = t.lookup(prefix); 
+	pos1 = t.pos;
+	if (k<=0) {		/* V1.2 -- No prefix, try a standard date ? */
+	    int pdate = t.parseDate();
+	    boolean sexatime = false;
+	    x = 0;		// Default time part
+	    if (t.pos > pos1) {
+	        k = 0;		// It's "date" unit
+		int pos2 = t.pos;
+		prec = t.format()&(~Astroformat.DATE_alpha);
+		if (prec == Astroformat.DATE_YM || prec == Astroformat.DATE_MY)
+		     prec = 0;
+		else prec = 1;
+		if (prec == 1) {
+      	            char c = t.currentChar();
+		    if (c == '.') {		// Decimal day, or time ?
+			x = t.parseDecimal();
+			if (sexatime = t.match(':'))
+			     t.set(pos2);
+			else prec = 1+t.decimals();
+		    }
+		    /* ISO-8601 uses T to separate date/time */
+		    else sexatime = (c == 'T') || (c == ':') || (c == ' ');
+		    if (sexatime) {
+			t.advance(1);
+			x = t.parseSexa();
+			if ((t.pos-pos2)>1) {
+			    x /= 24.;
+			    prec = 2+t.decimals();
+			}
+			else {
+			    t.set(pos2);
+			    x = 0;
+			}
+		    }
+		}
+		// System.out.print  ("...Astrotime.parse: prec=" + prec);
+	        x += pdate;
+		// System.out.println(", date=" + x);
+	    }
+	}
+	else {
+      	    x = t.parseDouble();
+	    prec = 1+t.decimals();
+	}
+	if (t.pos == pos1) {	// No value found -- can't work
+	    t.set(posini);
+	    return(false);
+	}
+	precision = (byte)prec;
+        if (k<0) k = t.lookup(prefix);	// Accept type of time as a suffix.
+	if (k<0) k=3;			// Default (no prefix) == Julian year.
+	// System.out.println("....k=" + k + ", offset=" + offset[k]);
+	mjd = (x-offset[k])/factor[k];
+	return(true);
+    }
+
+   /**
+    * Interpret a string for a time. 
+    * Accepts a time surrounded by brackets, or preceded by , /
+    * @param text   String expression of an Astrotime
+    * @param offset Where to start in the text
+    * @return the number of bytes interpretated (offset if an error)
+    */
+    public int parse(String text, int offset) {
+      Parsing t = new Parsing(text, offset);
+      return( parsing(t) ? t.pos : offset );
+    }
+
+   /**
+    * Set the time from MJD.
+    * @param mjd Date/time in MJD (JD-2400000.5)
+    */
+    public void set(double mjd) {
+	this.mjd = mjd;
+	unit = 1;
+	precision = 8;
+    }
+
+   /**
+    * Set the time from milliseconds.
+    * @param ms Date/Time in milliseconds.
+    * 		(e.g. value returned from Calendar.getTimeInMillis()).
+    * 		The default edition is in JD, with 8 decimals.
+    */
+    public void set(long ms) {
+	mjd = (JD_1970-JD_MJD0) + (double)ms/86400.e3;
+	unit = 0;
+	precision = 8;
+    }
+
+   /**
+    * Set the time from a String.
+    * Valid times are "Byyyy...", "Jyyyy...", "JDxxx" or "MJD..."
+    * eventually surrounded by brackets, or preceded by , /
+    * @param text Sting expression of an Astrotime
+    * @throws ParseException when <em>text</em> can't be interpreted.
+    */
+    public void set(String text) throws ParseException {
+      Parsing t = new Parsing(text);
+      	if (parsing(t)) 	// Verify text completely interpretated
+	    t.gobbleSpaces();
+	if (t.pos != t.length) throw new ParseException
+	    ("****Astrotime: argument '" + text + "'", t.pos);
+    }
+
+  //  ===========================================================
+  //                    Get the time in its different forms
+  //  ===========================================================
+
+   /**
+    * Get the time expressed in MJD (JD-2400000.5)
+    */
+    public double getMJD() {
+	return(mjd);
+    }
+
+   /**
+    * Get the time expressed in Julian yr
+    */
+    public double getJyr() {
+	return(2000.+((mjd+(JD_MJD0-JD_J2000))/Jyr));
+    }
+
+   /**
+    * Get the time expressed in Besselian yr
+    */
+    public double getByr() {
+	return(1900.+((mjd+(JD_MJD0-JD_B1900))/Byr));
+    }
+
+   /**
+    * Get the time expressed in JD
+    */
+    public double getJD() {
+	return(mjd+JD_MJD0);
+    }
+
+   /**
+    * Get the time expressed in milliseconds since 1 Jan 1970
+    */
+    public long getTime() {
+      	return (long)((mjd+(JD_MJD0-JD_1970))*86400e3);
+    }
+
+  //  ===========================================================
+  //                    Edit the time
+  //  ===========================================================
+
+   /**
+    * Internal edition
+    * @param i     Index in "unit"
+    * @param value The number to edit
+    */
+    private final void edit(StringBuffer b, int i, double v) {
+	if (i>0) b.append(prefix[i]);
+	if (Double.isNaN(v) || (i>0)) {
+	    ed.editDecimal(b, v, ilen[i], precision-1, 0);
+	    return;
+	}
+	// System.out.println("\n....Astrotime.edit: precision=" + precision);
+	// Here edit ISO-8601 DAte+Time
+	int iv = (int)v;
+	double dv = v-iv;	// Fraction of day
+	if (dv< -1.e-11) {
+	    --iv;
+	    dv += 1.0;
+	}
+	else if (dv<0) dv = 0;
+	
+	ed.editDate(b, iv);	// Standard date edition.
+	if (precision == 0) 	// Month only
+	    b.setLength(b.length()-3);
+	if (precision <= 1)	// No fraction
+	    return;
+	b.append('T');
+	ed.editSexa(b, dv*24., 2, precision-2, 
+		Editing.ZERO_FILL|Editing.SEXA3c);
+    }
+
+   /**
+    * Edit the time in the specified choice.
+    * @param unit One of the possibilities "JD" "MJD" "J" "B" "ms"
+    */
+    public String toString(String unit) {
+      StringBuffer b = new StringBuffer(32);
+      double v; int i;
+	for (i=0; i<prefix.length; i++) {
+	    if (unit.equals(prefix[i])) break;
+	}
+	if (i == prefix.length) i = this.unit;	// Default
+	v = this.mjd*factor[i] + offset[i];
+	this.edit(b, i, v);
+	return(b.toString());
+    }
+
+   /**
+    * Get the time expressed in milliseconds since 1 Jan 1970
+    */
+    public String toString() {
+      double v = this.mjd*factor[this.unit] + offset[this.unit];
+      StringBuffer b = new StringBuffer(32);
+        this.edit(b, this.unit, v);
+	return(b.toString());
+    }
+
+}
Index: aladin/cds/astro/CheckPosition.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/CheckPosition.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,156 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+import java.io.*;
+import java.util.*;
+import java.text.*; // for parseException
+
+/*==================================================================*
+  Interface for positional checks
+ *==================================================================*/
+
+/**
+ * CheckPosition is an interface which has to tell whether a {@link Qbox}
+ * can match a target.
+ **/
+
+interface CheckPosition {
+    /** QBOX_NONE means that this Qbox is completely outside the target */
+    static final int QBOX_NONE = 0;
+    /** QBOX_ANY  means that this Qbox is fully included within the target */
+    static final int QBOX_ANY = -1;
+    /** QBOX_SOME means that this Qbox intersects the Target (need checking) */
+    static final int QBOX_SOME = 1;
+    static boolean DEBUG = true;
+    /**The method which checks a qbox, must return one of the 3 statuses
+     * QBOX_NONE QBOX_ANY QBOX_SOME */
+    int checkTarget(int qbox);
+}
+
+/** Check a Circular Target
+ * return	a Vector with marked Qboxes
+ **/
+class CheckRadius implements CheckPosition {
+    double[] XY = new double[4]; // Corners
+    Coocube target; // Center
+    double[] u0 = new double[3]; // Center: direction cosines
+    double radius, sh2, s2r; // Radius, 4sin^2(r/2), sin^2(r)
+    Qbox abox = new Qbox();
+
+    /** Constructor
+     * @param	c the center of the target
+     * @param	r the target radius, in degrees.
+     **/
+    CheckRadius(Coo c, double r) {
+    	//if (DEBUG) System.out.println("....new CheckRadius(" + c
+    	//    + ", r=" + r + ")");
+    	target = new Coocube(c);
+    	u0[0] = target.x;
+    	u0[1] = target.y;
+    	u0[2] = target.z;
+    	radius = r;
+    	s2r = AstroMath.sind(r);
+    	s2r *= s2r;
+    	sh2 = 2. * AstroMath.sind(r / 2);
+    	sh2 *= sh2;
+    }
+
+    /** Verify Target in Circle
+     * @param	qbox the Qbox to check
+     * @return	QBOX_NONE / QBOX_ANY / QBOX_SOME
+     **/
+    public int checkTarget(int qbox) {
+    	double[][] u4 = new double[5][3];
+    	Coocube cc;
+    	int i, f, lev;
+    	double r;
+
+    	abox.set(qbox);
+    	lev = abox.level();
+    	cc = abox.center();
+    	r = cc.distance(target); // Distance from Qboxcenter
+    	//if (DEBUG) System.out.println("....CheckTarget(" + qbox + "): lev="
+    	//    + lev + "\n    pos=" + cc + "\n    r=" + r);
+    	if (r >= (Qbox.MAXRAD[lev] + radius)) { // All points outside
+    		return (Qbox.QBOX_NONE);
+    	}
+    	if (radius >= (Qbox.MAXRAD[lev] + r)) {
+    		return (Qbox.QBOX_ANY);
+    	}
+
+    	// Check more accurately: can the box be completely included ?
+    	// Easy: if all corners are inside the circle ...
+
+    	if (radius >= (Qbox.MINRAD[lev] + r)) {
+    	    f = Qbox.ucorners(abox.qbox, u4);
+    	    for (i = 0; i < 4; i++) {
+    	    	if (Qbox.dist2(u4[i], u0) > sh2) {
+    	    		return (Qbox.QBOX_SOME);
+    	    	}
+    	    }
+    	    //cc.set(f, XY[0], XY[1]);
+    	    //if (cc.dist(target) > radius) return(Qbox.QBOX_SOME);
+    	    //cc.set(f, XY[2], XY[1]);
+    	    //if (cc.dist(target) > radius) return(Qbox.QBOX_SOME);
+    	    //cc.set(f, XY[2], XY[3]);
+    	    //if (cc.dist(target) > radius) return(Qbox.QBOX_SOME);
+    	    //cc.set(f, XY[0], XY[3]);
+    	    //if (cc.dist(target) > radius) return(Qbox.QBOX_SOME);
+    	    return (Qbox.QBOX_ANY);
+    	}
+
+    	// Check now if the box is completely outside the circle.
+    	// More tricky, not only all corners must be outside,
+    	//  but the distance to any of the vertices must be smaller
+    	// than the target radius
+    	// Method used: distance between center and a vertice
+    	//  is computed from vector product:
+    	//  sin(dist) = (a^b).C/||a^b||
+    	//  if (a,b) = vertices and C = center
+
+    	if (r >= Qbox.MINRAD[lev] + radius) {
+    	    double[] v = new double[3];
+    	    int n = 0; // Count of positive determinant
+    	    Qbox.ucorners(abox.qbox, u4);
+    	    u4[4][0] = u4[0][0];
+    	    u4[4][1] = u4[0][1];
+    	    u4[4][2] = u4[0][2];
+    	    for (i = 0; i < 4; i++) {
+    	    	Qbox.vecprod(u4[i], u4[i + 1], v);
+    	    	r = Qbox.dotprod(v, u0); // (v1^v2).v0
+    	    	//if (DEBUG) System.out.println("....Check outside, i=" + i
+    	    	//    + ": r=" + r + ", d2=" + (r*r/Qbox.norm2(v)));
+    	    	if (r >= 0) {
+    	    		n++; // Center inside the box ?
+    	    	}
+    	    	if (r * r <= s2r * Qbox.norm2(v))  
+    	    	    return (Qbox.QBOX_SOME);	// Distance to vertice too small
+    	    }
+    	    if (DEBUG) 
+    	    	System.out.println("....Check outside==n=" + n);
+    	    if (n == 4) 
+    	    	return (Qbox.QBOX_SOME);
+    	    return (Qbox.QBOX_NONE);
+    	}
+    	return (Qbox.QBOX_SOME);
+    }
+}
+
Index: aladin/cds/astro/Converter.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Converter.java	2012-09-27 15:30:32.000000000 +0200
@@ -0,0 +1,242 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/**
+ *==========================================================================
+ * @author  Brice GASSMANN, Francois Ochsenbein-- francois@astro.u-strasbg.fr
+ * @version 0.9 15-Nov-2006: 
+ *==========================================================================
+ */
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * This class, tightly connected to the {@link Unit} class,
+ * gathers <em>non-standard</em> unit conversions.<P>
+ * <em>Standard</em> conversions are made between units having the same physical
+ * dimension, as e.g. a conversion between <b>Hz</b> and <b>km/s/Mpc</b>.
+ * Conversion bewteen units having different physical dimensions are called
+ * <em>non-standard</em>, e.g. between hours (time) and degrees (angle).
+ * This default class contains linear transformations only; a derived class
+ * can be used if necessary to generate more complex converters.
+ * @author  Brice GASSMANN, Francois Ochsenbein-- francois@astro.u-strasbg.fr
+ * @version 1.0 15-Nov-2006: Finalisation
+ */
+public class Converter {
+    /**
+     * The source unit
+    **/
+     public Unit source;
+    /**
+     * The target unit
+    **/
+     public Unit target;
+    /**
+     * The conversion factor, if used (target = factor * source)
+    **/
+     public double factor;
+    /**
+     * The conversion offset, if used (target = factor * source + offset)
+    **/
+     // public double offset;
+    /**
+     * separator beween the units (a Unicode arrow)
+    **/
+     static char SEP = '\u27fe';
+
+    /*==================================================================
+			Constructors
+     *==================================================================*/
+
+     /**
+      * Creation of a <em>standard converter</em>.
+      * The standard rules of unit conversion are applied 
+      * (see {@link Unit#convert})
+      * @param source_unit unit of source value
+      * @param target_unit unit of target value
+      **/
+     public Converter(String source_unit, String target_unit) {
+	this.factor = 0./0.; // this.offset = 0;
+	try {  this.source = new Unit(source_unit); }
+	catch (Exception e) { System.err.println(e); source = null; }
+	try {  this.target = new Unit(target_unit); }
+	catch (Exception e) { System.err.println(e); target = null; }
+	// No need to register, uses the standard Unit.convertUnit
+    }
+
+     /**
+      * Creation (and registration) of a unit converter.
+      * New objects of this class are known in {@link Unit#convert},
+      * i.e. the {@link #convert} method defined here is applied.<p>
+      * Examples could be
+      * <tt> Converter("h", "deg", 15.)</tt> or 
+      * <tt> Converter("\"d:m:s\"", "\"h:m:s\"", 1./15.)</tt>
+      * @param source_unit unit of source value.
+      * @param target_unit unit of target value
+      * @param factor factor of conversion in: target = factor * source 
+      **/
+     public Converter(String source_unit, String target_unit, double factor) {
+	// Prepare the units, and register them 
+	try { this.source = new Unit(source_unit); this.source.setUnit(); }
+	catch (Exception e) {
+	     System.err.println(e);
+	     source = null;
+	}
+	try { this.target = new Unit(target_unit); this.target.setUnit(); }
+	catch (Exception e) {
+	    System.err.println(e);
+	    target =null;
+	}
+	this.factor = factor;
+	Unit.registerConverter(source_unit, target_unit, this);
+    }
+
+     /**
+      * Creation of a unit converter. An example can be:
+      * <tt> Converter("h", "deg", 15.)</tt> or 
+      * <tt> Converter("\"d:m:s\"", "\"h:m:s\"", 1./15.)</tt>
+      * @param source_unit unit of source value.
+      * @param target_unit unit of target value
+      * @param factor factor of conversion in: target = factor * source + offset
+      * @param offset offset of conversion in: target = factor * source + offset
+      ** 
+     public Converter(String source_unit, String target_unit, 
+	     double factor, double offset) {
+	// Prepare the units, and reigster them 
+	try { this.source = new Unit(source_unit); this.source.setUnit(); }
+	catch (Exception e) {
+	     System.err.println(e);
+	     source = null;
+	}
+	
+	// Not necessary to define a new symbol...
+    	if (!Unit.checkSymbol(target_unit)) {
+	    try   { this.target = Unit.addSymbol(target_unit, target_unit); }
+	    catch (Exception e) { 
+		System.err.println(e);
+		target =null;
+	    }
+	}
+	try { this.target = new Unit(target_unit); this.target.setUnit(); }
+	catch (Exception e) {
+	    System.err.println(e);
+	    target =null;
+	}
+	this.factor = factor;
+	this.offset = offset;
+	Unit.registerConverter(source_unit, target_unit, this);
+    }
+    **/
+
+    /*==================================================================
+			Dump
+     *==================================================================*/
+    /**
+     * Dump the object
+     * @param	title title line of the dump
+     **/
+    public void dump(String title) {
+	System.out.println(title+"(factor="+factor+")");
+	source.dump("source_unit ");
+	source.dump("target_unit ");
+    }
+
+    /*==================================================================
+			Conversion
+     *==================================================================*/
+
+    /**
+     * Convert a number.
+     * Convert the value from <em>source</em> unit into <em>target</em> unit
+     * @param	value the value (expressed in source)
+     * @return	the corresponding value, expressed in <em>target</em> units.
+     **/
+    public double convert(double value) throws ArithmeticException {
+	source.setValue(value);
+	if (factor == factor) 	// factor is not NaN, apply the factor
+	    target.setValue(value*factor/*+offset*/);
+	else 			// Apply the standard rules:
+	    Unit.convert(source, target);
+	return(target.value);
+    }
+
+    /**
+     * Convert a value.
+     * Convert the value from <em>source</em> unit into <em>target</em> unit
+     * @param	value the value (expressed in source)
+     * @return	the corresponding value, expressed in <em>target</em> units.
+     **/
+    public double convert(String value) 
+	throws ParseException, ArithmeticException {
+	source.setValue(value);
+	if (factor == factor) 	// factor is not NaN, apply the factor
+	    target.setValue(source.value*factor);
+	else 			// Apply the standard rules:
+	    Unit.convert(source, target);
+	return(target.value);
+    }
+
+    /**
+     * Convert a value, return its edited form.
+     * Convert the value from <em>source</em> unit into <em>target</em> unit
+     * @param	value the value (expressed in source)
+     * @return	the corresponding edited value, expressed in 
+     * 		<em>target</em> units.
+     **/
+    public String transform(String value) 
+	throws ParseException, ArithmeticException {
+	source.setValue(value);
+	if (factor == factor) 	// factor is not NaN, apply the factor
+	    target.setValue(source.value*factor/*+offset*/);
+	else 			// Apply the standard rules:
+	    Unit.convert(source, target);
+	return(target.editedValue());
+    }
+
+    /**
+     * Convert a value, return its edited form.
+     * Convert the value from <em>source</em> unit into <em>target</em> unit
+     * @param	value the value (expressed in source)
+     * @return	the corresponding edited value, expressed in 
+     * 		<em>target</em> units.
+     **/
+    public String transform(double value) throws ArithmeticException {
+	source.setValue(value);
+	if (factor == factor) 	// factor is not NaN, apply the factor
+	    target.setValue(value*factor/*+offset*/);
+	else 			// Apply the standard rules:
+	    Unit.convert(source, target);
+	return(target.editedValue());
+    }
+
+    /*==================================================================
+			Edition
+     *==================================================================*/
+
+     /**
+      * Standard edition of the unit converter
+     **/
+    public String toString() {
+	return(source.symbol+"=>"+target.symbol+"(x"+factor+")");
+    }
+	
+}
Index: aladin/cds/astro/Coo.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Coo.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,877 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro ;
+
+/*==================================================================
+                Coo class
+ *==================================================================*/
+
+import java.io.*;
+//import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * Class that manipulates the coordinates defining a point on the 
+ * celestial sphere.
+ * The class includes conversions between polar angles (lon,lat)
+ * expressed in degrees, and Cartesian 3-vectors.
+ * The typical way of converting between polar and cartesian is:
+ * <PRE>
+ * Coo aCoo = new Coo ; double u[] = new double[3] ;
+ * while (true) {
+ *     aCoo.set(stdin.readLine()) ;
+ *     System.out.println("Coordonnees   : " + aCoo) ;
+ *     u[0] = aCoo.x; u[1] = aCoo.y; u[2] = aCoo.z;
+ *     System.out.println("Cos. directeurs: " + Coo.toString(u)) ;
+ * }
+ * </PRE>
+ * This class also deals with 3x3 matrices.
+ * @author Pierre Fernique, Francois Ochsenbein [CDS]
+ * @version 1.0 : 03-Mar-2000<br>
+ * @version 1.1 : 24-Mar-2000: Bug in dist<br>
+ * @version 1.2 : 17-Apr-2002: Accept decimal degrees in scientific notation<br>
+ * @version 1.3 : 17-Sep-2002: Method "dist" between 2 coordinates<br>
+ * @version 1.4 : 21-Jan 2004 (BB): ajout de la methode equals.<br>
+ * @version 1.5 : 12-Aug 2004: methods rotate rotate_1
+ * 				dlon and dlat moved to Astrocoo
+ * @version 1.6 : 24-Apr-2006: methods moveMatrix
+ * @version 1.7 : 04-Jun-2006: methods add sub
+ * @version 1.8 : 02-Feb-2007: editingDecimals
+ */
+
+public class Coo implements Serializable, Cloneable {
+   /** Components of unit vector (direction cosines) */
+   public double x, y, z ;
+   /** Longitude in degrees, range [0, 360[ */
+   protected double lon;
+   /** Latitude in degrees, range [-90, +90]  */
+   protected double lat ;
+   /** Number of decimals on lon and lat -- reported to subclass */
+   // public byte dlon, dlat ;
+   /** Whether longitude part was in time units (Equatorial) */
+   // public boolean eq;
+
+   /** The edition of Coordinates */
+   static public Editing ed = new Editing("--");
+
+   /** Number of decimals edited in the default toString method.
+    * Can be changed with the setDecimals() method. */
+   static public int decimals = -10;
+   /** The unit 3-D unit matrix . */
+   static public double Umatrix3[][] = { 
+       { 1.0, 0.0, 0.0}, { 0.0, 1.0, 0.0}, { 0.0, 0.0, 1.0} };
+
+    //  ===========================================================
+    //		Constructors
+    //  ===========================================================
+
+    /**
+     * The basic contructor: undefined position
+     */
+    public Coo() {
+	this.set();
+    }
+
+    /**
+     * Define a coordinate from another one (clone).
+     * 	It is faster than the creation from the angles or vector
+     * 	because there is no conversion between angles and vectors.
+     * @param coo the coordinates to clone.
+     */
+    /* Useless -- better to use clone !
+    public Coo(Coo coo) {
+    	this.set(coo);
+    }
+    */
+
+    /**
+     * Define a coordinate from its angles
+     * @param lon longitude angle in degrees
+     * @param lat latitude angle in degrees
+     */
+    public Coo(double lon, double lat) {
+    	this.set(lon, lat);
+    }
+
+    /**
+     * Define a coordinate from its direction cosines.
+     * (Note that (x,y,z) doesn't need to have a norm=1)
+     * @param x x item in unit vector (direction cosines)
+     * @param y y item in unit vector (direction cosines)
+     * @param z z item in unit vector (direction cosines)
+     */
+    public Coo(double x, double y, double z) {
+    	this.set(x, y, z);
+    }
+
+    /**
+     * Define a coordinate from a string
+     * @param  text	a position as a string (decimal or sexagesimal)
+     * @param  equatorial     true when text represents equatorial coordinates
+     * 			(RA, if sexagesimal, is interpretated in time units)
+     * @throws ParseException when the string is not interpretable
+     */
+    /* --- Not useful -- remove
+    public Coo(String text, boolean equatorial) throws ParseException {
+    	this.set(text, equatorial);
+    }
+    */
+
+    /**
+     * Define a coordinate from a string
+     * @param  text	a position as a string
+     * @throws ParseException when the string is not interpretable
+     */
+    public Coo(String text) throws ParseException {
+    	this.set(text);
+    }
+
+    /**
+     * Clone the Coo object
+     */
+    public Object clone() {
+	Coo c = null;
+    	try {
+	    c = (Coo) super.clone();
+	} catch (CloneNotSupportedException e) {
+	    // should not happen
+	}
+	return c;
+    }
+
+    //  ===========================================================
+    //		Polar angles (lon,lat) <--> Cartesian
+    //  ===========================================================
+
+    /**
+     * Compute coordinates from x,y,z
+     */
+    private final void computeLonLat() {
+    	double r2 = x * x + y * y;
+    	lon = 0.0;
+    	if (r2 == 0.0) { /* in case of poles */
+    	    if (z == 0.0) {
+    	    	lon = 0./0.; lat = 0./0.;
+    	    }
+	    else
+    	    	lat = (z > 0.0) ? 90.0 : -90.0;
+    	}
+	else {
+    	    lon = AstroMath.atan2d(y, x);
+    	    lat = AstroMath.atan2d(z, Math.sqrt(r2));
+    	    if (lon < 0.0)
+    	    	lon += 360.0;
+    	}
+    }
+
+    /**
+     * Sets the position to its default (unknown)
+     */
+    public void set() {
+    	x = y = z = 0.;
+    	lon = 0./0.; lat = 0./0.;
+    }
+
+    /**
+     * Set the position from an existing one.
+     * 	It is faster than the set methods from angles or vector components
+     * 	because there is no conversion.
+     * @param coo the coordinates
+     */
+    public void set(Coo coo) {
+    	this.x = coo.x;
+    	this.y = coo.y;
+    	this.z = coo.z;
+	this.lon = coo.lon;
+	this.lat = coo.lat;
+    }
+
+    /**
+     * Compute the unit vector from angles in degrees.
+     * @param lon longitude in degrees
+     * @param lat latitude angle in degrees
+     * @param u   resulting unit vector
+     */
+    static public final void setUvec(double lon, double lat, double[] u) {
+    	u[0] = u[1] = AstroMath.cosd(lat);
+    	u[0] *= AstroMath.cosd(lon);
+    	u[1] *= AstroMath.sind(lon);
+    	u[2] = AstroMath.sind(lat);
+    }
+
+    /**
+     * Set a position from its longitude and latitude (RA/Dec).
+     * Convert (lon,lat) into its direction cosines (x,y,z)
+     * @param lon longitude in degrees
+     * @param lat latitude angle in degrees
+     */
+    public void set(double lon, double lat) {
+    	double coslat = AstroMath.cosd(lat);
+    	this.lon = lon; this.lat = lat;
+    	x = coslat * AstroMath.cosd(lon);
+    	y = coslat * AstroMath.sind(lon);
+    	z = AstroMath.sind(lat);
+    }
+
+    /**
+     * Set a position from its unit vectors.
+     * Revert conversion of (x,y,z) into (lon,lat).<br>
+     * (Note that (x,y,z) is assxumed to have a norm=1)
+     * @param x x item in unit vector (direction cosines)
+     * @param y y item in unit vector (direction cosines)
+     * @param z z item in unit vector (direction cosines)
+     */
+    public void set(double x, double y, double z) {
+    	this.x = x; this.y = y; this.z = z;
+	lon = lat = 0./0.;
+	computeLonLat();
+    }
+
+    //  ===========================================================
+    //		Interpret a string for Position
+    //  ===========================================================
+
+    //* REMOVED --- used only in Astrocoo
+    /**
+     * Compute the number of decimals.
+     * @param  nd   number of decimals
+     * @param  form the format
+    **/
+    /* ----------------
+    private static final int set_nd(int decimals, int form) {
+	int nd = decimals+1;
+	if (nd < 0) nd = 0;
+	if (nd >31) nd =31;
+	if (form >= Parsing.SEXA2) {
+	    nd += 2;
+	    if ((form&1)!=0) nd += 2;
+	    nd |= 128;		// Indicates SEXAgesimal
+	}
+	return(nd);
+    }
+    ----*/
+
+    /**
+     * Interpret the string and convert to Coo.
+     *               Called from set(...) and parse(...) methods
+     * @param  acoo	a text ready for parsing
+     *			(may contain the hms or '" characters)
+     * @return true if OK.
+     */
+    public boolean parsing (Parsing acoo) {
+      boolean f15 = false;
+	x = y = z = 0;		// Nothing found yet.
+	// Extract the longitude / RA
+	acoo.gobbleSpaces();
+	lon  = acoo.parseSexa();
+	if (acoo.inError()) return(false);
+	if (acoo.isTime()) f15 = true;
+	else if (acoo.isAngle()) f15 = false;
+	if (f15) lon *= 15.;	// { lon *= 15.; nd--; }
+	// Extract the Latitude / Declination
+	acoo.gobbleSpaces();
+	if (acoo.currentChar() == ',') { // Accept HEASARC way with a comma
+	    acoo.advance(1);
+	    acoo.gobbleSpaces();
+	}
+	lat  = acoo.parseSexa();
+	if (acoo.inError()) return(false);
+	// Both coordinates OK.
+	this.set(lon, lat);
+	return(true);
+     }
+
+    /**
+     * Interpret the string and convert to Coo.
+     * @param  text	a text containing 2 angles, in decimal or Sexagesimal
+     *			(may contain the hms or '" characters)
+     * @param  offset	where to start the analysis
+     * @return new position in text after interpretation.
+     */
+    public int parse(String text, int offset) {
+      	Parsing acoo = new Parsing(text, offset);
+	// Interpret, and in case of error return original offset
+      	return(parsing(acoo) ? acoo.pos : offset) ;
+     }
+
+    /**
+     * Define a coordinate from its angles.
+     *
+     * @param  text	a text containing 2 angles, in decimal or Sexagesimal
+     // @param  equatorial	true when text represents equatorial coordinates
+     //			(the RA in units of time)
+     * @throws ParseException when the tring is not interpretable
+     */
+    /*
+    public void set(String text, boolean equatorial)
+	   throws ParseException {
+      Parsing acoo = new Parsing(text);
+	if (!parsing(acoo, false)) throw new ParseException
+	    ("****Coo: component larger than 60 in: " + text, acoo.pos);
+    	// Error Check -- is there something left in the string ?
+	acoo.gobbleSpaces();
+	if (acoo.pos < acoo.length) throw new ParseException
+	    ("****Coo: '" + text + "'+" + acoo.pos, acoo.pos);
+    	set(lon, lat);
+    }
+    */
+
+    /**
+     * Define a non-equatorial coordinate from its text (RA is in degrees)
+     * @param  text	a text containing 2 angles, in decimal or Sexagesimal
+     * @throws ParseException when the string is not interpretable
+     */
+     public void set(String text) throws ParseException {
+      	Parsing acoo = new Parsing(text);
+	if (!parsing(acoo)) throw new ParseException
+	    ("****Coo: component larger than 60 in: " + text, acoo.pos);
+    	// Error Check -- is there something left in the string ?
+	acoo.gobbleSpaces();
+	if (acoo.pos < acoo.length) throw new ParseException
+	    ("****Coo: '" + text + "'+" + acoo.pos, acoo.pos);
+    	set(lon, lat);
+     }
+
+    /**
+     * Define equatorial coordinate for its angles (the RA in units of time)
+     * @param  text	a text containing 2 angles, in decimal or Sexagesimal
+     * @throws ParseException when the string is not interpretable
+     */
+     /* Not really useful
+     public void setEquatorial(String text) throws ParseException {
+    	 this.set(text) ;
+     }
+     */
+
+  //  ===========================================================
+  //		Get special components
+  //  ===========================================================
+
+  /**
+    * Get the Longitude (RA) in degrees.
+    * @return   the longitude (RA) in degrees
+   **/
+    public double getLon() {
+	if (Double.isNaN(lat)) computeLonLat();
+	return(lon);
+    }
+
+  /**
+    * Get the Latitude (Dec) in degrees.
+    * @return   the latitude (Dec) in degrees
+   **/
+    public double getLat() {
+	if (Double.isNaN(lat)) computeLonLat();
+	return(lat);
+    }
+
+  /**
+    * Get the spherical angles (lon, lat) as a 2-vector
+   **/
+    public void copyAngles(double[] o) {
+	if (Double.isNaN(lat)) computeLonLat();
+	o[0] = lon; o[1] = lat; 
+    }
+
+  /**
+    * Get the unit vector (x, y, z) as a 3-vector
+   **/
+    public void copyUvector(double[] u) {
+	u[0] = x; u[1] = y; u[2] = z;
+    }
+
+  //  ===========================================================
+  //		Spherical distance
+  //  ===========================================================
+
+  /**
+    * Distance between 2 points on the sphere.
+    * @param lon1 longitude of first point in degrees
+    * @param lat1 latitude of first point in degrees
+    * @param lon2 longitude of second point in degrees
+    * @param lat2 latitude of second point in degrees
+    * @return distance in degrees in range [0, 180]
+   **/
+    public static final double distance(double lon1, double lat1,
+                                  double lon2, double lat2) {
+      double c1 = AstroMath.cosd(lat1);
+      double c2 = AstroMath.cosd(lat2);
+      double w, r2;
+	w = c1 * AstroMath.cosd(lon1) - c2 * AstroMath.cosd(lon2);
+	r2 = w * w;
+	w = c1 * AstroMath.sind(lon1) - c2 * AstroMath.sind(lon2);
+	r2 += w * w;
+	w = AstroMath.sind(lat1) - AstroMath.sind(lat2);
+	r2 += w * w; // 4.sin^2(r/2)
+	return (2. * AstroMath.asind(0.5 * Math.sqrt(r2)));
+    }
+
+  /**
+    * Distance between 2 points on the sphere.
+    * @param  pos another position on the sphere
+    * @return distance in degrees in range [0, 180]
+   **/
+    public final double distance(Coo pos) {
+      	double w, r2;
+      	// Take care of NaN:
+    	if ((pos.x==0)&&(pos.y==0)&&(pos.z==0))
+	    return(0./0.);
+    	if ((this.x==0)&&(this.y==0)&&(this.z==0))
+	    return(0./0.);
+      	w = pos.x - x;
+      	r2 = w * w;
+      	w = pos.y - y;
+      	r2 += w * w;
+      	w = pos.z - z;
+      	r2 += w * w; // 4.sin^2(r/2)
+      	return (2. * AstroMath.asind(0.5 * Math.sqrt(r2)));
+    }
+
+    //  ===========================================================
+    //		Apply a rotation matrix
+    //  ===========================================================
+
+    /**
+     * Rotate a vector.
+     * The vector <b>v</b> becomes <b>R . v</b>
+     * @param R [3][3] Rotation Matrix
+     * @param v Vector to rotate, may be of dimension 3 or 6.
+     */
+    public static final void rotateVector(double[][] R, double[] v) {
+      int i; double x, y, z;
+        if (R == Umatrix3) return;
+        for (i=0; i<v.length; i+=3) {
+	    x = v[i]; y = v[i+1]; z = v[i+2];
+            v[i+0] = R[0][0]*x + R[0][1]*y + R[0][2]*z;
+            v[i+1] = R[1][0]*x + R[1][1]*y + R[1][2]*z;
+            v[i+2] = R[2][0]*x + R[2][1]*y + R[2][2]*z;
+	}
+    }
+
+    /**
+     * Reversely rotate a vector.
+     * The vector <b>v</b> becomes <b>R<sup>-1</sup> . v</b>
+     * @param R [3][3] Rotation Matrix
+     * @param v Vector to rotate, may be of dimension 3 or 6.
+     */
+    public static final void rotateVector_1(double[][] R, double[] v) {
+      int i; double x, y, z;
+        if (R == Umatrix3) return;
+        for (i=0; i<v.length; i+=3) {
+	    x = v[i]; y = v[i+1]; z = v[i+2];
+            v[i+0] = R[0][0]*x + R[1][0]*y + R[2][0]*z;
+            v[i+1] = R[0][1]*x + R[1][1]*y + R[2][1]*z;
+            v[i+2] = R[0][2]*x + R[1][2]*y + R[2][2]*z;
+	}
+    }
+
+    /**
+     * Rotate a coordinate (apply a rotation to the position).
+     * @param R [3][3] Rotation Matrix
+     */
+    public void rotate (double[][] R) {
+      double X, Y, Z;
+        if (R == Umatrix3) return;
+        X = R[0][0]*x + R[0][1]*y + R[0][2]*z;
+        Y = R[1][0]*x + R[1][1]*y + R[1][2]*z;
+        Z = R[2][0]*x + R[2][1]*y + R[2][2]*z;
+    	// this.set(X, Y, Z); Not necessary to compute positions each time.
+	x = X; y = Y; z = Z;
+	lon = lat = 0./0.;
+    }
+
+    /**
+     * Rotate a coordinate (apply a rotation to the position)
+     * 		in reverse direction.
+     * 	The method is the inverse of rotate.
+     * @param R [3][3] Rotation Matrix
+     */
+    public void rotate_1 (double[][] R) {
+      double X, Y, Z;
+        if (R == Umatrix3) return;
+        X = R[0][0]*x + R[1][0]*y + R[2][0]*z;
+        Y = R[0][1]*x + R[1][1]*y + R[2][1]*z;
+        Z = R[0][2]*x + R[1][2]*y + R[2][2]*z;
+    	// this.set(X, Y, Z); Not necessary to compute positions each time.
+	x = X; y = Y; z = Z;
+	lon = lat = 0./0.;
+    }
+
+   /** Generate the rotation matrix from the Euler angles
+    * @param z	Euler angle
+    * @param theta	Euler angle
+    * @param zeta	Euler angles
+    * @return R [3][3]		the rotation matrix
+    * The rotation matrix is defined by:<pre>
+    *    R =      R_z(-z)              R_y(theta)          R_z(-zeta)
+             |cos.z -sin.z  0|   |cos.the  0 -sin.the|   |cos.zet -sin.zet 0|
+	   = |sin.z  cos.z  0| x |   0     1     0   | x |sin.zet  cos.zet 0|
+	     |   0      0   1|   |sin.the  0  cos.the|   |   0        0    1|
+    * </pre>
+    */
+    public static double[][] eulerMatrix(double z, double theta, double zeta) {
+      double R[][] = new double[3][3];
+    	R[0][2] =  AstroMath.cosd(z);
+    	R[1][2] =  AstroMath.sind(z);
+    	R[2][2] =  AstroMath.cosd(theta);
+      double  w =  AstroMath.sind(theta) ;
+    	R[2][0] =  AstroMath.cosd(zeta);
+    	R[2][1] =  AstroMath.sind(zeta);
+    	R[0][0] =  R[2][0]*R[2][2]*R[0][2] - R[2][1]*R[1][2];
+    	R[1][0] =  R[2][0]*R[2][2]*R[1][2] + R[2][1]*R[0][2];
+    	R[0][1] = -R[2][1]*R[2][2]*R[0][2] - R[2][0]*R[1][2];
+    	R[1][1] = -R[2][1]*R[2][2]*R[1][2] + R[2][0]*R[0][2];
+    	R[2][0] =  R[2][0]*w;
+    	R[2][1] = -R[2][1]*w;
+    	R[0][2] = -w*R[0][2];
+    	R[1][2] = -w*R[1][2];
+	//* System.err.println("Compute tR . R ") ;
+	//* System.err.println(Coo.toString(Coo.prod(Coo.t(R), R))) ;
+      	return(R) ;
+    }
+
+    /**
+     * Compute the rotation matrix that transforms a direction
+     * into the local frame.
+     * The axises of the local frame are defined by:
+     *  <UL>
+     *  <LI>R[0] (first axis)  = unit vector towards Zenith
+     *  <LI>R[1] (second axis) = unit vector towards East
+     *  <LI>R[2] (third axis)  = unit vector towards North
+     *  </UL><PRE>
+     *  +-                             -+   +-                  -+
+     *  | cosb.cosl   cosb.sinl    sinb |   |  x        y      z |
+     *  |  -sinl        cosl        0   | = | (-y/r)   (x/r)   0 |
+     *  |-sinb.cosl  -sinb.sinl    cosb |   |-z(x/r)  z(-y/r)  r |
+     *  +-                             -+   +-                  -+
+     *  </PRE>
+     * r = sqrt(x*x+y*y) ; if r==0,take (x/r)=1, (y/r)=0
+     * @param lon  longitude of the center of local frame
+     * @param lat  latitude  of the center of local frame
+     * @return R[3][3] = Rotation Matrix  [(x,y,z)_local = R * (x,y,z)_global].
+     *     With the result matrix, <b>rotate(R)</b> converts the position 
+     *     to (0,0).
+     */
+    public static final double[][] localMatrix(double lon, double lat) {
+      double R[][] = new double[3][3];
+    	R[2][2] =   AstroMath.cosd(lat);
+    	R[0][2] =   AstroMath.sind(lat);
+    	R[1][1] =   AstroMath.cosd(lon);
+    	R[1][0] =  -AstroMath.sind(lon);
+    	R[1][2] =  0.0;
+    	R[0][0] =  R[2][2] * R[1][1];
+    	R[0][1] = -R[2][2] * R[1][0];
+    	R[2][0] = -R[0][2] * R[1][1];
+    	R[2][1] =  R[0][2] * R[1][0];
+    	return (R);
+    }
+
+    /**
+     * Compute the rotation matrix associated to current position.
+     * Simple mathematics R[0][i] = <b>I</b> (x y z)
+     *                    R[1][i] = <b>J</b> (u v 0) 
+     *                    R[2][i] = <b>K</b> (u v 0) 
+     * @param R = Rotation Matrix[3][3] to transform the current position 
+     * 			into (0,0)
+     */
+    public final void localMatrix(double[][] R) {
+      double r = Math.sqrt(x*x+y*y);
+    	R[0][0] =  x;  R[0][1] =  y;   R[0][2] =  z;
+	if (r == 0.) { R[1][0] = 0;    R[1][1] = 1.; }
+	else         { R[1][0] = -y/r; R[1][1] = x/r; }
+    	R[1][2] =  0.0;
+    	R[2][0] = -z * R[1][1];
+    	R[2][1] =  z * R[1][0];
+    	R[2][2] =  r;
+    }
+
+    /**
+     * Compute the rotation matrix associated to current position.
+     * @return R[3][3] = Rotation Matrix to transform the current position 
+     * 			into (0,0)
+     */
+    public final double[][] localMatrix() {
+        double R[][] = new double[3][3];
+        this.localMatrix(R);
+    	return (R);
+    }
+
+    /**
+     * Compute the rotation matrix to move between 2 directions.
+     *  		This matrix is coo.localMatrix  t(this.localMatrix) 
+     * @param  coo2  target direction.
+     * @return R[3][3] = Rotation Matrix to transform the current position 
+     * 			into the position given in argument
+     */
+    public final double[][] moveMatrix(Coo coo2) {
+      double R[][] = new double[3][3];
+      double R1[][] = this.localMatrix();
+      double R2[][] = coo2.localMatrix();
+      int i,j;
+
+        for (i=0; i<3; i++) for (j=0; j<3; j++) 
+	    R[i][j] = R2[0][i]*R1[0][j] 
+		    + R2[1][i]*R1[1][j] 
+		    + R2[2][i]*R1[2][j];
+    	return (R);
+    }
+
+    //  ===========================================================
+    //		Normalisation
+    //  ===========================================================
+
+    /**
+     * Normalisation of a vector (set its norm to 1)
+     * @param   u  3- or 6-Vector to normalize
+     * @return the norm of the 3-D vector
+     */
+    public static final double normalize(double[] u) {
+      double n = Math.sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
+      if (n>0) {
+          u[0] /= n; u[1] /= n; u[2] /= n; 
+          if (u.length > 3) {
+	      u[3] /= n; u[4] /= n; u[5] /= n;
+          }
+      }
+      return(n);
+    }
+
+    /**
+     * Normalisation of coordinates (set its norm to 1)
+     * @return the norm of the 3-D vector
+     */
+    public double normalize() {
+      double n = x*x + y*y + z*z;
+      if (n>0) {
+	  n = Math.sqrt(n);
+          x /= n; y /= n; z /= n; 
+      }
+      return(n);
+    }
+
+    //  ===========================================================
+    //		Addition / Subtraction of Coordinates
+    //  ===========================================================
+
+    /**
+     * Addition of a vector (addition, then normalisation)
+     * @param   u  3- or 6-Vector to modify
+     * @param  du  3-Vector to add
+     * @return the norm of the 3-D vector
+     */
+    public static final double add(double[] u, double[] du) {
+      u[0] += du[0]; u[1] += du[1]; u[2] += du[2];
+      return(normalize(u));
+    }
+
+    /**
+     * Subtraction of a vector (subtravtion, then normalisation)
+     * @param   u  3- or 6-Vector to modify
+     * @param  du  3-Vector to subtract
+     * @return the norm of the 3-D vector
+     */
+    public static final double sub(double[] u, double[] du) {
+      u[0] -= du[0]; u[1] -= du[1]; u[2] -= du[2]; 
+      return(normalize(u));
+    }
+
+    /**
+     * Addition of a vector (addition, then normalisation)
+     * @param  du  3-Vector to add
+     * @return the norm of the 3-D vector
+     */
+    public final double add(double[] du) {
+      x += du[0];  y += du[1];  z += du[2];
+      lon = 0./0.; lat = 0./0.;
+      return(normalize());
+    }
+
+    /**
+     * Subtraction of a vector (subtravtion, then normalisation)
+     * @param  du  3-Vector to subtract
+     * @return the norm of the 3-D vector
+     */
+    public final double sub(double[] du) {
+      x -= du[0]; y -= du[1];  z -= du[2];
+      lon = 0./0.; lat = 0./0.;
+      return(normalize());
+    }
+
+    //  ===========================================================
+    //		Comparison of 2 Coordinates.
+    //  ===========================================================
+
+    /**
+     * Test equality of Coo.
+     * @param o Object to compare
+     * @return  True if o is identical to Coo.
+     */
+    public boolean equals(Object o) {
+      boolean res = false;
+      	if(o instanceof Coo) {
+            Coo c = (Coo)o;
+            res = c.x == this.x && c.y == this.y && c.z == this.z;
+      	}
+      	return res;
+    }
+
+    //  ===========================================================
+    //		Editions of Angles, uvectors and Matrices
+    //  ===========================================================
+
+    /**
+     * Edition of the Coordinates with specified number of decimals.
+     * @param  b the StringBuffer for edition
+     * @param  nd the number of decimals in the edition of each coordinate.
+     * 		Possible to use a negative nd to minimize the length.
+     * @return  the StringBuffer
+     */
+    public final StringBuffer editCoo(StringBuffer b, int nd) {
+      int o = b.length();
+
+	//System.out.println("....editCoo("+lon+","+lat+") nd="+nd);
+
+        if (Double.isNaN(lat)) computeLonLat();
+
+	// We'll replace 360 by 0
+	ed.editDecimal(b, lon, 3, nd, Editing.ZERO_FILL);
+	//System.out.println("....editCoo(1): " + b);
+	if ((b.charAt(o) == '3') && (b.charAt(o+1) == '6')) {
+	    String pb = b.substring(o+2);
+	    b.setLength(o);
+	    b.append("00");
+	    b.append(pb);
+	}
+	ed.editDecimal(b, lat, 3, nd, Editing.ZERO_FILL|Editing.SIGN_EDIT);
+	return(b);
+    }
+
+    /**
+     * Default Edition of the Coordinates, as 2 numbers expressing
+     * the angles in degrees.
+     * @param  b the StringBuffer for edition
+     * @param  nd the number of decimals in the edition of each coordinate.
+     * 		Possible to use a negative nd to minimize the length.
+     * @return  the StringBuffer
+     */
+    public StringBuffer edit(StringBuffer b, int nd) {
+        return(editCoo(b, nd)) ;
+    }
+
+    /**
+     * Set (and get) the number of decimals for the default edition of the
+     * cordinates.
+     * @param  nd the number of decimals in the edition of each coordinate.
+     * 		Possible to use a negative nd to minimize the length.
+     * @return  the previous deifnition.
+     */
+    public static int setDecimals(int nd) {
+	int ret = decimals;
+	decimals = nd;
+	return(ret);
+    }
+
+    /**
+     * Default Edition of the Coordinates, as 2 numbers expressing
+     * the angles in degrees.
+     * @return The edited coordinates
+     */
+    public String toString() {
+      StringBuffer b = new StringBuffer();
+    	editCoo(b, decimals);
+    	return (b.toString()); // Buffer converted to String
+    }
+
+    /**
+     * Edition of the 3 components of a vector
+     * @param buf Stringbuffer to use for edition.
+     * @param u a vector to edit
+     * @param offset first element to edit.
+     */
+    private static final StringBuffer ed3(StringBuffer buf, 
+	    double u[], int offset) {
+    	ed.editDecimal(buf, u[offset+0], 2, 15, ed.SIGN_EDIT); buf.append(' ');
+    	ed.editDecimal(buf, u[offset+1], 2, 15, ed.SIGN_EDIT); buf.append(' ');
+    	ed.editDecimal(buf, u[offset+2], 2, 15, ed.SIGN_EDIT); 
+	return(buf);
+    }
+
+    /**
+     * Edition of the 3 components of a vector.
+     * @param	u the 3-vector
+     * @return	the equivalent string (edited vector)
+     */
+    protected static final String toString(double u[]) {
+    	return(toString("", u));
+    }
+
+    /**
+     * Edition of the 3 components of a vector.
+     * @param	title text prefixing each line.
+     * @param	u the 3-vector
+     * @return	the equivalent string (edited vector)
+     */
+    protected static final String toString(String title, double u[]) {
+      StringBuffer b = new StringBuffer(title);
+      int n = title.length();
+      int i, o;
+    	ed3(b, u, 0);
+	for (o=3; o < u.length; o += 3) {
+	    b.append('\n');
+	    for (i=0; i<n; i++) b.append(' ');
+	    ed3(b, u, o);
+	}
+    	return (b.toString()); // Buffer converted to String
+    }
+
+    /**
+     * Edition of a 3x3 matrix
+     * @param title text prefixing each line of the matrix
+     * @param m the 3x3 matrix
+     * @return	the equivalent string (edited matrix)
+     */
+    protected static final String toString(String title, double m[][]) {
+      StringBuffer b = new StringBuffer(title);
+      int n = title.length();
+      int i;
+        if (m == null)  b.append(" (3x3matrix)(nil)");
+	else {
+    	    ed3(b, m[0], 0); b.append('\n'); for(i=0; i<n; i++) b.append(' ');
+    	    ed3(b, m[1], 0); b.append('\n'); for(i=0; i<n; i++) b.append(' ');
+    	    ed3(b, m[2], 0);
+	}
+    	return (b.toString()); // Buffer converted to String
+    }
+
+    /**
+     * Dump the contents of a Coordinate
+     * @param title A title to precede the dump
+    **/
+     public void dump (String title) {
+      StringBuffer b = new StringBuffer(256);
+      int i = title.length();
+      	b.append(title); b.append("  "); this.editCoo(b, 12);
+	b.append("\n"); while (--i>=0) b.append(' ');
+    	ed.editDecimal(b, x, 2, 15, Editing.SIGN_EDIT); b.append(' ');
+    	ed.editDecimal(b, y, 2, 15, Editing.SIGN_EDIT); b.append(' ');
+    	ed.editDecimal(b, z, 2, 15, Editing.SIGN_EDIT);
+	System.out.println(b.toString());
+     }
+}
Index: aladin/cds/astro/Coocube.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Coocube.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,272 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro ;
+
+import java.io.*;
+import java.util.*;
+//import cds.astro.*;
+
+/**
+ * The routines provided in this module define a "coordinate" as
+ * a <em>face</em> number (between 1 and 6), and two <em>(X,Y)</em> values 
+ * in the range [-1,1[ representing the projection of a direction onto
+ * a cube. The <em>face</em> numbers, and the axis orientations, are:<BR>
+ * <PRE>
+ * <b>1 = +z</b> X=+y Y=-x &nbsp;(North Pole)
+ * <b>2 = +y</b> X=-z Y=-x &nbsp;(azimuth +90)
+ * <b>3 = +x</b> X=+y Y=+z &nbsp;(azimuth 0)
+ * <b>4 = -x</b> X=-z Y=-y &nbsp;(azimuth 180)
+ * <b>5 = -y</b> X=+x Y=+z &nbsp;(azimuth -90)
+ * <b>6 = -z</b> X=+x Y=-y &nbsp;(South Pole)
+ *           +---------+
+ *           |    ^    |
+ *           |    |x   |
+ *           |&lt;---+    |
+ *           |    1    |
+ * +---------+---------+---------+---------+
+ * |    ^    |    ^    |         |         |
+ * |    |    |    |    |         |         |
+ * |   5+---&gt;|  3 +---&gt;|   2+---&gt;|   4+---&gt;|
+ * |      x  |      x  |   x|    |   x|    |
+ * |         |         |    v    |    v    |
+ * +---------+---------+---------+---------+
+ *           |    ^    |
+ *           |    |x   |
+ *           |&lt;---+    |
+ *           |    6    |
+ *           +---------+
+ *
+ *</PRE>
+ * These coordinates can be used to address accurately a point with
+ * 2 floating-point numbers associated to a 3-bit face number
+ * <P>
+ * @author	Francois Ochsenbein
+ * @version 1.0	16-sep-2002
+**/ 
+
+public class Coocube extends Coo {
+
+  /** 
+   * The face number in range 1 to 6 -- zero for undefined. 
+  **/
+  public byte face;
+  /** 
+   * The position on the face, a number between -1 and 1.  
+  **/
+  public double X, Y;
+
+  /* Variables common to the Class: all Definitions */
+  /* Definitions of the directions of the (X,Y) axises on 
+     each face of the cube, with 
+     1=+z, 2=+y, 3=+x, 4=-x, 5=-y, 6=-z
+  */
+  static private final byte[] axis6 = {
+     0,2,6,2,6,3,3,0 ,		// 01..06 : Direction of X axis
+     0,4,4,1,5,1,5,0 ,		// 09..14 : Direction of Y axis
+     0,1,2,3,4,5,6,0 		// 17..22 : z = original direction
+  };
+  static private Editing edition = new Editing();
+
+ /*==================================================================*
+ 		Conversion (xyz) <--> (nXY)
+  *==================================================================*/
+
+  /** Compute the face number from the unit vector
+   * @param	u unit vector (vector of 3 direction cosines)
+   * @return	the face number in range 1..6 (0 if error)
+  **/
+    public static final int face(double u[]) {
+      int s[] = { 0, 1, 2 };
+      int n;
+	/* Sort the components of the unit vector to guess the face number */
+	if(u[1] < u[0])	{ s[0] = 1; s[1] = 0; }
+	if(u[2] < u[s[0]])	{ s[2] = s[0]; s[0] = 2; }
+	if(u[s[2]] < u[s[1]])	{ n = s[2]; s[2] = s[1]; s[1] = n; }
+	/* Derive the face number */
+	if(u[s[2]] > -u[s[0]]) n = 3^s[2];	// 0 1 2 ==> 3 2 1
+	else			n = 4^s[0];	// 0 1 2 ==> 4 5 6
+	// Special case when it's not a unit vector (minimum 1/sqrt(3) = 0.577)
+	if((u[s[0]] >= -0.577) && (u[s[2]] <= 0.577)) n=0;
+	return(n);
+    }
+
+  /** Compute the (face, X, Y)
+   * @param	u the Direction Cosines
+   * @param	XY the (X,Y) components 
+   * @return	the face number in range 1..6 (0 if error)
+  **/
+    public static final int setXY(double[] u, double [] XY) {
+      int face = face(u) ;
+      double z;
+      int n;
+	/* Component perpendicular to a face number (z) is
+	    3^face    for faces 1,2,3	(gives z,y,x)
+	   -4^face    for faces 4,5,6	(gives -x,-y,-z)
+	*/
+	z = (face&4) == 0 ? u[3^face] : -u[4^face];	// Denominator
+	if (z < 0.577)	{				// ERROR, not normal !!
+	    XY[0] = XY[1] = 0;
+	    return(0);
+	}
+	n     = axis6[face];  
+	XY[0] = (n&4) == 0 ? u[3^n] : -u[4^n];	// X-axis
+	n     = axis6[8|face];  
+	XY[1] = (n&4) == 0 ? u[3^n] : -u[4^n];	// Y-axis
+	XY[0] /= z;
+	XY[1] /= z;
+	return(face);
+    }
+  
+   /** Transformation (face + Projections) --&gt; unit vector
+    * @param face the face number (1 to 6)
+    * @param	X X value of the projection on the face n
+    * @param	Y Y value of the projection on the face n
+    * @param	u the unit vector (modified)
+    * @return	the face number
+   **/
+    public static final int setUvec(int face, double X, double Y, double[] u) {
+      double factor;
+      int n;
+
+	if ((face<1) || (face>6)) { u[0] = u[1] = u[2] = 0; return(0); }
+
+	/* Compute Factor to convert Projections into Direction Cosines */
+	factor = 1./Math.sqrt(1. + X*X + Y*Y) ;
+	n = face;
+	if ((n&4) == 0) u[3^n] =  factor;
+	else            u[4^n] = -factor;
+
+	/* Compute the Direction Cosine from X */
+	n = axis6[face];
+	if ((n&4) == 0) u[3^n] =  X * factor;
+	else            u[4^n] = -X * factor;
+
+	/* Compute the Direction Cosine from Y */
+	n = axis6[8|face];
+	if ((n&4) == 0) u[3^n] =  Y * factor;
+	else            u[4^n] = -Y * factor;
+
+	return(face);
+    }
+
+
+ /*==================================================================*
+ 			Assign the Coocube
+  *==================================================================*/
+
+  /** Compute the Coocube coordinates from the Direction Cosines
+   * @param	u the Direction Cosines
+   * @return	the face number in range 1..6 (0 if error)
+  **/
+    public final void set(double[] u) {
+      double[] XY = new double[2];
+	super.set(u[0], u[1], u[2]);
+	face = (byte)setXY(u, XY);
+	X = XY[0]; Y = XY[1];
+    }
+
+  /** Compute the Coocube coordinates
+   * @param	coo coordinates of a point
+   * @return	the face number in range 1..6 (0 if error)
+  **/
+    public final void set(Coo coo) {
+      double[] u = { coo.x, coo.y, coo.z };
+      	set(u);
+    }
+
+  /** Compute the Coocube from its (XY) components
+   * @param 	face the face number between 1 and 6
+   *		face is set to 0 in case of error.
+   * @param 	X  x position on the face
+   * @param		Y  y position on the face
+   * @return	the face number in range 1..6 (0 if error)
+  **/
+    public final void set(int face, double X, double Y) {
+      double[] u = new double[3];
+      	if ((face < 1) || (face > 6)) 
+	     u[0] = u[1] = u[2] = 0;
+	else setUvec (face, X, Y, u);
+	set(u);
+    }
+
+ /*==================================================================*
+ 			Constructors
+  *==================================================================*/
+
+  /** 
+   * Define the default undefined Coocube 
+  **/
+    public Coocube() {
+        face = 0;
+        X = 0; Y = 0;
+    }
+
+  /** 
+   * Define the Coocube from a Coordinate
+  **/
+    public Coocube(Coo coo) {
+        this.set(coo);
+    }
+
+  /** 
+   * Define the Coocube from its components
+   * @param 	face the face number between 1 and 6
+   *		face is set to 0 in case of error.
+   * @param 	X  x position on the face
+   * @param 	Y  y position on the face
+  **/
+    public Coocube(int face, double X, double Y) {
+        this.set(face, X, Y);
+    }
+
+ /*==================================================================*
+ 			Edition
+  *==================================================================*/
+
+  /** 
+   * Edit the Coocube value as <tt>f:&plusmn;X&plusmn;Y</tt>
+   * @param	buf buffer for the edition
+   * @param	ndec number of decimals for edition 
+   *		(a value of 6 corresponds to an accuracy of 0.3arcsec)
+   * @return	the face number in range 1..6 (0 if error)
+  **/
+    public StringBuffer edit(StringBuffer buf, int ndec) {
+	buf.append(face);
+	buf.append(":");
+	if (face == 0) return(buf);
+	edition.editDecimal(buf, X, 2, ndec, Editing.SIGN_EDIT);
+	edition.editDecimal(buf, Y, 2, ndec, Editing.SIGN_EDIT);
+	return(buf);
+    }
+
+  /** 
+   * Default Edition of the Coocube values
+   * @return	the string equivalent of the Coocube
+   * the angles in degrees.
+  **/
+    public String toString() {
+      StringBuffer b = new StringBuffer(20) ;
+	edit(b, 6);
+	b.append("(");
+	super.edit(b, 4);	// 4 decimals corespond to 0.3arcsec
+	b.append(")");
+     	return(b.toString());	// Buffer converted to String
+    }
+}
Index: aladin/cds/astro/Ecliptic.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Ecliptic.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,119 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                Class Ecliptic
+ *==================================================================*/
+
+import java.util.*;
+import java.text.*;		// for parseException
+
+/**
+ * The ecliptic frame is defined such that the Sun has a latitude = 0.
+ * Since the obliquity of the Earth's axis is slightly changing with
+ * time, the relation between the Equatorial and Ecliptic frames
+ * vary with time.
+ *  
+ *  The J2000 value of the obliquity is in Hipparcos vol. 1, table 1.1.2
+ *  The fomulae used here refer to Earth Ephemeris VSOP 82/ELP 2000
+ *
+ * @author Francois Ochsenbein (CDS)
+ *
+ */
+
+public class Ecliptic extends Astroframe {
+    /** The ecliptic frame is tightly connected to the Equatorial frame. */
+    protected double equinox ;		// also base_epoch
+    protected double fromJ2000[][];	// Rotation matrix FK5 -> ecliptic
+    //TODO: add conversion to B1950 ?
+
+   /**
+    * Compute the matrix to move from this ecliptic frame to FK5/J2000 (ICRS)
+    * @param equinox the equinox of definition (in Julian year)
+   **/
+   private static double[][] Jmatrix(double equinox) {
+      double eps, dt;
+      double R[][] = new double[3][3];
+      	dt = (equinox-2000.)/100.;	// In Julian centuries
+	// Compute mean obliquity in arcec:
+	eps = (84381.448 + (-46.8150 + (-0.00059+0.001813*dt)*dt)*dt);
+	eps /= 3600.;			// obliquity in degrees
+	R[0][0] = 1.;
+	R[0][1] = 0.;
+	R[0][2] = 0.;
+	R[1][0] = 0.;
+	R[2][0] = 0.;
+	R[1][1] = AstroMath.cosd(eps);	// J2000 = 0.9174820620691818
+	R[1][2] = AstroMath.sind(eps);	// J2000 = 0.3977771559319137
+	R[2][1] = -R[1][2];		// J2000 =-0.3977771559319137
+	R[2][2] =  R[1][1];		// J2000 = 0.9174820620691818
+	if (equinox != 2000.) 		// Combine with precession
+	    R = AstroMath.m3p(R, FK5.precessionMatrix(2000., equinox));
+ 	return(R);
+   }
+
+   /**
+    * Install the matrices for the conversion
+   **/
+   private final void setJmatrix() {
+       fromJ2000 = Jmatrix(this.equinox);
+       ICRSmatrix = AstroMath.m3t(fromJ2000);
+   }
+
+   // ===========================================================
+   // 			Constructor
+   // ===========================================================
+
+   /**
+    * Instanciate an Ecliptic frame.
+    * For non-standard default epoch, use setFrameEpoch() method.
+    * @param equinox the equinox of definition, in Julian Year.
+   **/
+    public Ecliptic(double equinox) {
+    	this.precision = 8;	// Intrinsic precision = 0.01arcsec
+	this.equinox = equinox;
+	this.epoch = equinox;
+	fromJ2000 = null;
+	name = "Ecl(J" + equinox + ")";
+    }
+
+   /**
+    * Instanciate an Ecliptic frame (at default J2000 equinox)
+   **/
+    public Ecliptic() {
+	this(2000.);
+    }
+
+   /**
+    * Defines the rotation matrix to rotate to ICRS
+    * @return the 3x3 rotation matrix to convert a position to ICRS frame
+   **/
+    public double[][] toICRSmatrix() {
+	if (ICRSmatrix == null) setJmatrix();
+	return(ICRSmatrix);
+    }
+
+   // ===========================================================
+   // 			Convert To/From ICRS
+   // ===========================================================
+
+   // Defaults are OK.
+}
Index: aladin/cds/astro/Editing.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Editing.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,991 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro ;
+
+/*==================================================================
+                Editing class (for nice editions)
+ *==================================================================*/
+
+//import java.io.*;
+//import java.util.*;
+
+/**
+ * Class for 'nice' edition of numbers. 
+ * This class contains options for the edition of integer / float numbers;
+ * the edited value is appended to the StringBuffer generally specified
+ * as the first argument. <br>
+ * This class is used in the various astronomical editions.
+ * @author Francois Ochsenbein [CDS]
+ * @version 1.0 : 03-Mar-2004
+ * @version 1.1 : 03-Mar-2005 (bug in sexagesimal edition DD.d)
+ * @version 1.2 : 03-Apr-2006 (bug in Double edition between 0.1 and 1;
+ * 				addition of editFlags)
+ * @version 1.3 : 03-Sep-2006 Added editDate
+ */
+
+public class Editing extends Astroformat {
+
+    /** How the NULL (NaN) is represented is defined in parent class */
+    // public String null_string;  -- is nulls[0]
+    /** How the Infinite is represented -- default is Inf */
+    public String inf_string;
+
+    /** 
+     * Option for edition follow the same conventions as Parsing,
+     * which are defined in Astroformat.
+     **/
+
+    /** Debugging option */
+    public static boolean DEBUG = false;
+    // List of symbols used to edit sexagesimal
+    static private char sexachar [] = {
+	Character.MIN_VALUE, 	// 0 
+	' ',			// 1 = blank
+	':', 			// 2 = colon
+	'h',			// 3 = hour
+	'm',			// 4 = min
+	's',			// 5 = sec
+	'd',			// 6 = deg
+	'\u00B0',		// 7 = {deg}
+	'\'',			// 8 = arcmin
+	'"',			// 9 = arcsec
+    };
+
+    // Factors of Y M D h m s to move to the next
+    static private double fac6 [] = {
+	12., 30., 
+	24., 	/* day -> hr */
+	60., 60. };
+
+    // How to edit the sexagesimal. 
+    // For each option, this array specifies 4 hexa digits:
+    // #1 = number of components-1 (0, 1, or 2)
+    // Other = index in sexachar of the symbol that follows the component
+    static private short sexadrive[] = {
+	0x0000, 	// 0 = DECIMAL -- edited in editDouble
+	0x0000,		// 1 = EFORMAT -- edited in editDouble
+	0x1100, 	// 2 = SEXA2   -- hh mm
+	0x2110,		// 3 = SEXA3   -- hh mm ss
+	0x1200,		// 4 = SEXA2c  -- hh:mm
+	0x2220,		// 5 = SEXA3c  -- hh:mm:ss
+	0x1640,		// 6 = SEXA2d
+	0x2645,		// 7 = SEXA3d  -- d m s separator
+	0x1640,		// 8 = SEXA2h
+	0x2345,		// 9 = SEXA3h  -- h m s separator
+	0x0000,		//10 = FACTOR  -- not sexa
+	0x0600,		//11 = SEXA1d  -- a single number followed by d
+	0x0300,		//12 = SEXA1h  -- a single number followed by h
+	0x0700,		//13 = SEXA1o  -- a single number followed by &deg;
+	0x1780,		//14 = SEXA2o  -- 2 components &deg; '
+	0x2789,		//15 = SEXA3o  -- 3 components &deg; ' "
+    };
+    // Edition of date: 1=yr 2=Mon 3=MonNum 4=Day 5=Yday
+    //            a=add- b=addBlank c=add, d=add/
+    static private int datedrive[] = {
+	0x1a2,		//  0 = "date(Y-M)",   
+	0x13,		//  1 = "date(Ymon)",  
+	0x2a1,		//  2 = "date(MY)",  
+	0x31,		//  3 = "date(monY)",
+	0x1a5,		//  4 = "date(YD)",   
+	0x1a5,		//  5 = "#mjd-5#",     
+	0x5d1,		//  6 = "date(DY)",  
+	0x5d1,		//  7 = "#mjd-7#",   
+	0x1a2a4,	//  8 = "date(YMD)",  
+	0x1a3a4,	//  9 = "date(YmonD)", 
+	0x4d2d1,	// 10 = "date(DMY)", 
+	0x4a3a1,	// 11 = "date(DmonY)",
+	0x2d4c1,	// 12 = "date(MDY)",  
+	0x3a4c1,	// 13 = "date(monDY)", 
+	0x2d1a4,	// 14 = "date(MYD)", 
+	0x3d1a4,	// 15 = "date(monYD)",
+    };
+    static private char datesep[] = { '-', ' ', ',', '/' };
+
+    /**
+     * The basic constructor: default NaN edition is "-".
+    **/
+    public Editing() {
+	// buf = new StringBuffer();
+	super();
+	inf_string  = "Inf";
+    }
+
+    /**
+     * Constructor specifying the NaN representation, and default options.
+     * @param null_text what to write in case of NULL (NaN) value.
+    **/
+    public Editing(String null_text) {
+	// buf = new StringBuffer();
+	setNaN(null_text);
+	inf_string  = "Inf";
+    }
+
+    /**
+     * Define the NaN representation.
+     * @param text the choice for NULL (NaN) representation.
+     * ---- Method inherited from parent class (Astroformat)
+    public void setNaN(String text) {
+	null_string = text;
+    }
+    **/
+
+    /**
+     * Define the Infinite representation
+     * @param text the choice for Infinity
+    **/
+    public void setInfinite(String text) {
+	inf_string = text;
+    }
+
+   /**
+    * Internal edition of the sign and value of an integer number.
+    * Used to ensure the right alignment.
+    * @param  buf   the buffer to which the string representation is appended
+    * @param  value the (positive) number to edit
+    * @param  width the total width
+    * @param  option  a mixture of options like 
+    *  {@link Astroformat#ZERO_FILL},
+    *  {@link Astroformat#SIGN_EDIT}, ...
+    */
+   private static void edN(StringBuffer buf, long value, int width, int opt) {
+      char asig = Character.MIN_VALUE;
+      String aval = Long.toString(value);	// Number in character.
+      int  nb = width - aval.length();		// Number of blanks
+      	if ((opt&(SIGN_EDIT|0x80000000)) != 0) {
+      	    if ((opt&0x80000000) != 0) asig = '-'; 
+	    else asig = '+';
+	    nb--;
+	}
+	if ((opt&ZERO_FILL)!=0) {
+	    if (asig != Character.MIN_VALUE) buf.append(asig); 
+	    while (nb>0) { buf.append('0'); nb--; }
+	}
+	else {
+	    while (nb>0) { buf.append(' '); nb--; }
+	    if (asig != Character.MIN_VALUE) buf.append(asig);
+	}
+	buf.append(aval);
+   }
+
+   /**
+    * Internal method to remove the useless decimals
+    * @param  buf   the buffer -- remove ending zeroes until '.'
+    * @return a boolean: true if decimal point removed.
+    */
+   private static boolean remove_zeroes(StringBuffer buf) {
+      int i;
+      boolean removed_point = false;
+	for (i = buf.length()-1; buf.charAt(i) == '0'; i--) ;
+	if (buf.charAt(i) == '.') removed_point = true; else ++i;
+	buf.setLength(i);
+	return(removed_point);
+   }
+
+   /**
+    * Edit a number considered as a set of bits.
+    * The bits set are edited from a table; list separated with commas.
+    * @param  buf   the buffer to which the flags are appended
+    * @param  flags    the list of flags.
+    * @param  symbols  the table of symbols
+    */
+   public StringBuffer editFlags(StringBuffer buf, int flags, String symbols[])
+   {
+      int i, j;
+      int n=symbols.length;
+      	for (i=j=0; i<n; i++) {
+	    if ((flags&(1<<i)) == 0) continue;
+	    if(j>0) buf.append(',');
+	    buf.append(symbols[i]);
+	    j++;
+	}
+	return buf;
+   }
+
+   /**
+    * Assignment to NaN represention.
+    * Just appends the NULL string representation, right-aligned.
+    * @param  buf   the buffer to which the string representation is appended
+    * @param  width the total width
+    */
+    public StringBuffer editNaN(StringBuffer buf, int width) {
+      	for (int nb = width - nulls[0].length(); nb>0; nb--)
+	    buf.append(' ');
+	buf.append(nulls[0]);
+	return buf;
+    }
+
+   /**
+    * Assignment to Infinity represention, right-aligned.
+    * Just appends the Infinite string representation, right-aligned.
+    * @param  buf   the buffer to which the string representation is appended
+    * @param  width the total width
+    * @param  sign  positive(add +sign), negative(add -sign), or zero.
+    */
+   public StringBuffer editInfinite(StringBuffer buf, int width, int sign) {
+      	int nb = width - inf_string.length(); 
+	if (sign != 0) nb--;
+	while (--nb>=0) buf.append(' ');
+	if (sign<0) buf.append('-');
+	else if (sign != 0) buf.append('+');
+	buf.append(inf_string);
+	return buf;
+   }
+
+   /**
+    * Edition of a long integer number, right-aligned, with user-specified 
+    * options.
+    * A long having the MIN_VALUE (0x8000000000000000L) is considered as NaN.
+    * A long having &pm;MAX_VALUE (0x7fffffffffffffffL) is considered as Infty
+    * @param  buf   the buffer to which the string representation is appended
+    * @param  value the number to edit
+    * @param  width the total width
+    * @param  option  a mixture of options like 
+    *  {@link Astroformat#ZERO_FILL},
+    *  {@link Astroformat#SIGN_EDIT}, ...
+    * @return the edited buffer
+    */
+   public StringBuffer editLong(StringBuffer buf, long value, int width, 
+		   int option) {
+      int o = option;
+      long val = value;
+    	if (val == Long.MIN_VALUE) this.editNaN(buf, width);
+	else {
+      	    if (val < 0) { o |= 0x80000000; val = -val; }
+	    if (val == Long.MAX_VALUE) 
+		this.editInfinite(buf, width, o&(0x80000000|SIGN_EDIT));
+	    else edN(buf, val, width, o);
+	}
+	return buf;
+   }
+
+   /**
+    * Edition of an integer number, right-aligned, with user-specified options.
+    * An integer having the MIN_VALUE (0x80000000) is considered as NaN.
+    * An integer having &pm;MAX_VALUE (0x7fffffff) is considered as Infty.
+    * @param  buf   the buffer to which the string representation is appended
+    * @param  value the number to edit
+    * @param  width the total width
+    * @param  option  a mixture of options like 
+    *  {@link Astroformat#ZERO_FILL},
+    *  {@link Astroformat#SIGN_EDIT}, ...
+    * @return the edited buffer
+    */
+   public StringBuffer editInt(StringBuffer buf, int value, int width, 
+		   int option) {
+      int o = option;
+      long val = value;
+    	if (value == Integer.MIN_VALUE) this.editNaN(buf, width);
+	else {
+      	    if (value < 0) { o |= 0x80000000; val = -val; }
+	    if (val == Integer.MAX_VALUE) 
+		this.editInfinite(buf, width, o&(0x80000000|SIGN_EDIT));
+	    edN(buf, val, width, o);
+	}
+	return buf;
+   }
+
+   /**
+    * Edition of an integer number, right-aligned, with default options.
+    * An integer having the MIN_VALUE (0x80000000) is considered as NaN.
+    * @param  buf   the buffer to which the string representation is appended
+    * @param  value the number to edit
+    * @param  width the total width
+    * @return the edited buffer
+    */
+   public StringBuffer edit(StringBuffer buf, int value, int width) {
+	this.editInt(buf, value, width, 0);
+	return(buf);
+   }
+
+   /**
+    * Edition of a single floating-point number (%f).
+    * The width of the edited number is nint+nd+1
+    * The number is truncated when the option includes TRUNCATE;
+    * it is rounded by default.<br>
+    * Negative number of decimals <b>nd</b> follow the following conventions:
+    * <UL>
+    * <li><b>0</b>: no decimal, but the decimal point is edited 
+    *              (e.g. 1.0 is edited "<tt>1.</tt>")
+    * <li><b>-1</b>: the decimal point is not edited 
+    *              (e.g. 1.0 is edited "<tt>1</tt>")
+    * <li><b>&lt;-1</b>: the number is edited with <b>|nd|</b> decimals,
+    * 		but useless decimals are removed. For nd=-3, the
+    * 		number 1.123456 is edited "<tt>1.123</tt>",
+    * 		but 1.200 will be edited "<tt>1.2</tt>"
+    * </UL>
+    * @param  buf   the buffer to which the string representation is appended
+    * @param  value the number to edit
+    * @param  nint  the number of characters for the integer part.
+    * 		If <em>nint==0</em> a value in range ]0..1[ starts by a 
+    * 		decimal point (e.g. <tt>.123</tt>)
+    * @param  nd    the number of decimals -- use -1 to remove the decimal point
+    *               -2 to -15 to remove the non-significant zeroes.
+    * @param  option a combination of 
+    *  {@link Astroformat#ZERO_FILL} /
+    *  {@link Astroformat#SIGN_EDIT} /
+    *  {@link Astroformat#TRUNCATE}
+    * @return the editing buffer.
+    */
+   public StringBuffer editDecimal(StringBuffer buf, double value, 
+ 	  int nint, int nd, int option) {
+      boolean shortest_form = nd < -1;
+      	/*
+      	if (DEBUG) System.out.println("....editDecimal(" + value +") nint=" 
+	      + nint +", nd=" + nd);
+	*/
+      double val = value ;
+      int o = option;
+      long int_part ;
+      int n;
+        if (shortest_form) nd = -nd;
+    	if (Double.isNaN(value)) {
+	    // Edit the NaN representation such that the last char is aligned
+	    // with the decimal point.
+	    n = nint; if (nd>=0) n++;
+	    this.editNaN(buf, n);
+    	    return buf;
+	}
+      	if (value < 0) { o |= 0x80000000; val = -val; }
+	if (Double.isInfinite(val)) {
+	    // Edit the Infinity representation aligned to the decimal point.
+	    n = nint; if (nd>=0) n++;
+	    this.editInfinite(buf, n, o&(0x80000000|SIGN_EDIT));
+    	    return buf;
+	}
+	if (val >= 1.e19)	// Can't edit such a number !
+	    return this.editDouble(buf, value, 2, nint+nd-3, option);
+	/* Verify a date, or a sexagesimal ?? */
+	if ((option&DATE)!=0) {
+	    int_part = (int)value;
+	    if (value<0) int_part--;
+	    return (this.editDate(buf, (int)int_part, option));
+	}
+	/* Verify a Sexagesimal edition ? */
+        if (sexadrive[option&15] != 0)	// Option corresponds to sexagesimal...
+	    return editSexa(buf, value, nint, nd, option);
+	/* Round the number if asked */
+	if ((option&TRUNCATE) == 0) {
+	    if (nd <= 0) val += 0.5;
+	    else val += 0.5/AstroMath.dexp(nd);
+	}
+	//System.out.println("....editDecimal("+value+") nd="+nd);
+    	int_part = (long) val; 
+    
+    	// Edit the integer part -- take care of nint=0
+	if ((nint>0) || (int_part!=0))
+	    edN(buf, int_part, nint, o);
+    
+    	// Add now the decimals
+    	if (nd >= 0)
+    	     buf.append('.');
+	if (nd > 0) {
+	    val -= int_part;
+	    //System.out.print("....editFract("+val+",nd="+nd+") =>");
+    	    val *= AstroMath.dexp(nd);
+	    //System.out.println(val);
+    	    int_part = (long) val; 
+	    //System.out.println(" => ="+int_part);
+	    edN(buf, int_part, nd, ZERO_FILL);
+	    if (shortest_form) {	// Remove the decimals, keep just 1
+		if (remove_zeroes(buf))	// ... but decimal point MUST be there
+		    buf.append(".0");
+	    }
+    	}
+    
+    	// Finally, return.
+    	return (buf);
+   }
+
+   /**
+    * Edition of a single floating-point number (%g or %e).
+    * The standard edition is decimal in range [0.1, 1000[, E-format otherwise.
+    * The %e format can be forced with the EFORMAT option.<br>
+    * Remark: the number is truncated (instead of the default rounding)
+    * if the TRUNCATE option is specified.<br>
+    * The total width used for the edition is 3+ndig+nexp or 5+ndig+nexp
+    * depending on the FACTOR option.
+    * @param  buf   buffer to which the string representation is appended
+    * @param  value number to edit
+    * @param  ndig  number of significant digits (do the best if ndig<=0)
+    * @param  nexp  number of characters for the exponent value (3 recommended)
+    * @param  option a combination of {@link Astroformat#EFORMAT} 
+    * / {@link Astroformat#SIGN_EDIT}
+    * @return the editing buffer.
+    */
+   public StringBuffer editDouble(StringBuffer buf, double value, int ndig, 
+		   int nexp, int option) {
+      String expo = (option&FACTOR)!=0 ? "x10" : "e";
+      int o = option;
+      int posini = buf.length();
+      double val = value ;
+      boolean shortest_form = ndig <= 0;
+      boolean decimal_form;
+      double f;
+      int e, n;
+        if (sexadrive[option&15] != 0)	// Option corresponds to sexagesimal...
+	    return editSexa(buf, value, ndig ,nexp, option);
+    	if (Double.isNaN(value) || Double.isInfinite(value)) {
+	    // Edit the special values
+    	    return editDecimal(buf, value, ndig+2, expo.length(), option);
+	}
+	if (shortest_form) ndig = 15;
+	if (value < 0) { o |= 0x80000000; val = -val; }
+	decimal_form = (option&EFORMAT)==0;
+	if (decimal_form) {
+	    if (val == 0.) ;
+	    else decimal_form = (val>=0.1) && (val<1000.) ;
+	}
+	if (decimal_form) {
+	    n = 2;
+	    if (val >=  10.) n++;
+	    if (val >= 100.) n++;
+	    this.editDecimal(buf, value, shortest_form ? 1 : n, ndig-n+1, 
+		option);
+	    if (shortest_form) remove_zeroes(buf);
+	    else for (n=expo.length()+nexp; n>0; n--) buf.append(' ');
+	    return buf;
+	}
+	/* Find the exponent n from IEEE format such that:
+	   10^n <= val < 10^(n+1) 
+	   i.e. normalize the number in range 1 .. 10
+	*/
+	e = (int)(Double.doubleToLongBits(val) >> 52) - 0x3ff;  // Expo base 2
+	e = (e*3)/10;		// Approximative exponent in base 10
+	f = AstroMath.dexp(e);
+	while (val < f)      f = AstroMath.dexp(--e);
+	while (val >= 10.*f) f = AstroMath.dexp(++e);
+	val /= f;		// Value in range [1, 10[
+	/* Round the Value */
+	if (((option&TRUNCATE) == 0) && (ndig>0)) {
+	    val += 5./AstroMath.dexp(ndig);
+	    //System.out.println("....editDouble("+value+",ndig="+ndig
+	    //  +") truncated="+val);
+	    if (val>=10.) { f/=10; ++e; }
+	}
+	this.editDecimal(buf, val, shortest_form ? 1 : 2, ndig-1, 
+	    (o&(~ZERO_FILL))|TRUNCATE);
+	if (shortest_form && remove_zeroes(buf)) {	// decimal point removed
+	    /* In EFORMAT, 1E10 would not be acceptable for 1.E+10;
+	     * and in FACTOR format, avoid 1x10+5, prefer 10+5
+	     */
+	    if ((option&FACTOR) == 0) buf.append('.');
+	    else if ((buf.length() == 1+posini) && (buf.charAt(posini) == '1')){
+		buf.setLength(posini);
+		expo = "10";
+	    }
+	}
+	buf.append(expo);
+	this.editInt(buf, e, nexp, ZERO_FILL|SIGN_EDIT);
+    
+    	// Finally, return.
+    	return (buf);
+   }
+
+   /**
+    * Edition of a single floating-point number (%g or %e).
+    * The standard edition is decimal in range [0.1, 1000[, E-format otherwise.
+    * Edits in the best possible way.
+    * @param  buf   buffer to which the string representation is appended
+    * @param  value number to edit
+    * @param  option a combination of {@link Astroformat#EFORMAT} 
+    * / {@link Astroformat#SIGN_EDIT}
+    * @return the editing buffer.
+    */
+   public StringBuffer editDouble(StringBuffer buf, double value, int option) {
+      return(editDouble(buf, value, 0, 0, option));
+   }
+
+   /**
+    * Edition of a single floating-point number in Sexagesimal.
+    * Remark: the number is truncated -- not rounded.
+    * @param  buf   buffer to which the string representation is appended
+    * @param  value number to edit
+    * @param  nint  number of characters for the integer part (degrees)
+    * @param  ndec  number of 'decimals' (2=arcmin, 4=arcsec, ...)
+    * 			use a negative number to specify the "maximal"
+    * 			number of decimals.
+    * @param  option a combination of 
+    *   {@link Astroformat#SEXA1d} (and other SEXAxx possibilities) / 
+    *   {@link Astroformat#ZERO_FILL} / 
+    *   {@link Astroformat#SIGN_EDIT} ...
+    * @return the editing buffer.
+    */
+   public StringBuffer editSexa(StringBuffer buf, double value, 
+		   int nint, int ndec, int option) {
+      int o = option;
+      int nd = Math.abs(ndec);
+      boolean remove_zeroes = ndec<0;
+      short form = (short)(option&15);	// One of the values SEXA3, SEXA2, ...
+      double val = value ;
+      double f;
+      long part;
+      int n;
+      char sep;
+        if (form == 0) form = SEXA3c;	// Default with colons
+    	if (Double.isNaN(value) || Double.isInfinite(value)) {
+	    this.editDecimal(buf, value, nint, nd, option);
+    	    return buf;
+	}
+	// Set nd to the number of decimals of LAST part
+	// nd = Math.abs(nd);
+	form = sexadrive[form];
+	if ((form&0x1000) != 0) nd -= 2;
+	if ((form&0x2000) != 0) nd -= 4;
+	while ((nd < 0) && ((form&0xf000)!=0)) {
+	    form -= 0x1000;		// Now form = 0x1... or 0x0...
+	    nd += 2;
+	    if ((form&0xf000) != 0) {	// No seconds
+		if ((form&0xf) == 0) form &= 0xff00;
+		form &= 0xfff0;
+	    }
+	    else {			// No minutes/seconds
+		if ((form&0xf0) == 0) form = 0;
+		form &= 0xff00;
+	    }
+	}
+	//System.out.println("....editSexa: form=0x"+Integer.toHexString(form)
+	// +",nd="+nd);
+	// If just a single number ==> do it via the other routines
+    	if ((form&0xf000) == 0) {
+	    this.editDecimal(buf, value, nint, nd, 	// Mod V1.1
+	        o&(ZERO_FILL|SIGN_EDIT|TRUNCATE));
+	    n = form>>8;
+	    if (n>0) buf.append(sexachar[n]);
+    	    return buf;
+	}
+	if (nd<0) nd=0;
+      	if (value < 0) { o |= 0x80000000; val = -val; }
+	/* Round the value */
+	if ((option&TRUNCATE) == 0) {
+	    f = (form&0x2000) == 0 ? 60. : 3600.;
+	    f *= AstroMath.dexp(nd);
+	    val += 0.5/f;
+	    //System.out.println("....editSexa("+value+",nd="+nd+"), rounded="
+	    //  +val);
+	}
+
+	/* Find the final width required by the fractions */
+	part = (long)val; val -= part;
+	edN(buf, part, nint, o);
+	sep = sexachar[(form>>8)&0xf];
+	if ((form&0xf000) != 0) { 	// Edit the minutes
+	    if (sep != Character.MIN_VALUE) buf.append(sep);
+	    sep = sexachar[(form>>4)&0xf];
+	    val *= 60.; 
+	    if ((form&0x2000) == 0) {	// Minutes only
+		if (nd==0) nd=-1;	// Don't edit the decimal point
+		this.editDecimal(buf, val, 2, nd, ZERO_FILL|TRUNCATE);
+	    }
+	    else {
+	    	n = (int)val; val -= n;
+		buf.append(Character.forDigit(n/10, 10));
+		buf.append(Character.forDigit(n%10, 10));
+	    }
+	}
+	if ((form&0x2000) != 0) {	// Edit the seconds
+	    if (sep != Character.MIN_VALUE) buf.append(sep);
+	    sep = sexachar[form&0xf];
+	    val *= 60.;
+	    if (nd == 0) {
+	    	n = (int)val; 
+		buf.append(Character.forDigit(n/10, 10));
+	    	buf.append(Character.forDigit(n%10, 10));
+	    }
+	    else this.editDecimal(buf, val, 2, nd, ZERO_FILL|TRUNCATE);
+	}
+	if (sep != Character.MIN_VALUE) buf.append(sep);
+	
+	// Remove the ending zeroes
+	if (remove_zeroes) {
+	    for (n = buf.length()-1; (n>1) && (buf.charAt(n) == '0'); n--) ;
+	    if (buf.charAt(n) != '.') n++;	// Remove also decimal point
+	    buf.setLength(n);
+	}
+    	// Finally, return.
+    	return (buf);
+   }
+
+   /**
+    * Internal edition of MJD date -- uses elements in datedrive.
+    * @param  buf   buffer to which the string representation is appended
+    * @param  mjd   the date to edit
+    * @param  driver the suite of elements to edit
+    * @return the editing buffer.
+    */
+   private final void  edate(StringBuffer buf, int mjd, int driver) {
+      int form, i, j, n4, nd10; // year, month, day, yday;
+      int[] ymd = new int[4];
+      	
+        Astrotime.JD2YMD(Astrotime.JD_MJD0+mjd, ymd);
+	/* ---------------
+      	j = mjd + 2400001;	// Julian Date
+	year = -4712;
+	while (j <= 4480)   { j += 146097; year -= 400;}
+	n4 = 4*(j+((2*((4*j-17918)/146097)*3)/4+1)/2-37);
+	nd10=10*( ((n4-237)%1461)/4)+5;
+
+	year += n4/1461;
+	month = (nd10/306+2)%12;
+	day   = (nd10%306)/10+1;
+	------------------ */
+
+	for (form = driver; form!=0; form <<= 4) switch(i = (form>>28)&15) {
+	  case 0: 
+	    continue;
+	  case 1: 		// Year
+	    if (ymd[0] < 0) {
+	    	buf.append('-');
+	    	edN(buf, -ymd[0], 3, Astroformat.ZERO_FILL);
+	    }
+	    else edN(buf, ymd[0], 4, Astroformat.ZERO_FILL);
+	    continue;
+	  case 2:		// Month number
+	    edN(buf, ymd[1]+1, 2, Astroformat.ZERO_FILL);
+	    continue;
+	  case 3:		// Month name
+	    buf.append(month_list[ymd[1]]);
+	    continue;
+	  case 4:		// Day number
+	    edN(buf, ymd[2], 2, Astroformat.ZERO_FILL);
+	    continue;
+	  case 5:		// Day in Year
+	    /* ------------
+	    n4 = (j+32104)%146097;	// Day in 400-yr cycle, #0=01-Jan-2000
+	    if (n4 >= 36525) 		// Century#0 is 25 leap years
+	        n4 += (n4-366)/36524;
+	    n4 %= 1461;		// Day in 4-yr cycle
+	    if (n4 >= 731) n4 += (n4-366)/365;
+	    yday = n4%366;
+	    -------------- */
+	    edN(buf, ymd[3]+1, 3, Astroformat.ZERO_FILL);
+	    continue;
+	  default:		// Separator
+	    buf.append(datesep[i-10]);
+	    continue;
+	}
+    }
+
+   /**
+    * Edition of a MJD date into an ISO-8601 date YYYY-MM-DD
+    * @param  buf   buffer to which the string representation is appended
+    * @param  mjd   the date to edit
+    * @return the editing buffer.
+    */
+   public StringBuffer editDate(StringBuffer buf, int mjd) {
+	edate(buf, mjd, datedrive[DATE_YMD&15]);
+	return(buf);
+   }
+
+   /**
+    * Edition of a MJD date into an ISO-8601 date YYYY-MM-DD
+    * @param  buf   buffer to which the string representation is appended
+    * @param  mjd   the date to edit
+    * @param  option the option for date editing (e.g. Astroformat.DATE_YMD)
+    * @return the editing buffer.
+    */
+    public StringBuffer editDate(StringBuffer buf, int mjd, int option) {
+	if ((option&DATE) == 0) option = DATE_YMD;
+	edate(buf, mjd, datedrive[option&15]);
+	return(buf);
+    }
+
+   /**
+    * Edition of a MJD date into an ISO-8601 date YYYY-MM-DDThh:mm:ss[...]
+    * @param  buf   buffer to which the string representation is appended
+    * @param  mjd   the date to edit
+    * @param  time_prec the precision in the time edition.
+    * 		Values are 0=no time, 2=hr, 4=min, 6=sec, 9=ms, etc.
+    * 		Negative values indicate a maximal precision.
+    * @param  option the option for date editing (e.g. Astroformat.DATE_YMD)
+    * @return the editing buffer.
+    */
+    public StringBuffer editDate(StringBuffer buf, double mjd, 
+	    int time_prec, int option) {
+      int j;
+
+        if (Double.isNaN(mjd)) {
+	    if (time_prec < 2) 
+		return(editNaN(buf, time_prec < 0 ? 0 : 11)) ;
+	    return(editSexa(buf, mjd, 13, time_prec-2, 0));
+	}
+
+	if ((option&DATE) == 0) option = DATE_YMD;
+      	j = (int) mjd;
+	edate(buf, j, datedrive[option&15]);
+	// Edit the time part.
+	if (mjd<0)  --j;
+	double sec = (mjd - j)*86400;   
+	// No time edition when time_prec is zero, or time=0...
+	if ((time_prec <= 0) && ((time_prec>= -1) || (sec == 0)))
+	    return(buf);
+	// Edit time preceded by 'T'
+	buf.append('T');
+	j = time_prec-2;	// Precision for edition of hours
+	if (time_prec < 0) j -= 4;
+	editSexa(buf, sec/3600., 2, j, (option&TRUNCATE)|ZERO_FILL|SEXA3c);
+	return(buf);
+    }
+
+   /**
+    * Edit a complex number (date, time, angle).
+    * @param  buf   buffer to which the string representation is appended
+    * @param  mjd   the value to edit (MJD in case of date/time)
+    * @param  pic   the 'picture' to use, includes
+    * 		Y=year, M=month, D=day, h=hour, m=min, s=sec, d=deg f=fraction
+    * @return the editing buffer.
+    */
+    public StringBuffer editComplex(StringBuffer buf, double mjd, String pic) {
+      int[]  ymd   = new int[4];	// Date elements
+      byte[] len6  = new byte[6];	// Length of each element Y M  h m s
+      byte[] elm6  = new byte[6];	// Index of components 
+      char[] apic  = pic.toCharArray();
+      int bpic = 0;			// begining in pic
+      int epic = pic.length();		// end      in pic
+      int ipic, ielm, len, k, i, j;
+      boolean minus = false;
+      boolean mixed = false;		// Indicates change M<->m D<->d
+      double val = mjd;
+      double round = 1.e-11;		// Precision of fraction to edit
+      int valunit = 2;			// Unit of val 2=D 3=h 4=m 5=s
+      char c, p;
+
+        if (Double.isNaN(val)) 
+	    return(editSexa(buf, val, pic.length(), -1, 0));
+	if (DEBUG) System.out.println("....editComplex(" + mjd +")  pic=" 
+		+ pic);
+
+	// Initialisation
+	len6[0] = len6[1] = len6[2] = len6[3] = len6[4] = len6[5] = 0;
+	elm6[0] = elm6[1] = elm6[2] = elm6[3] = elm6[4] = elm6[5] = 0;
+	if (val>0) val += 0.49*round;
+	else       val -= 0.49*round;
+	
+	// Scan the elements to edit
+	// The pic may be sourronded by quotes
+	if (apic[0] == '"') { bpic = 1; epic--; }
+	for (ielm=0, ipic=bpic; ipic < epic; ) {
+	    c = apic[ipic++];
+	    k = pic1.indexOf(c);
+	    if (k<0) continue;
+	    k %= 6;
+	    if (len6[k] != 0) {		// Duplication in 'picture' ?
+		i = 5-k;		// Month <-> Minute, Day <-> Deg
+		if ((k>0) && (i>0) && (len6[i] == 0)) {
+		    len6[i] = len6[k];
+		    for (j=0; elm6[j] != k; j++) ;
+		    elm6[j] = (byte)i;
+		    k = i;
+		}
+	    }
+	    elm6[ielm++] = (byte)k;
+	    // Count the number of identical elements in picture
+	    for(len=1; (ipic<epic) && (apic[ipic] == c); ipic++) len++;
+	    if (len6[k] == 0) len6[k] = (byte)len;
+	    if (ielm >= 6) break;
+	}
+	if (DEBUG) {
+	    String s;
+	    System.out.print("    edCplx[a]:elm"); s="="; 
+	    for(i=0;i<6;i++) { System.out.print(s+elm6[i]);s=","; } 
+	    System.out.print('\t');
+	    System.out.print("    edCplx[a]:len"); s="="; 
+	    for(i=0;i<6;i++) { System.out.print(s+len6[i]);s=","; } 
+	    System.out.print('\n');
+	}
+
+	// Verify possible mixing month[1]/min[4] 
+	if (     (len6[1] != 0) /* Month given */ 
+	      && (len6[0] == 0) /* but no year */ 
+	      && (len6[4] == 0) /* and no min  */ ) {
+	    len6[4] = len6[1]; len6[1] = 0;
+	    for (j=0; elm6[j] != 1; j++); elm6[j] = 4;
+	    mixed = true;
+	}
+	else if ((len6[1] == 0)	/* No month given */ 
+	      && (len6[0] != 0) /* but year given */ 
+	      && (len6[4] != 0) /* and minutes... */ 
+	      && (len6[5] == 0) /* and no seconds */) {
+	    len6[1] = len6[4]; len6[4] = 0;
+	    for (j=0; elm6[j] != 4; j++); elm6[j] = 1;
+	    mixed = true;
+	}
+
+	// Verify possible mixing day[2]/deg[3]
+	if (     (len6[2] != 0) /* A day given  */
+	      && (len6[3] == 0) /* but no hour  */
+	      && (len6[0] == 0) /* and no year  */ 
+	      && (len6[1] == 0) /* and no month */) {
+	    len6[3] = len6[2]; len6[2] = 0;
+	    for (j=0; elm6[j] != 2; j++); elm6[j] = 3;
+	    mixed = true;
+	}
+	else if ((len6[3] != 0)	/* Degree given   */
+	      && (len6[0] != 0) /* and a year ... */
+	      && (len6[2] == 0) /* but no day ... */) {
+	    len6[2] = len6[3]; len6[3] = 0;
+	    for (j=0; elm6[j] != 3; j++); elm6[j] = 2;
+	    mixed = true;
+	}
+	if (mixed && (DEBUG)) {
+	    String s;
+	    System.out.print("    edCplx[b]:elm"); s="="; 
+	    for(i=0;i<6;i++) { System.out.print(s+elm6[i]);s=","; } 
+	    System.out.print('\t');
+	    System.out.print("    edCplx[b]:len"); s="="; 
+	    for(i=0;i<6;i++) { System.out.print(s+len6[i]);s=","; } 
+	    System.out.print('\n');
+	}
+
+	// Convert the values into their components
+	if (len6[0] != 0) {	// It's a date
+	    Astrotime.JD2YMD(Astrotime.JD_MJD0+val, ymd);
+	    val -= Math.floor(val);	// Remaining fraction of days
+	    /*---
+	    if (DEBUG) {
+		String s;
+		System.out.print("    edCplx-date=="); s="="; 
+		for(i=0;i<4;i++) { System.out.print(s+ymd[i]);s=","; } 
+		System.out.print(" h=" + val); System.out.print('\n');
+	    }
+	    ---*/
+	}
+	else {				// Not a date -- could dontain days
+	    if (val<0) { 	
+		minus = true;
+		val = -val;
+	    }
+	    if (len6[2] > 0) {		// There are days
+	        ymd[3] = (int)val;	// ymd[3] = yday (1..366)
+	        val -= ymd[3];		// Remaining fraction of days
+	    }
+	    else valunit = 3;		// Not a date, no day, unit is hours.
+	}
+
+	/* Edit now the elements */
+	c = p = Character.MIN_VALUE;	// p = preceding char
+	k = 0;
+	for (ielm=0, ipic=bpic; ipic < epic; ) {
+	    p = c;
+	    c = apic[ipic];
+	    if (c == 'f') break;	// Fraction
+	    ipic++;
+	    k = pic1.indexOf(c);
+	    if (k<0) { 			// Unknown element, copy it (e.g. :)
+		buf.append(c); 
+		continue; 
+	    }
+	    i = k%6;			// Element 0=y 1=M, 2=D 3=h 4=m 5=s
+	    if (ielm < 6) { i = elm6[ielm++]; len = len6[i]; }
+	    else len = 0;
+	    if (len == 0) {
+	        for(len=1; (ipic<epic) && (apic[ipic] == c); ipic++) len++;
+	    }
+	    ipic += (len-1);
+	    if (minus) { buf.append('-'); minus = false; len--; }
+	    /* Set value to the correct unit */
+	    while (valunit<i)  { 
+		val   *= fac6[valunit]; 
+		round *= fac6[valunit];
+		valunit++;
+	    }
+	    if (DEBUG) {
+		System.out.print("    edCplx["+i+"]: "+c+" len="+len 
+			+ ",len6[1]=" + len6[1]); 
+		System.out.print('\n');
+	    }
+	    switch(i) {
+	      case 0:	// Year
+		j = ymd[0]; if (len6[0] == 2) j %= 100;
+		edN(buf, j, len, Astroformat.ZERO_FILL);
+		break;
+	      case 1:	// Month
+		if (len6[1] > 2) buf.append(month_list[ymd[1]]);
+		else edN(buf, ymd[1]+1, 2, Astroformat.ZERO_FILL);
+		break;
+	      case 2:	// Day in month, or yday (if no month)
+		if (len<2) len=2;
+		j = len6[1] == 0 ? ymd[3] : ymd[2];
+		/*---
+		if (DEBUG) {
+		    System.out.print("    edCplx[2]: len6[1]=" + len6[1] 
+			    + ", j=" + j); 
+		    System.out.print('\n');
+		}
+		---*/
+		edN(buf, j, len, len6[0]>0 ? ZERO_FILL : 0);
+		break;
+	      case 3:	// Hour or degree
+		if (len<2) len=2;
+		j = (int) val; 
+		edN(buf, j, len, len6[2]>0 ? ZERO_FILL : 0);
+		val -= j;
+		break;
+	      case 4:	// Minutes
+		if (len<2) len=2;
+		j = (int) val;
+		edN(buf, j, len, j<60 ? ZERO_FILL : 0);
+		val -= j;
+		break;
+	      case 5:	// Seconds
+		if (len<2) len=2;
+		j = (int) val ;
+		edN(buf, j, len, j<60 ? ZERO_FILL : 0);
+		val -= j;
+		break;
+	    }
+	    //if (ielm < 6) { i = elm6[ielm]; len6[i] = 0; ielm++; }
+	}
+	if (minus) { buf.append('-'); minus = false; }
+
+	// edit eventual fraction
+	if (DEBUG) {
+		System.out.print("    Fraction="+val + " (valunit=" 
+			+ valunit + ")\n");
+	}
+	len = 0;	// Number of 'f'
+	if (c == 'f') for (; (ipic<epic) && (apic[ipic] == 'f'); ipic++) 
+	    len++;
+	if ((len>0) || (val>round)) {
+	    if ((len == 0) && (p != '.'))  buf.append('.');
+	    i = len>0 ? len : 9;	/* Max = 9 decimals */
+	    while (--i >= 0) {
+		val *= 10; round *= 10.;
+		j = (int)val;
+		val -= j;
+		buf.append(Character.forDigit(j, 10));
+		if ((val <= round) && (len == 0)) break;
+	    }
+	}
+
+	// and eventual fill characters
+	while (ipic < epic) { buf.append(apic[ipic]); ipic++; }
+	return(buf);
+    }
+
+    /**
+     * The conversion to string
+    **/
+    public String toString() {
+      StringBuffer b = new StringBuffer(64);
+        b.append("null_text=");  b.append(nulls[0]);
+        b.append(", inf_text="); b.append(inf_string);
+	return(b.toString());
+    }
+}
Index: aladin/cds/astro/Equatorial.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Equatorial.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,62 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/**
+ * This abstract class introduces the specificities of the equatorial
+ * coordinates.
+ * <BR>An equatorial coordinate system is a system linked to the Earth,
+ * and therefore varies with the long-term Earth motion (precession).
+ * A full definition of this frame therefore requires the knowledge
+ * of an Equinox which specifies when exactly this frame coincides with
+ * the Earth frame.
+ *  
+ * @author Francois Ochsenbein (CDS)
+ *
+ */
+public abstract class Equatorial extends Astroframe {
+    /** Any equatorial frame must have its equinox defined.
+     *  The exact definition is Besselian or Julian, depending on type
+     *  of frame (FK5-based is Julian, FK4-based is Besseilan)
+    **/
+    protected double equinox = 0;	// The actual equinox in J/B year
+    /* The Equatorial frame also has a matrix to precess to standard equinox*/
+    protected double[][] toBaseEquinox;
+
+    /**
+     * Constructor: editions are sexagesimal time in Lon/Lat 
+    **/
+    Equatorial() {
+	hms = true;
+	// Default edition in sexagesimal separated by : 
+        ed_lon = Editing.SEXA3c|Editing.ZERO_FILL;
+        ed_lat = Editing.SEXA3c|Editing.ZERO_FILL|Editing.SIGN_EDIT;
+    }
+
+    /**
+     * Edition of Equatorial frame.
+     * @return the name of the Astroframe.
+    **/
+    public String toString() {
+	if ((base_epoch != epoch) || (equinox != base_epoch)) 
+	    return (super.toString(this.epoch));
+	return (super.toString());
+    }
+}
Index: aladin/cds/astro/FK4.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/FK4.java	2012-09-27 15:30:32.000000000 +0200
@@ -0,0 +1,549 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                FK4  (Astroframe -> Equatorial -> FK4)
+ *==================================================================*/
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * The FK4 is an equatorial coordinate system (coordinate system linked to 
+ * the Earth) based on its B1950 position. 
+ * The units used for time specification is the Besselian Year.
+ *
+ * The conversion to/from FK5 (which coincides with ICRS) uses the 
+ * algorithm published by Standish (1982A&A...115...20S)
+ *  
+ * @author Francois Ochsenbein (CDS)
+ *
+ */
+
+public class FK4 extends Equatorial {
+  /**
+   * In addition to the equinox, we store the precession matrix
+   * which converts to the standard epoch.
+  **/
+   static private boolean DEBUG=false;
+   static private double[] ev50 = eterm(1950.);	// e-term for B1950
+   protected double[][] toBaseEquinox;		// Precession to B1950
+   protected double[] ev_eq;			// e-term for Equinox
+
+  /**
+   * Initialize the parameters of this equatorial frame.
+   * @param equinox the equinox of definition, in Besselian Year.
+   * @param epoch   the default epoch, in Julian Year
+  **/
+   private void initialize(double equinox, double epoch) {
+	this.precision = 6;	// Intrinsic precision
+        base_epoch = Astrotime.B2J(1950.);
+	this.equinox = equinox;
+	this.epoch = epoch;
+	this.name = "FK4(B" + equinox + ")";
+        this.ed_lon = Editing.SEXA3c|Editing.ZERO_FILL;
+        this.ed_lat = Editing.SEXA3c|Editing.ZERO_FILL|Editing.SIGN_EDIT;
+	if (Math.abs(equinox-1950.0)>0.0003) {
+	     toBaseEquinox = this.precessionMatrix(equinox, 1950.);
+	     ev_eq = eterm(equinox);
+	}
+	else {
+	    toBaseEquinox = Coo.Umatrix3;
+	    ev_eq = ev50;
+	}
+   }
+
+   /**
+    * Constants for Conversion from FK4 to FK5
+    * The 6x6 matrix to move from FK4 to FK5
+    * Proper motions are in arcsec/century (10mas/yr) 
+   **/
+
+   /** Matrix 6x1 to compute the e-term */
+   static protected double[] A = {		// For e-term
+      //-0.33530/206265., -0.06584/206265., -0.02855/206265.,
+           -1.62557e-6,    -0.31919e-6,      -0.13843e-6,
+      // 1.245e-3,      -1.580e-3,      -0.659e-3  
+         1.244e-3,      -1.579e-3,      -0.660e-3    };
+
+   /** 
+    * Table 2 of Standish (1982A&A...115...20S), rediscussed by Soma and
+    * Aoki (1990A&A...240..150S), and apparently slightly modified 
+    * by the starlink group.
+    **/
+   static protected double[][] EM = {	// 
+     { 	 0.9999256782, 		-0.0111820611, 		-0.0048579477,
+		 2.42395018e-6,		-0.02710663e-6,		-0.01177656e-6},
+     {	 0.0111820610,     	 0.9999374784,     	-0.0000271765,
+		 0.02710663e-6,      	 2.42397878e-6,      	-0.00006587e-6},
+     {	 0.0048579479,     	-0.0000271474,     	 0.9999881997,
+		 0.01177656e-6,      	-0.00006582e-6,      	 2.42410173e-6},
+     {	-0.000551,         	-0.238565,         	 0.435739,
+		 0.99994704e0,       	-0.01118251e0,       	-0.00485767e0},
+     {	 0.238514,         	-0.002667,         	-0.008541,
+		 0.01118251e0,       	 0.99995883e0,       	-0.00002718e0},
+     {	-0.435623,         	 0.012254,         	 0.002117,
+		 0.00485767e0,       	-0.00002714e0,       	 1.00000956e0}
+     };
+
+   /* For moving from FK4 to FK5 without proper motion, the EM50 matrix
+      is used
+      EM50[i][j] = EM[i][j] + EM[i+3][j]*dtB/PMF ;
+   */
+   static private double EM50[][] = {
+     { 0.9999256795356672, -0.0111814827996970, -0.0048590039655699},
+     { 0.0111814828233251,  0.9999374848650175, -0.0000271557959449},
+     { 0.0048590038843768, -0.0000271771046587,  0.9999881945682256}
+   } ;
+
+   /** The 6x6 matrix to move from FK5 to FK4 */
+   static protected double[][] EM1 = {	/* FK5 ==> FK4	*/
+     { /*0.9999256795,      0.0111814828,     0.0048590039,*/
+         0.9999256795,      0.0111814829,     0.0048590038,
+	    /*-2.42389840e-6,      -0.02710544e-6,     -0.01177742e-6*/
+	      -2.42389840e-6,      -0.02710545e-6,     -0.01177742e-6},
+     {  -0.0111814828,      0.9999374849,    -0.0000271771,
+	     /*0.02710544e-6,      -2.42392702e-6,      0.00006585e-6*/
+	       0.02710545e-6,      -2.42392702e-6,      0.00006585e-6},
+     {/*-0.0048590040,     -0.0000271557,     0.9999881946,*/
+        -0.0048590040,     -0.0000271558,     0.9999881946,
+	       0.01177742e-6,       0.00006585e-6,     -2.42404995e-6},
+     {/*-0.000551,          0.238509,        -0.435614,*/
+        -0.000550,          0.238509,        -0.435613,
+  	       0.99990432e0,        0.01118145e0,       0.00485852e0},
+     {/*-0.238560,         -0.002667,         0.012254,*/
+        -0.238559,         -0.002668,         0.012254,
+	      -0.01118145e0,        0.99991613e0,      -0.00002717e0},
+     {/* 0.435730,         -0.008541,         0.002117,*/
+         0.435730,         -0.008541,         0.002116,
+	      -0.00485852e0,       -0.00002716e0,       0.99996684e0}
+     };
+
+    /** To estimate the proper motions in FK4 **/
+     static double[][] EM2 = null; /* new double[6][6];	*/
+
+   // ===========================================================
+   // 			Contructor
+   // ===========================================================
+
+  /**
+   * Instanciate an FK4 frame
+   * @param equinox the equinox of definition, in Besselian Year.
+   * @param epoch   the epoch in Besselian Year.
+  **/
+    public FK4(double equinox, double epoch) {
+	initialize(equinox, Astrotime.B2J(epoch));
+    }
+
+  /**
+   * Instanciate an FK4 frame
+   * @param equinox the equinox of definition, in Besselian Year.
+  **/
+    public FK4(double equinox) {
+	initialize(equinox, Astrotime.B2J(equinox));
+    }
+
+  /**
+   * Instanciate an FK4 frame (at default B1950 equinox)
+  **/
+    public FK4() {
+	initialize(1950., base_epoch);
+    }
+
+  /**
+   * Get the conversion to ICRS matrix
+   * @return null (it's impossible to to reduce the transformation to a matrix)
+  **/
+    public double[][] toICRSmatrix() {
+	return(null);
+    }
+
+   // ===========================================================
+   // 			Precession in FK4 system
+   // ===========================================================
+
+   /**
+    * Precession matrix from equinox t0 to t1 (Besselian Years)
+    * @param eq0 equinox at original equinox (Besselian year)
+    * @param eq1 equinox of destination      (Besselian year)
+    * @return the rotation that converts t0 into t1 by  u1 = R  u0
+   **/
+    static public double[][] precessionMatrix(double eq0, double eq1) {
+      /* Note: Seems to be not reversible. Choose t0 closest to 1900 */
+      double t0, dt, z, theta, zeta;
+      boolean reverse = false;
+        t0 = eq0 - 1900; dt = eq1 - eq0; 
+	if (Math.abs(t0) > Math.abs(t0+dt)) {	// t0+dt = t1
+            reverse = true;
+	    t0 += dt; 
+	    dt = -dt;
+	}
+        t0 /= 1000.; dt /= 1000.;	// Express in Milleniums
+	zeta = dt*(23042.53+ t0*(139.73+0.06*t0)
+	     + dt*(30.23+18.*dt-0.27*t0) ) /3600.;
+	z    = zeta + dt*dt*(79.27+0.66*t0+0.32*dt)/3600.;
+	theta = dt* (20046.85 - t0*(85.33+0.37*t0)
+	      - dt*(42.67+0.37*t0+41.8*dt) )/3600.;
+	if (reverse) return(Coo.eulerMatrix(-zeta, -theta, -z));
+	else  return(Coo.eulerMatrix(z, theta, zeta));
+    }
+
+   // ===========================================================
+   // 			Convert To/From ICRS
+   // ===========================================================
+
+    /* For debugging purposes: display a 6-vector */
+    private static void pr6(double u6[], String t1, String t2) {
+	double v[] = { u6[0], u6[1], u6[2] };
+	    System.out.println(t1 + Coo.toString(v));
+	    v[0]=u6[3]; v[1]=u6[4]; v[2]=u6[5];
+	    System.out.println(t2 + Coo.toString(v));
+    }
+
+    /* Computation e-term */
+    /**  
+     * Compute the e-term (change due to the ellipticity of Earth orbit).
+     * @param  y the epoch, in Besselian years
+     * @return the 3 components of the E-term
+    **/
+    public static final double[] eterm(double y) {
+      double t, e, L, eps, cL;
+      double ev[] = new double[3];
+        t   =  (y - 1900.e0)/1.e2;	// Centuries
+	eps = 23.452   - 0.013*t;	// Mean obliquity
+	e   = 0.016751 - 0.000042*t;	// Eccentricity
+	L   = 281.221  + 1.719*t;	// Mean longitude of perihelion
+
+	e  *= (20.496/(3600.*180./Math.PI));	// Aberration
+	cL  = AstroMath.cosd(L);
+	ev[0] =  e * AstroMath.sind(L);
+	ev[1] = -e * cL * AstroMath.cosd(eps);
+	ev[2] = -e * cL * AstroMath.sind(eps);
+	if(DEBUG) System.out.println(".... e-term(B" + y + "): " 
+		+ Coo.toString(ev));
+        return(ev);
+    }
+
+  /**
+   * Convert the position to FK5 system -- assumed to be ICRS.
+   * We assume no proper motion in FK5, and an equinox/epoch in B1950.
+   * @param coo a coordinate which is converted from FK4(B1950) to FK5(J2000)
+  **/
+    public static void toFK5(Coo coo) {
+      double u6[] = new double[6]; 
+    /*-------------------------------
+     * NEW Method using the NEW Method Matrix
+     **
+	double w, x, y, z;
+	double u[] = { coo.x, coo.y, coo.z }; 	// coo.getUvector();
+	// Remove e-term (replace r by r - r^(A^r))
+	w = u[0]*A[0] + u[1]*A[1] + u[2]*A[2]; // Ar
+	u[0] -= A[0] - w*u[0];
+	u[1] -= A[1] - w*u[1];
+	u[2] -= A[2] - w*u[2];
+	// With EM50 matrix:
+	x = EM50[0][0]*u[0] + EM50[0][1]*u[1] + EM50[0][2]*u[2];
+	y = EM50[1][0]*u[0] + EM50[1][1]*u[1] + EM50[1][2]*u[2];
+	z = EM50[2][0]*u[0] + EM50[2][1]*u[1] + EM50[2][2]*u[2];
+	// Renormalize the Unit Vector
+	w = Math.sqrt(x*x + y*y + z*z);
+	x /= w; y /= w; z /= w;
+	u[0]=x; u[1]=y; u[2]=z; 
+	System.out.println("....toFK5.fast : " + Coo.toString(u));
+	coo.set(x, y, z);
+      ---------------------------------*/
+
+        // Estimate the proper motion...
+        coo.copyUvector(u6);
+        estimateFK4motion(u6);
+	// Convert to FK5
+	toFK5(u6);	// Now, in FK5, Ep.=Eq.=J2000
+	/* Verify consecutive transformations if they match... */
+	/* ---------------------------------- Test Code
+	if(DEBUG) {
+	  double v[] = new double[3]; int i;
+	    eterm(1950., v);
+	    v[0]=u6[0]; v[1]=u6[1]; v[2]=u6[2];
+	    System.out.println("....toFK5 gives: " + Coo.toString(v));
+	    v[0]=u6[3]; v[1]=u6[4]; v[2]=u6[5];
+	    System.out.println("          .dot.  " + Coo.toString(v));
+	  for(i=0; i<10; i++) {
+	    //u6[3] = u6[4] = u6[5] = 0;
+	    fromFK5(u6);
+	    v[0]=u6[0]; v[1]=u6[1]; v[2]=u6[2];
+	    System.out.println(".... back FK4  : " + Coo.toString(v));
+	    v[0]=u6[3]; v[1]=u6[4]; v[2]=u6[5];
+	    System.out.println("          .dot.  " + Coo.toString(v));
+	    System.out.println("          norm:  " 
+		    + Math.sqrt(u6[0]*u6[0]+u6[1]*u6[1]+u6[2]*u6[2]));
+	    toFK5(u6);
+	    v[0]=u6[0]; v[1]=u6[1]; v[2]=u6[2];
+	    System.out.println("....FK5 again  : " + Coo.toString(v));
+	    v[0]=u6[3]; v[1]=u6[4]; v[2]=u6[5];
+	    System.out.println("          .dot.  " + Coo.toString(v));
+	    System.out.println("          norm:  " 
+		    + Math.sqrt(u6[0]*u6[0]+u6[1]*u6[1]+u6[2]*u6[2]));
+	  }
+	}
+	---------------------------------------------*/
+	coo.set(u6[0], u6[1], u6[2]);
+    }
+
+  /**
+   * Convert the position from standard B1950 FK4 to standard J2000 FK5 system 
+   * with Standish's algorithm.
+   * Standish uses the 6x6 matrix applied on the 6-vector
+   * (x y z xd yd zd) representing the position + derivative 
+   * (derivatives expressed in arcsec/century) with the EM matrix
+   * applied on the vector after subtraction of the E-term
+   * The E-term (due to the Earth's elliptical orbit) can be expressed
+   *  r ^ (A ^ r) = A - (Ar)r
+   *  where ^ represents the vectorial product, and  the scalar product.
+   * @param u6 6-vector containing position + mouvement (rad/yr)
+  **/
+    public static void toFK5(double[] u6) {
+	double v[] = new double[6];
+	double w, wd;
+	int i, j;
+	// Convert the derivative part, originally in rad/yr, into arcsec/cy
+	v[0] = u6[0]; v[1] = u6[1]; v[2] = u6[2];
+	v[3] = u6[3] * (360000.*180./Math.PI);
+	v[4] = u6[4] * (360000.*180./Math.PI);
+	v[5] = u6[5] * (360000.*180./Math.PI);
+	if(DEBUG) pr6(v, "        toFK5(1) ", "                 ");
+	// Remove e-term (replace r by r - r^(A^r))
+	w  = v[0]*A[0] + v[1]*A[1] + v[2]*A[2]; // Ar
+	wd = v[0]*A[3] + v[1]*A[4] + v[2]*A[5];	// A1r
+	v[0] -= A[0] - w*u6[0]; 
+	v[1] -= A[1] - w*u6[1]; 
+	v[2] -= A[2] - w*u6[2]; 
+	// Correction to the proper motions (not in Standish)
+	v[3] -= A[3] - wd*u6[0]; 
+	v[4] -= A[4] - wd*u6[1]; 
+	v[5] -= A[5] - wd*u6[2]; 
+	// Rotate with the EM matrix
+	for (i=0; i<6; i++) {
+	    w = 0;
+	    for (j=0; j<6; j++) w += EM[i][j]*v[j];
+	    u6[i] = w;
+	}
+	if(DEBUG) pr6(u6, "        toFK5(2) ", "                 ");
+	// Convert the derivative part to rad/yr
+	u6[3] /= (360000.*180./Math.PI);
+	u6[4] /= (360000.*180./Math.PI);
+	u6[5] /= (360000.*180./Math.PI);
+	// Renormalize
+	w = Math.sqrt(u6[0]*u6[0] + u6[1]*u6[1] + u6[2]*u6[2]);
+	for (i=0; i<6; i++) u6[i] /= w;
+    }
+
+   /**
+    * Compute FK4 position from FK5, assuming no proper motion in FK5
+    * and an observation in B1950.
+    * @param coo a coordinate which is converted from FK5(J2000) to FK4(B1950)
+    * @return FK4 vector x3
+   **/
+    public static void fromFK5(Coo coo) {
+    /* Note: could be coded with using the 6-vector method:
+     * ----
+        double u6[] = new double[6];
+        coo.copyUvector(u6); u6[3] = u6[4] = u6[5] = 0.;
+        fromFK5(u6);
+     *---------------------------------------------------*/
+	double w, x, y, z;
+	double u[] = { coo.x, coo.y, coo.z }; 	// coo.getUvector();
+	// 6-vector Rotation. The velocity is zero.
+	x = EM1[0][0]*u[0] + EM1[0][1]*u[1] + EM1[0][2]*u[2];
+	y = EM1[1][0]*u[0] + EM1[1][1]*u[1] + EM1[1][2]*u[2];
+	z = EM1[2][0]*u[0] + EM1[2][1]*u[1] + EM1[2][2]*u[2];
+	// Renormalize the Unit Vector
+	w = Math.sqrt(x*x + y*y + z*z);
+	x /= w; y /= w; z /= w;
+	// Apply e-term
+	w = x*A[0] + y*A[1] + z*A[2]; 	// Ar
+	x += A[0] - w*x;
+	y += A[1] - w*y;
+	z += A[2] - w*z;
+	// Renormalize the Unit Vector (a tiny bit)
+	w = Math.sqrt(x*x + y*y + z*z);
+	x /= w; y /= w; z /= w;
+	coo.set(x, y, z);
+    }
+
+  /**
+   * Convert the position from standard J2000 FK5 to standard B1950 FK4 system
+   * with Standish's algorithm.
+   * Standish uses the 6x6 matrix applied on the 6-vector
+   * (x y z xd yd zd) representing the position + derivative 
+   * (derivatives expressed in arcsec/century) with the EM matrix
+   * applied on the vector after subtraction of the E-term
+   * The E-term (due to the Earth's elliptical orbit) can be expressed
+   *  r ^ (A ^ r) = A - (Ar)r
+   *  where ^ represents the vectorial product, and  the scalar product.
+   * @param u6 6-vector containing position + mouvement (rad/yr)
+  **/
+    public static void fromFK5(double[] u6) {
+	double v[] = new double[6];
+	double w, wd;
+	int i, j;
+	// Convert the derivative part, originally in rad/yr, into arcsec/cy
+	// v[0] = u6[0]; v[1] = u6[1]; v[2] = u6[2];
+	// v[3] = u6[3] * (360000.*180./Math.PI);
+	// v[4] = u6[4] * (360000.*180./Math.PI);
+	// v[5] = u6[5] * (360000.*180./Math.PI);
+	u6[3] *= (360000.*180./Math.PI);
+	u6[4] *= (360000.*180./Math.PI);
+	u6[5] *= (360000.*180./Math.PI);
+	if(DEBUG) pr6(u6, "        from5(1) ", "                 ");
+	// Rotate with the EM1 matrix
+	for (i=0; i<6; i++) {
+	    w = 0;
+	    for (j=0; j<6; j++) w += EM1[i][j]*u6[j];
+	    v[i] = w;
+	}
+	// Renormalize
+	w = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
+	for (i=0; i<6; i++) v[i] /= w;
+	if(DEBUG) pr6(v, "        from5(+) ", "                 ");
+	// Include the e-term (replace r by r + r^(A^r))
+	w  = v[0]*A[0] + v[1]*A[1] + v[2]*A[2];	// Ar
+	wd = v[0]*A[3] + v[1]*A[4] + v[2]*A[5];	// A1r
+	// Correction to the proper motions (not in Standish)
+	u6[3] = v[3] + A[3] - wd*v[0]; 
+	u6[4] = v[4] + A[4] - wd*v[1]; 
+	u6[5] = v[5] + A[5] - wd*v[2]; 
+	// Correction to the position
+	u6[0] = v[0] + A[0] - w*v[0]; 
+	u6[1] = v[1] + A[1] - w*v[1]; 
+	u6[2] = v[2] + A[2] - w*v[2]; 
+	// Renormalize (a tiny amount only!)
+	w = Math.sqrt(u6[0]*u6[0] + u6[1]*u6[1] + u6[2]*u6[2]);
+	for (i=0; i<6; i++) u6[i] /= w;
+	if(DEBUG) pr6(u6, "        from5(2) ", "                 ");
+	// Convert the derivative part to rad/yr
+	u6[3] /= (360000.*180./Math.PI);
+	u6[4] /= (360000.*180./Math.PI);
+	u6[5] /= (360000.*180./Math.PI);
+    }
+
+  /**
+   * Estimate the proper motions in the FK4 system, assuming a zero
+   * proper motion in the FK5.
+   * @param u6 6-vector containing position + mouvement (rad/yr);
+   * 		the mouvement (derivative, pos. u6[3-5]) is updated.
+  **/
+    public static void estimateFK4motion(double[] u6) {
+	double v1[] = new double[6];
+	double w;
+	int i, j, k;
+	// the matrix EM2 = EM1 * (EM restricted to 3x3):
+	// Compute this matrix if not yet done.
+	if (EM2 == null) { double tm[][] = new double[6][6];
+	    for (i=0; i<6; i++) for (j=0; j<6; j++) {
+	        w = 0;
+	        for (k=0; k<3; k++) w += EM1[i][k] * EM[k][j];
+	        tm[i][j] = w;
+	    }
+	    EM2 = tm;
+	}
+	for (i=0; i<6; i++) {
+	    w=0;
+	    for (j=0; j<3; j++) 
+		w += EM2[i][j] * u6[j];
+	    v1[i] = w;
+	}
+	// Compute scalars u.A
+	w = v1[0]*A[3] + v1[1]*A[4] + v1[2]*A[5];
+	// Include A-term
+	for (i=3; i<6; i++) v1[i] += A[i] - w*v1[i-3];
+	// Output Derivative (in rad/yr)
+	for (i=3; i<6; i++) u6[i] = v1[i] / (360000.*180./Math.PI);
+    }
+
+   /**
+    * Convert the position to its ICRS equivalent.
+    * @param u6  the 6-vector (cartesian position + derivative) 
+    * 		Velocity in Jyr<sup>-1</sup>).
+    * 	        u6 is on FK4 on input, in ICRS on output)
+   **/
+    public void toICRS(double[] u6) {
+	if (toBaseEquinox != Coo.Umatrix3) {
+	  double[] ev = new double[3];
+	    Coo.sub(u6, ev_eq);		// Subtract E-term for Equinox
+	    Coo.rotateVector(toBaseEquinox, u6);
+	    Coo.add(u6, ev50);		// Add E-term for B1950.0
+	}
+	// System.out.println("....FK4.toICRS, base_epoch=" + base_epoch);
+	toFK5(u6);	// Converts rigorously.
+    }
+
+   /**
+    * Convert the position to its ICRS equivalent.
+    * @param coo on input the position in this frame; on ouput the ICRS
+   **/
+    public void toICRS(Coo coo) {
+	if (toBaseEquinox != Coo.Umatrix3) {
+	  double[] ev = new double[3];
+	    coo.sub(ev_eq);		// Subtract E-term for Equinox
+	    coo.rotate(toBaseEquinox);
+	    coo.add(ev50);		// Add E-term for B1950.0
+	}
+	toFK5(coo);	// Converts rigorously.
+    }
+
+   /**
+    * Convert the position from the ICRS frame to FK4.
+    * @param u6  the 6-vector (cartesian position + derivative)
+    *            Velocity in Jyr<sup>-1</sup>).
+    *            (in ICRS on input, in FK4 on output)
+   **/
+    public void fromICRS(double[] u6) {
+	// System.out.println("....FK4.fromICRS, base_epoch=" + base_epoch);
+	fromFK5(u6);
+	if (toBaseEquinox != Coo.Umatrix3) {
+	  double[] ev = new double[3];
+	    Coo.sub(u6, ev50);		// Subtract E-term for B1950.0
+	    Coo.rotateVector_1(toBaseEquinox, u6);
+	    Coo.add(u6, ev_eq);		// Add E-term for Equinox
+	}
+    }
+
+   /**
+    * Convert the position from the ICRS frame.
+    * @param coo on input the ICRS position, on output in FK4.
+   **/
+    public void fromICRS(Coo coo) {
+      double[] u = new double[6];
+	coo.copyUvector(u);
+	u[3] = u[4] = u[5] = 0.;
+	fromFK5(u);
+	if(DEBUG) pr6(u, "FK4from ", "FK4from.");
+	coo.set(u[0], u[1], u[2]);
+	//if(DEBUG) coo.dump("FK4.fromICRS");
+	//fromFK5(coo);
+	if (toBaseEquinox != null) {
+	  double[] ev = new double[3];
+	    coo.sub(ev50);		// Subtract E-term for B1950.0
+	    coo.rotate_1(toBaseEquinox);
+	    coo.add(ev_eq);		// Add E-term for Equinox
+	}
+    }
+}
Index: aladin/cds/astro/FK5.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/FK5.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,128 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                FK5  (Astroframe -> Equatorial -> FK5)
+ *==================================================================*/
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * The FK5 is an equatorial coordinate system (coordinate system linked to 
+ * the Earth) based on its J2000 position.
+ * As any equatorial frame, the FK5-based follows the long-term
+ * Earth motion (precession).
+ *  
+ * @author Francois Ochsenbein (CDS)
+ *
+ */
+
+public class FK5 extends Equatorial {
+
+  /**
+   * Initialize the parameters of this equatorial frame.
+   * @param equinox the equinox of definition (in Julian year)
+   * @param epoch   the default epoch (in Julian year)
+  **/
+   private void initialize(double equinox, double epoch) {
+   	this.precision = 7;	// Intrinsic precision = 0.01arcsec
+	this.equinox = equinox;
+	this.epoch = epoch;
+	this.name = "FK5(J" + equinox + ")";
+        // ed_lon = Editing.SEXA3c|Editing.ZERO_FILL;
+        // ed_lat = Editing.SEXA3c|Editing.ZERO_FILL|Editing.SIGN_EDIT;
+	if (Math.abs(equinox-2000.0)>0.0003) 
+	     toBaseEquinox = this.precessionMatrix(equinox, 2000.);
+	else toBaseEquinox = Coo.Umatrix3;
+	ICRSmatrix = toBaseEquinox;
+   }
+
+   // ===========================================================
+   // 			Constructor
+   // ===========================================================
+
+  /**
+   * Instanciate an FK5 frame
+   * @param equinox the equinox of definition, in Julian Year.
+  **/
+    public FK5(double equinox) {
+	initialize(equinox, 2000.);
+    }
+
+  /**
+   * Instanciate an FK5 frame (at default J2000 equinox)
+  **/
+    public FK5() {
+	initialize(2000., 2000);
+    }
+
+   // ===========================================================
+   // 			Precession in FK5 system
+   // ===========================================================
+
+   /**
+    * Precession matrix from equinox t0 to t1 (Julian Years)
+    * @param eq0 equinox at original equinox (julian year)
+    * @param eq1 equinox of destination      (julian year)
+    * @return the rotation matrix R such that   u1 = R  u0
+   **/
+    static final double[][] precessionMatrix(double eq0, double eq1) {
+      double t0, dt, w, z, theta, zeta;
+      boolean reverse = false;
+      // Choose t0 as the closest to 2000.
+        t0 = (eq0 - 2000.)/100.;	// Origin J2000.0
+	dt = (eq1 - eq0)/100.;		// Centuries
+	if (Math.abs(t0) > Math.abs(t0+dt)) {	// t0+dt = t1
+	    reverse = true;
+	    t0 += dt;
+	    dt = -dt;
+	}
+	w = 2306.2181+(1.39656-0.000139*t0)*t0;	// arcsec
+	zeta = (w + ( (0.30188-0.000344*t0) + 0.017998*dt) *dt)
+		*dt/3600.;		// to degrees
+	z    = (w + ( (1.09468+0.000066*t0) + 0.018203*dt) *dt)
+		*dt/3600.;		// to degrees
+	theta =  ( (2004.3109 + (-0.85330-0.000217*t0)*t0)
+		 +( (-0.42665-0.000217*t0) - 0.041833*dt) *dt) 
+		*dt/3600.;
+	if (reverse) return(Coo.eulerMatrix(-zeta, -theta, -z));
+	else return(Coo.eulerMatrix(z, theta, zeta));
+    }
+
+   // ===========================================================
+   // 			toICRSmatrix
+   // ===========================================================
+
+   /**
+    * Defines the rotation matrix to rotate to ICRS
+    * @return the 3x3 rotation matrix to convert a position to ICRS frame
+   **/
+    public double[][] toICRSmatrix() {
+	return(ICRSmatrix);
+    }
+
+   // ===========================================================
+   // 			Convert To/From ICRS
+   // ===========================================================
+
+    // Default methods are OK.
+}
Index: aladin/cds/astro/Galactic.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Galactic.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,109 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                Galactic  (Astroframe -> Galactic)
+ *==================================================================*/
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * The Galactic frame is defined such that the plane of our Galaxy
+ * (the Milky Way) has a latitude close to zero.
+ * The galactic center has a position (0,0) in this system.
+ * It was originally defined by reference to the FK4 System.
+ *  
+ * @author Francois Ochsenbein (CDS)
+ *
+ */
+
+public class Galactic extends Astroframe {
+
+  /**
+   * Name of this frame.
+  **/
+    static public String class_name = "Galactic";
+
+   /**
+    * Constants to transform from  Galactic to SuperGalactic:
+    * See Supergal
+   **/
+
+   //  In FK4/B1950, the Galactic Frame is defined by
+   // North Pole at (RA, Dec) = 192.25 +27.4 (12h49 +27d24')
+   //    longitude of ascending node = 33 deg
+   // Matrix B1950 to Gal = Euler(asc.node-90, 90-lat(Pole), -lon(Pole))
+   /** Rotation matrix to move from FK4 to Galactic. */
+   static public final double[][] gal_1950 = {	// Euler(-57, 62.6, -192.25)
+     {-0.0669887394151508,-0.8727557658519927,-0.4835389146321842},
+     { 0.4927284660753235,-0.4503469580199614, 0.7445846332830311},
+     {-0.8676008111514348,-0.1883746017229204, 0.4601997847838516}
+   } ;
+
+   /** 
+    * Rotation matrix to move from FK5 to Galactic.
+    * (from Hipparcos documentation vol1, Eq. 1.5.11, see
+    * ftp://cdsarc.u-strasbg.fr/pub/cats/I/239/version_cd/docs/vol1/sect1_05.pdf
+    * transformed to have a truly orthogonal matrix.
+   **/
+    static public final double[][] gal_2000 = {
+    // -0.0548755604,       -0.8734370902,       -0.4838350155
+      {-0.0548755604024359, -0.8734370902479237, -0.4838350155267381},
+    //  0.4941094279,       -0.4448296300,        0.7469822445},
+      { 0.4941094279435681, -0.4448296299195045,  0.7469822444763707},
+    // -0.8676661490, -0.1980763734,  0.4559837762}
+      {-0.8676661489811610, -0.1980763734646737,  0.4559837762325372}
+    };
+
+   // ===========================================================
+   // 			Contructor
+   // ===========================================================
+
+  /**
+   * Instanciate an Galactic frame
+  **/
+    public Galactic() {
+    	this.precision = 5;	// Intrinsic precision = 1arcsec 
+	this.name = class_name;
+	epoch = 2000.;		// May be changed by setFrameEpoch()
+	ICRSmatrix = AstroMath.m3t(gal_2000);
+    }
+
+   // ===========================================================
+   // 			toICRSmatrix
+   // ===========================================================
+
+   /**
+    * Defines the rotation matrix to rotate to ICRS
+    * @return the 3x3 rotation matrix to convert a position in ICRS frame
+   **/
+    public double[][] toICRSmatrix() {
+	return(ICRSmatrix);
+    }
+
+   // ===========================================================
+   // 			Convert to FK5
+   // ===========================================================
+
+   // Default methods are OK.
+
+}
Index: aladin/cds/astro/ICRS.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/ICRS.java	2012-09-27 15:30:32.000000000 +0200
@@ -0,0 +1,129 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                ICRS  (Astroframe -> ICRS)
+ *==================================================================*/
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * The ICRS frame (International Celestial Reference System) is defined 
+ * by the Hipparcos mission. It is also named <em>ICRF</em>.
+ *
+ *  
+ * @author Francois Ochsenbein (CDS)
+ *
+ */
+
+public class ICRS extends Astroframe {
+
+  /**
+   * Name of this firame.
+  **/
+    static public String class_name = "ICRS";
+
+   // ===========================================================
+   // 			Contructor
+   // ===========================================================
+
+  /**
+   * Instanciate an ICRS frame
+   * @param epoch the default epoch, in Julian years
+  **/
+    public ICRS(double epoch) {
+    	this.precision = 9;		// Intrinsic precision = 0.1mas
+	ICRSmatrix = Coo.Umatrix3;	// Identity matrix
+	this.name = class_name;
+	this.epoch = epoch;
+	hms = true;			// Sexagesimal is h m s in RA
+        ed_lon = Editing.SEXA3c|Editing.ZERO_FILL;
+        ed_lat = Editing.SEXA3c|Editing.ZERO_FILL|Editing.SIGN_EDIT;
+    }
+
+  /**
+   * Instanciate an ICRS frame
+  **/
+    public ICRS() {
+	this(2000.);
+    }
+
+  /**
+   * Instanciate an ICRS frame
+   * @param text the default epoch, e.g. "J1991.25"
+  **/
+    public ICRS(String text) throws ParseException {
+        this();
+        Astrotime t = new Astrotime();
+        int o = t.parse(text, 0);
+        if (o > 0) 		// Epoch expressed in Julian years
+	    epoch = t.getJyr();
+	while (o<text.length() && Character.isWhitespace(text.charAt(o))) o++;
+	if (o<text.length()) throw new ParseException
+	    ("****Astroframe: '" + text + "'+" + o, o);
+    }
+
+   // ===========================================================
+   // 			Convert To/From ICRS
+   // ===========================================================
+
+  /**
+   * Get the conversion to ICRS matrix
+   * @return Indentity matrix
+  **/
+    public double[][] toICRSmatrix() {
+	return(Coo.Umatrix3);
+    }
+
+  /**
+   * Convert the position to its ICRS equivalent.
+   * @param coo on input the position in this frame; on ouput the ICRS
+  **/
+    public void toICRS(Coo coo) {
+	// Nothing to do !
+    }
+
+  /**
+   * Convert the position from the ICRS frame.
+   * @param coo on input the ICRS position, on output its local equivalent
+  **/
+    public void fromICRS(Coo coo) {
+	// Nothing to do !
+    }
+
+  /**
+   * Convert the position to its ICRS equivalent.
+   * @param u a 6-vector
+  **/
+    public void toICRS(double[] u) {
+	// Nothing to do !
+    }
+
+  /**
+   * Convert the position from the ICRS frame.
+   * @param u a 6-vector
+  **/
+    public void fromICRS(double[] u) {
+	// Nothing to do !
+    }
+
+}
Index: aladin/cds/astro/Mtype.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Mtype.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,542 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+import java.io.*;
+
+/**
+ * @author Marc Wenger/CDS
+ * @version 1.0
+ * @version 1.1 Jan 2004 (BB) ajout de la methode equals.
+ */
+
+/*++++++
+.PURPOSE Converts a string containing a morphological class to a long integer;
+.RETURNS -1 for error, 0 for completely coded string, 1 if incomplete
+.REMARKS If an error is encountered, message logged.
+--------*/
+
+public class Mtype implements Serializable {
+	private static final int MT_miss = 0x100;
+	private static final int MT_u1 = 0x2000;
+	private static final int MT_u2 = 0x20;
+	private static final int MT_p = 0x10;
+	private static final int MT_r = 0x08;
+	private static final int MT_s = 0x04;
+	private static final int MT_D = 0x02;
+	// Sequence of Spiral Galaxies
+	private static final String sspiral = "0abcdm";
+	private static final char[] digits = {
+		'0','1','2','3','4','5','6','7','8','9'};
+
+	int mt;
+	String str;
+	int pos, lgstr;
+	char cc;
+	char colon;
+	int incomplete, barred, format;
+
+	public Mtype() {
+		mt = 0x80800000;
+	}
+	public Mtype(String str) {
+		set(str);
+	}
+
+	/**
+	 * Sets the coded value of a string representing a morphological type
+	 *
+	 */
+	public int set(String str) {
+		this.str = str;
+		lgstr = str.length();
+		pos = 0;
+
+		int m1, m2;
+		int	mp=0, second=0;
+		incomplete = 0;
+
+		// Check first if deVaucouleurs / Hubble
+		nextChar();
+		if (Character.isDigit(cc))
+			m1 = getDV();
+		else if (Character.isLetter(cc))
+			m1 = getHubble();
+		else if (Character.isDigit(followingChar()))
+			m1 = getDV();
+		else
+			m1 = getHubble();
+
+		// Undefined type is universal..
+		if (m1 == -128)
+			format = 0;
+
+		// Save Pecularities
+		mp = (barred << 14) | (format << 10);
+		if (colon != '\0')	mp |= MT_u1;
+		barred = colon = 0;
+
+		 /* Get Second Type, if any	*/
+
+		m2 = -128; second = 0;
+		if (cc == '+')	{
+			mp |= 0x1000;
+			second = 1;
+			nextChar();
+		} else if (cc == '/')	{
+			second = 1;
+			nextChar();
+		}
+
+//		if (second == 1 && format == 2) {
+		if (second == 1 && Character.isLetter(cc)) {
+			// Only for Hubble type
+			if (colon != '\0')	mp |= MT_u2;
+			m2 = getHubble();
+				/* m2 = (format == 2 ? get_hubble() : get_dV()); */
+			if (barred != 0) mp |= (barred << 6);
+			if (colon != 0)
+				mp |= MT_u2;
+		}
+
+		// Pecularities
+
+		while(cc != '\0') {
+			switch(Character.toLowerCase(cc)) {
+				case 'p':
+					mp |= MT_p;
+					match("peculiar");
+					break;
+				case 'r':
+					mp |= MT_r;
+					break;
+				case 's':
+					mp |= MT_s;
+					break;
+				case 'd':
+					mp |= MT_D;
+					if (followingChar() == 'b')
+						match("dble");
+					else
+						match("double");
+					break;
+				default:
+					mp |= MT_miss;
+					break;
+			}
+			nextChar();
+		}
+
+		if (incomplete != 0)
+			mp |= MT_miss;
+		mt = (m1 << 24) | ((m2&0xff)<<16) | (mp&0xffff);
+		/*
+		  if (Str.error)
+			 mp = -1;
+		*/
+//		return (mp & MT_miss) == 0 ? 0 : 1;
+		return (mp & MT_miss);
+	}
+
+	public int get() {
+		return mt;
+	}
+
+	/**
+	 * Edits a coded morphological type
+	 * @return the edited morphological type
+	 */
+
+	public String toString() {
+		StringBuffer s = new StringBuffer(24);
+		int	m;
+
+		format = (mt >> 10) & 3;
+		barred = (mt >> 14) & 3;
+		if (mt == 0x80800000)	return("");
+
+		m = mt >> 24;
+		if   (m == -128) s.append('?');
+		else if (format < 2)	s.append(edDV (m, format));
+		else s.append(edHubble(m));
+		if ((mt & MT_u1) != 0)	s.append(':');
+
+		format = 0;
+		barred = (mt >> 6) & 3;
+		m = (mt << 8) >> 24;
+		if ((mt & 0x1000) != 0) s.append('+');
+		else if (m != -128)	s.append('/');
+		if (m != -128)	s.append(edHubble(m));
+		if ((mt & MT_u2) != 0)	s.append(':');
+
+		//	Now, edit Pecularities
+
+		if ((mt & MT_r) != 0)	s.append('r');
+		if ((mt & MT_s) != 0)	s.append('s');
+		if ((mt & MT_p) != 0)	s.append('p');
+		if ((mt & MT_D) != 0)	s.append('D');
+		if ((mt & MT_miss) != 0)	s.append("...");
+
+		return(s.toString());
+}
+
+	/**
+	 * Get next char (skip blanks), and translate special symbols () :
+	 * I (Irregular) may be written I or Irr
+	 * @return The char, 0 when NULL
+	 */
+	private char nextChar() {
+		while (pos < lgstr) {
+			cc = str.charAt(pos++);
+			switch (cc) {
+				case ' ': case '\t':
+					continue;
+				case ',':
+					continue;
+				case '(':
+					continue;
+				case ')': case ':':
+					colon = cc;
+					continue;
+				case 'I':
+					if (pos+1 < lgstr &&
+						 str.charAt(pos) == 'r' && str.charAt(pos+1) == 'r') pos += 2;
+					break;
+				case '.':
+					if (pos+1 < lgstr &&
+						 str.charAt(pos) == '.' && str.charAt(pos+1) == '.') {
+						pos += 2;
+						incomplete = 1;
+						continue;
+					}
+					break;
+				default:
+					//pos++;
+			}
+			return cc;
+		}
+		cc = '\0';
+		return cc;
+	}
+
+	private char followingChar() {
+		return pos < lgstr ? str.charAt(pos) : '\0';
+	}
+
+	/**
+	 * Looks for a specific string in the main analysed string
+	 * it is assumed that s[0] == cc
+	 */
+	private int match(String s) {
+		int i,j;
+		for (i=pos, j=1; i<lgstr && j<s.length(); i++,j++) {
+			if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(s.charAt(j)))
+				 break;
+		}
+		pos += (i-pos);   // skip the matched letters
+		return j-1;
+	}
+
+	/**
+	 * Returns the Hubble code of a morph. type
+	 */
+	private int getHubble() {
+		int	mt, i;
+		char old_colon;
+
+		format = 2;			/* It'a s Hubble type	*/
+		colon = '\0';
+		barred = 0;
+		mt = -128;				/*     Default 	*/
+
+		switch(cc) {
+			case '?':
+				nextChar();	/* NO break	*/
+			case 0:
+				break;
+			case 'c':	case 'C':	/* Compact */
+			case 'd':  	case 'D':	/* Dwarf (or double?)  */
+				if (cc == 'c' || cc == 'C') {
+					// compact
+					match("compact");
+					mt = -60;
+				} else {
+					// dwarf ou double (dble)
+					if (str.charAt(pos) == 'o' || str.charAt(pos) == 'b')	break;
+					mt = -50;
+				}
+				// [compact] dwarf   Followed by E / G / Irr
+				match("dwarf");
+				nextChar();
+				switch(cc) {
+					case 'E':
+						nextChar();
+						break;
+					case 'G':
+						nextChar();
+					default:
+						mt -= 5;
+						break;
+					case 'I':
+						nextChar();
+						mt = 80 - mt/2;
+						break;
+				}
+				break;
+			case 'E':	/*Elliptical	*/
+				mt = -40;
+				nextChar(); 	break;
+			case 'L':	/* Lenticular	*/
+				mt = -20;
+				nextChar(); 	break;
+			case 'S':	/* Spiral	*/
+				nextChar();
+				if (cc == 'B')	{	/* Barred Spiral	*/
+					old_colon = colon;	colon = 0;
+					barred = 1;	nextChar();
+					if (colon != '\0') 	barred = 2;
+					colon = old_colon;
+				}
+				// sspiral = une String, + indexOf(char)
+				if ((i = sspiral.indexOf(cc)) >= 0) {
+					nextChar();
+					mt = i*20 - 10;
+					if (i+1 < sspiral.length() && sspiral.charAt(i+1) == cc) {
+						nextChar();
+						mt += 10;
+					}
+					if (mt < 0)	mt = -20;	/* Only for S0	*/
+				}
+				else mt = 45;			/* S alone ...	*/
+				break;
+			case 'I':	/* Irregular	*/
+				nextChar();	mt = 100;
+				if (cc == 'm') {
+					nextChar();
+					mt = 101;
+				}
+				break;
+			default:	/* May be a pecularity	*/
+				break;
+		}
+	//	System.out.println("....get_hubble returns "+mt);
+		return(mt);
+	}
+
+	/**
+	 * Converts the string to deVaucouleurs... + Bar.
+	 * @return the class
+	 */
+	private int getDV() {
+		int sign, mt;
+		char old_colon;
+
+		mt = 0;
+		sign = format = barred = 0;
+		colon = '\0';
+
+		if (cc == '-')	{
+			nextChar();
+			sign = 1;
+		}
+		while (Character.isDigit(cc)) {
+			mt = mt*10 + (cc-'0');
+			nextChar();
+		}
+
+		mt *= 10;
+		if (cc == '.' && str.charAt(pos) != '.') {
+			/* There is a decimal */
+			nextChar();
+			format = 1;
+			mt += (cc - '0');
+			nextChar();
+		}
+		if (sign == 1)	mt = -mt;
+
+		if (cc == 'B')	{
+			/* Barred Spiral	*/
+			old_colon = colon;
+			colon = 0;
+			barred = 1;
+			nextChar();
+			if (colon != 0) 	barred = 2;
+			colon = old_colon;
+		}
+
+		// Check that mt is in correct interval
+/*
+	 if (mt <= -70)	error("deVaucouleurs Type too small", p);
+	 if (mt >  110)	error("deVaucouleurs Type too large", p);
+*/
+//		System.out.println("....get_dV returns "+mt);
+		return mt;
+	}
+
+	/**
+	 * Edit de Vaucouleurs morphological type
+	 * @param mt morphological type (-128 / 127)
+	 * @param nd Number of decimals (0 or 1)
+	 * @return Edited string
+	 */
+	private String edDV(int mt, int nd) {
+		StringBuffer s = new StringBuffer(8);
+		if (mt <= -128)
+			return "";
+
+		if (mt >= 100)	s.append('1');
+		else if (mt < 0)	{
+			s.append('-');
+			mt = -mt;
+		}
+		else s.append(' ');
+
+		mt %= 100;
+		s.append(digits[mt/10]);
+		if (nd > 0) {
+			s.append('.');
+			s.append(digits[mt % 10]);
+		}
+		if (barred != 0)  {
+			s.append('B');
+			if ((barred & 2) != 0) s.append(':');
+		}
+		return (s.toString());
+	}
+
+
+	/**
+	 * Edit Hubble morphological type
+	 * @param mt Morphological type (-128 / 127)
+	 * @return Edited string
+	 */
+	private String edHubble(int mt) {
+		StringBuffer s = new StringBuffer(24);
+		int i, k, bar;
+
+		if (mt <= -128)
+			return "";
+
+		bar = barred;
+
+		if (mt >= -20 && mt <= 90)   {	/* Spiral Galaxies */
+			i = (mt < 0 ? 0 : mt+10);
+			s.append('S');
+			if (bar > 0)  {
+				s.append('B');
+				if ((bar & 2) != 0) s.append(':');
+				bar = 0;
+			}
+			if (i != 55) {
+				k = i/20;
+				s.append(sspiral.charAt(k));
+				switch (i%20) {
+					case 0: break;
+					case 10: s.append(sspiral.charAt(k+1)); break;
+					default: s.append('?'); break;
+				}
+			}
+		} else if (mt == -40) {
+			s.append('E');
+		} else if (mt <= -50) {
+			k = -50 - mt;
+			s.append(k/10 != 0 ? 'c' : 'd');
+			s.append(k%10 != 0 ? 'G' : 'E');
+			if (k%5 != 0 || k > 15) s.append('?');
+		}
+		else if (mt == 100)	s.append('I');
+		else if (mt == 101)	s.append("Im");
+		else if (mt == 105)	s.append("dI");
+		else if (mt == 110)	s.append("cI");
+		else	s.append('?');
+
+		if (bar != 0)  {
+			s.append('B');
+			if ((bar & 2) != 0) s.append(':');
+		}
+
+		return s.toString();
+}
+
+	public static void main(String[] args) {
+		String str = null;
+		BufferedReader rdr = null;
+		boolean stdin = true;
+		int ctlig = 0;
+
+		if (args.length == 0)
+//		if (true)
+			rdr = new BufferedReader(new InputStreamReader(System.in));
+		else {
+			try {
+				rdr = new BufferedReader(new InputStreamReader(
+						new FileInputStream(args[0])));
+			} catch (Exception e) {
+				System.err.println("Open file error: "+e);
+			}
+			stdin = false;
+		}
+		while (true) {
+			if (stdin) System.out.print("morph type :");
+			try {
+				str = rdr.readLine();
+			} catch (IOException e) {}
+			if (str == null || str.compareTo("fin") == 0) break;
+			ctlig++;
+			Mtype mtyp1 = new Mtype(str);
+			String str1 = mtyp1.toString().trim();
+			Mtype mtyp2 = new Mtype(str1);
+			String str2 = mtyp2.toString().trim();
+			if (stdin) System.out.println(str+" -> "+str1+" -> "+str2);
+			else {
+				if (str.compareTo(str1) != 0 || str1.compareTo(str2) != 0)
+					System.out.println("Err ligne "+ctlig+" : "+str+" -> "+str1+" -> "+str2);
+//				else
+//					System.out.println("Ok  ligne "+ctlig+" : "+str+" -> "+str1+" -> "+str2);
+			}
+		}
+	}
+
+        /**
+   * MOD-BB 21-01-04 Ajout de cette methode.
+   * Comparaison de Mtype.
+   * @param o Objet a comparer.
+   * @return Vrai si o est identique a this, faux sinon.
+   */
+   public boolean equals(Object o)
+   {
+     boolean res = false;
+     if(o instanceof Mtype)
+     {
+       Mtype m = (Mtype)o;
+       res = m.barred == this.barred &&
+           m.cc == this.cc &&
+           m.colon == this.colon &&
+           m.format == this.format &&
+           m.incomplete == this.incomplete &&
+           m.lgstr == this.lgstr &&
+           m.mt == this.mt &&
+           m.pos == this.pos &&
+           (m.str == null ? this.str == null : m.str.equals(this.str));
+     }
+     return res;
+   }
+
+}
\ No newline at end of file
Index: aladin/cds/astro/Otype.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Otype.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,780 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                Otype class (includes also Odef)
+ *==================================================================*/
+
+import java.io.*;
+import java.net.*;
+import java.util.*;
+import java.text.*; // for parseException
+
+//import com.braju.format.Parameters;
+//import com.braju.format.Format;
+
+/**
+ * The <em>Otype</em> is a classification of the astronomical objects
+ * in a hierarchical structure.
+ * 
+ * @author	Francois Ochsenbein
+ * @author      Benoit Baranne (Stagiaire UTBM)
+ * @version 1.0	16-sep-2002<br>
+ *          1.1 29-oct-2002 (Sylvaine Jaehn (Stage UTBM)) : 
+ *          	ajout de la methode numericToHexa()<br>
+ *          1.2 14-nov-2002 (SJ):   ajout du test : 
+ *            if (!initialized) init(); ds constructeur otype sans parametre<br>
+ *               ajout de la methode hexaToNumeric(String strHex)<br>
+ *          1.3 24-jan-2003 (SJ) :   methode init() mise public<br>
+ * @version 1.4 jan 2004 (BB) : ajout de la methode equals.
+ * -------------
+ *
+ **/
+
+public class Otype implements Serializable {
+
+    // The Otype is just a number -- the bits are arranged to map to
+    // the hierarchical structure.
+    public int otype; // The Otype is just a number!!
+    
+    // Variables common to the Class: all Definitions
+    static final boolean DEBUG = true;
+    static boolean initialized = false;
+    static private final int B0 = 4; // Wavelength
+    static private final int B1 = 4; // Main Class
+    static private final int B2 = 5; // Subclass
+    static private final int B3 = 4; // Nova/SN
+    static private final int Bf = 15; // Not Yet Used
+    static private final char[] dig = "0123456789".toCharArray();
+    static private final int[] bits = {
+    	B0, B1, B2, B3, Bf};
+    static private final int[] Nt = {
+    	(1 << B0) - 1, 
+    	(1 << B1) - 1, 
+    	(1 << B2) - 1, 
+    	(1 << B3) - 1, 
+    	(1 << Bf) - 1};
+    static private final int[] Nlev = new int[bits.length + 1];
+    //  0, 0xf0000000, 0xff000000,		// Levels 0 1 2
+    //  0xfff80000, 0xffff8000, 0xffffffff	// Levels 3 4 5
+    static private Hashtable Hsymbols = new Hashtable(300);
+    static private Vector otypes = new Vector(200);
+    static private Vector otrees = new Vector(100);
+    // static private final String def_url = 
+    // 	"http://simbad.u-strasbg.fr/otype.def";
+    static private final String def_url =
+    	"http://localhost:2001/Tables/Otype/otype.def";
+
+    /*==================================================================*
+     			Constructors
+     *==================================================================*/
+    
+    /** Define the default Otype (object of unknown nature)
+     */
+    public Otype() {
+    	if (!initialized) {
+    		init();
+    	}
+    	otype = 0;
+    }
+    
+    /** Define the Otype from a String
+     * @param text the Otype as a string
+     * @throws ParseException when otype is not understandable
+     */
+    public Otype(String text) throws ParseException {
+    	set(text);
+    }
+    
+    /*==================================================================*
+     	Upload the list of Object Types
+     *==================================================================*/
+    /** Insert a definition -- verify it's not alreay in
+     * @param	symb the symbol of this object type
+     * @param	odef the object type definition
+     * @return	the previously defined level
+     **/
+    private static void hadd(String symb, Odef odef) {
+    	String s = symb.toLowerCase();
+    	Object o = Hsymbols.put(s, odef);
+    	if (o != null) {
+    		if (odef.equals(o)) {
+    			return;
+    		}
+    		System.err.println("****Otype: '" + symb + "' ambiguous: "
+				 + odef + " <> " + (Odef) o);
+    	}
+    }
+    
+    /** Read the List of the Object Types
+     * @param	plug the input stream
+     * @return	the previously defined level
+     **/
+    private static void upload(BufferedReader plug) {
+    	//File odef = new File("otype.def");
+    	String s1, s2, s3;
+    	Odef odef; // An Object Type
+    	char[] a;
+    	String line;
+    	int i, o, k;
+    	o = 0xffffffff;
+    	i = bits.length;
+    	while (i > 0) {
+    		Nlev[i] = o;
+    		o <<= bits[--i];
+    	}
+    	Nlev[0] = 0;
+    	while (true) {
+    		try {
+    			line = plug.readLine();
+    		}
+    		catch (Exception e) {
+    			System.err.println(e);
+    			return;
+    		}
+    		if (line == null) {
+    			break;
+    		}
+    		if (line.length() < 10) {
+    			continue;
+    		}
+    		a = line.toCharArray();
+    		if (a[0] == '#') {
+    			continue; // comment
+    		}
+    		if (a[0] == '-') {
+    			continue; // ignored
+    		}
+    		if (a[0] == '(') {
+    			continue; // ignored
+    		}
+    		if (a[0] == '+') {
+    			continue; // ignored
+    		}
+    		for (i=0; (i < a.length) && Character.isWhitespace(a[i]); i++);
+    		if (i >= a.length) {
+    			continue;
+    		}
+    		//if (DEBUG) System.out.println("Got: " + line);
+    		// Find the ':' which defines Synonyms
+    		k = i;
+    		while ( (i < a.length) && (a[i] != ':') && (a[i] != '/')) {
+    			i++;
+    			/* Interpret the line: numeric type / equivalences */
+    		}
+    		if (Character.isDigit(a[k])) {
+    		    /* Here the line is like
+    		      00.00.00.0: Unknown     ?    "Object of unknown nature"
+    		    --------------------------------------------------------*/
+    			o = ntype(new String(a, k, i - k));
+    			if (i < a.length) {
+    				i++; // Skip the :
+    			}
+    			while ( (i < a.length) && Character.isSpaceChar(a[i])) {
+    				i++;
+    			}
+    			k = i;
+    			while ( (i < a.length) && (!Character.isSpaceChar(a[i]))) {
+    				i++;
+    			}
+    			s1 = new String(a, k, i - k);
+    			while ( (i < a.length) && Character.isSpaceChar(a[i])) {
+    				i++;
+    			}
+    			if ( (i < a.length) && (a[i] != '"')) { // "
+    				k = i;
+    				while ( (i < a.length) && (!Character.isSpaceChar(a[i]))) {
+    					i++;
+    				}
+    				s2 = new String(a, k, i - k);
+    				while ( (i < a.length) && Character.isSpaceChar(a[i])) {
+    					i++;
+    				}
+    			}
+    			else {
+    				s2 = s1; // The 3-letter abbreviation
+    			}
+    			if ( (i < a.length) && (a[i] == '"')) { // "
+    				k = ++i;
+    				while ( (i < a.length) && (a[i] != '"')) {
+    					i++; // "
+    				}
+    				s3 = new String(a, k, i - k);
+    				if (i < a.length) {
+    					i++;
+    				}
+    				while ( (i < a.length) && Character.isSpaceChar(a[i])) {
+    					i++;
+    				}
+    			}
+    			else {
+    				s3 = s2;
+    			}
+    			odef = new Odef(o, s1, s2, s3);
+    			otypes.addElement(odef);
+    			hadd(s1, odef);
+    			if (s2 != s1) {
+    				hadd(s2.trim(), odef);
+    			}
+    			if (s3 != s2) {
+    				hadd(s3, odef);
+    				/* Are there other synonyms ? */
+    			}
+    			while (i < a.length) {
+    				k = i;
+    				while ( (i < a.length) && (!Character.isSpaceChar(a[i]))) {
+    					i++;
+    				}
+    				s3 = new String(a, k, i - k);
+    				hadd(s3, odef);
+    				while ( (i < a.length) && Character.isSpaceChar(a[i])) {
+    					i++;
+    				}
+    			}
+    			continue;
+    		}
+    		if (i >= a.length) {
+    			continue; // Empty Line
+    		}
+    		s1 = new String(a, k, i - k);
+    		s1 = s1.trim();
+    		k = i + 1; // Second part
+    		s2 = new String(a, k, a.length - k);
+    		s2 = s2.trim();
+    		//if(DEBUG) System.out.println("....additional: " + s1 + a[i] + s2);
+    		if (a[i] == ':') { // There is a : ==> Synonym
+    			hadd(s1, (Odef) Hsymbols.get(s2.toLowerCase()));
+    			continue;
+    		}
+    		if (a[i] == '/') { // There is a / ==> Subtree
+    			otrees.addElement(Hsymbols.get(s1.toLowerCase()));
+    			otrees.addElement(Hsymbols.get(s2.toLowerCase()));
+    		}
+    	}
+    	initialized = true;
+    	otypes.trimToSize();
+    	otrees.trimToSize();
+    	/*if (DEBUG) System.out.println("....Otype init: " + otypes.size()
+    	  + "otypes, " + otrees.size() + "subtrees, " + Hsymbols.size()
+    	  + "symbols");*/
+    }
+
+    /*==================================================================*
+     		Initialisations
+     *==================================================================*/
+
+    /** Initialisation
+     */
+    public static void init() {
+    	DataInputStream plug;
+    	URL odef;
+    	System.out.println("---> Otype.init() sans parametres appele");
+
+    	try {
+    		odef = new URL(def_url);
+    		plug = new DataInputStream(odef.openStream());
+    		upload(new BufferedReader(new InputStreamReader(plug)));
+    	}
+    	catch (Exception e) {
+    		System.err.println(e);
+    	}
+    }
+
+    /** Initialisation
+     * @param	filename name of file with the list of Object Types
+     * @throws Exception e.g. IOException if file not existing, parsing...
+     */
+    public static void init(String filename) throws Exception {
+    	File odef;
+    	FileInputStream plug;
+    	odef = new File(filename);
+    	plug = new FileInputStream(odef);
+    	upload(new BufferedReader(new InputStreamReader(plug)));
+    }
+
+    /** Compute the level in the hierarchy
+     * @param	otype an object type
+     * @return	the level (0 1 2 3 4)
+     **/
+    private static final int level(int otype) {
+    	int i;
+    	for (i = 0; otype != 0; otype <<= bits[i++]) ;
+    	return (i);
+    }
+
+    /** Test whether ot is in class cl
+     * @param	cl a 'class'
+     * @param	ot a 'subclass'
+     * @return	true if ot if subclass of cl
+     **/
+    private static final boolean otinclass(int cl, int ot) {
+    	int i = level(cl);
+    	return ( (ot & Nlev[i]) == cl);
+    }
+
+    /*==================================================================*
+     			Internal Routines
+     *==================================================================*/
+
+    /** Edit the otype as xx.xx.xx.xx
+     * @param	buf the buffer to which the ascii equivalent of otype
+     *			is appended.
+     * @param	otype the object type
+     * @return	the previously defined level
+     **/
+    protected static void edit(StringBuffer buf, int otype) {
+    	int[] otc = new int[4];
+    	int o = otype >>> Bf;
+    	int i;
+    	for (i = bits.length - 1; --i >= 0; o >>>= bits[i]) {
+    		otc[i] = o & Nt[i];
+    	}
+    	for (i = 0; i < 4; i++) {
+    		buf.append(dig[otc[i] / 10]);
+    		buf.append(dig[otc[i] % 10]);
+    		buf.append('.');
+    	}
+    	i = buf.length();
+    	buf.setLength(i - 1);
+    }
+
+    /** Interpret the 4 numbers as an Otype class.
+     * @param	s the text to interpret
+     * @return	The object type / -1 when error
+     **/
+    private static final int ntype(String s) {
+    	char a[] = s.toCharArray();
+    	int ot = 0;
+    	int i, h, n;
+    	for (i = 0, h = 0; (i < a.length) && (h < bits.length); h++) {
+    		ot <<= bits[h];
+    		if (a[i] == '.') {
+    			i++;
+    		}
+    		for (n = 0; (i < a.length) && Character.isDigit(a[i]); i++) {
+    			n = (n * 10) + Character.digit(a[i], 10);
+    		}
+    		if (n >= (1 << bits[h])) {
+    			return ( -1);
+    		}
+    		ot |= n;
+    	}
+    	while (h < bits.length) {
+    		ot <<= bits[h++];
+    	}
+    	return (ot);
+    }
+
+    /** Verify the number corresponds to an existing Otype
+     * @throws ParseException when the otype is incorrect
+     */
+    private final void verify() throws ParseException {
+    	Odef o = new Odef(otype, null, null, null);
+    	if (otypes.indexOf(o) < 0) {
+    		throw new ParseException
+    		("****Otype: invalid number to assignation: " + otype, 0);
+    	}
+    }
+
+    /*==================================================================*
+     Manipulation of Otypes
+     *==================================================================*/
+
+    /** Truncate the otype to some upper level (e.g. Algol --> V*)
+     * @param	lev the level (between 1 and 4)
+     **/
+    public final void truncate(int lev) {
+    	if (!initialized) {
+    		init();
+    	}
+    	if (lev < 0) {
+    		lev = 0;
+    	}
+    	if (lev > bits.length) {
+    		lev = bits.length;
+    	}
+    	otype &= Nlev[lev];
+    }
+
+    /** Check if is a subtype (in same branch)
+     * @param	t1 the other Otype
+     * @return	true t1 is an upper class
+     **/
+    public final boolean implies(Otype t1) {
+    	return (implies(otype, t1.otype));
+    }
+
+    /**
+     * Checks whether t0 implies t1
+     * @param t0 first otype
+     * @param t1 second otype
+     * @return true if t0 implies t1
+     */
+    private static final boolean implies(int t0, int t1) {
+    	int lev;
+    	if (!initialized) {
+    		init();
+    	}
+    	lev = level(t1);
+    	return ( (t0 & Nlev[lev]) == t1);
+    }
+
+    /** Check if the 2 Otypes are compatible
+     * @param	ot1 the other Otype
+     * @return	true t1 is compatible
+     **/
+    public final boolean agrees(Otype ot1) {
+    	Otype type, clas;
+    	int i;
+    	Odef o;
+    	if (ot1.otype == otype) {
+    		return (true);
+    	}
+    	// Order in clas (less accurate) / type (more accurate)
+    	type = merge(ot1);
+    	clas = ot1 == type ? this : ot1;
+    	if (type.implies(clas)) {
+    		return (true);
+    	}
+    	for (i = 0; i < otrees.size(); i += 2) {
+    		o = (Odef) otrees.elementAt(i);
+    		if (!implies(type.otype, o.otype)) {
+    			continue;
+    		}
+    		o = (Odef) otrees.elementAt(i + 1);
+    		if (implies(o.otype, clas.otype)) {
+    			return (true);
+    		}
+    	}
+    	return (false);
+    }
+
+    /** Choose the most accurate Otype: the deepest one ine the hierarchy.
+     * @param	ot1 a second otype
+     * @return	the 'most accurate' otype
+     **/
+    public final Otype merge(Otype ot1) {
+    	int lev, lev1;
+    	if (!initialized) {
+    		init();
+    	}
+    	lev = level(otype);
+    	lev1 = level(ot1.otype);
+    	/* The otype should be UNSIGNED --- but unsigned int in not
+    	 known in Java. Therefore compare the right-shifted values
+    	 */
+    	if (lev == lev1) {
+    		return
+    			( (otype >>> 1) > (ot1.otype >>> 1) ? this : ot1);
+    	}
+    	if (lev < lev1) {
+    		return (ot1);
+    	}
+    	return (this);
+    }
+
+    /*==================================================================*
+     		Setting an Otype from input details
+     *==================================================================*/
+
+    /** Convert an integer into an Otype
+     * @param	o a number representing an otype
+     * @throws ParseException when the text can' be interpreted.
+     **/
+    protected final void set(int o) throws ParseException {
+    	if (!initialized) {
+    		init();
+    	}
+    	otype = o;
+    	verify();
+    }
+
+    /** Convert a text into an object type
+     * @param	text the text representing the otype, either in numeric,
+     *		or as one of the available abbreviations
+     * @throws ParseException when the text can' be interpreted.
+     **/
+    public final void set(String text) throws ParseException {
+    	Odef odef;
+    	if (!initialized) {
+    		init();
+    	}
+    	odef = (Odef) Hsymbols.get(text.toLowerCase());
+    	if (odef != null) {
+    		otype = odef.otype;
+    	}
+    	else if (text.length() < 1) {
+    		otype = 0;
+    	}
+    	else if (Character.isDigit(text.charAt(0))) {
+    		otype = ntype(text);
+    		verify();
+    	}
+    	else {
+    		throw new ParseException("****Otype: " + text, 0);
+    	}
+    }
+
+    /*==================================================================*
+     		Give the list of Otypes
+     *==================================================================*/
+
+    /** List in an enumeration all Otypes belonging to a class.
+     * @return	An enumeration of Otypes in subtree
+     **/
+    public Enumeration list() {
+    	return new Enumeration() {
+    	    int o = otype; // Current otype
+    	    int mask = 0;
+    	    int pos = -1; // Index in otypes
+    	    int ori = otype; // Originally asked type
+    	    int omask = 0; // Mask corresponding to original type
+    	    int inc = 1; // Index in otrees
+    	    public boolean hasMoreElements() {
+    	    	Odef odef;
+    	    	//if(DEBUG) System.out.println("....hasMore(class=" + o 
+		//   + ") pos=" + pos + ", inc=" + inc);
+    	    	if (pos < 0) {
+    	    		if (!initialized) {
+    	    			init();
+    	    		}
+    	    		odef = new Odef(o, null, null, null);
+    	    		pos = otypes.indexOf(odef);
+    	    		omask = mask = Nlev[level(o)];
+    	    		return (pos >= 0);
+    	    	}
+    	    	if (pos < otypes.size()) {
+    	    		odef = (Odef) otypes.elementAt(pos);
+    	    		if ( (odef.otype & mask) == o) {
+    	    			return (true);
+    	    		}
+    	    	}
+    	    	// Are there subtrees ? [0]=subtree [1]=class
+    	    	while (inc < otrees.size()) {
+    	    		odef = (Odef) otrees.elementAt(inc);
+    	    		if ( (odef.otype & omask) == ori) {
+    	    			break;
+    	    		}
+    	    		inc += 2;
+    	    	}
+    	    	if (inc >= otrees.size()) {
+    	    		return (false);
+    	    	}
+    	    	odef = (Odef) otrees.elementAt(inc - 1);
+    	    	pos = otypes.indexOf(odef);
+    	    	o = odef.otype;
+    	    	mask = Nlev[level(o)];
+    	    	inc += 2;
+    	    	return (true);
+    	    }
+
+    	    public Object nextElement() {
+    	    	Odef odef;
+    	    	Otype e;
+    	    	odef = (Odef) otypes.elementAt(pos);
+    	    	e = new Otype();
+    	    	e.otype = odef.otype;
+    	    	pos++;
+    	    	return (e);
+    	    }
+    	};
+    }
+
+    /*==================================================================*
+      			Edition
+     *==================================================================*/
+
+    /** Default Edition of the Otype value
+     * @param	choice 0=numeric, 1=standard, 2=verbose, 3=3-letter
+     * @return	the meaning of the Object Type
+     */
+    public final String toString(int choice) {
+    	Odef o;
+    	int i;
+    	if (choice == 0) {
+    		StringBuffer b = new StringBuffer(40);
+    		edit(b, otype);
+    		return ("" + b);
+    	}
+    	o = new Odef(otype, null, null, null);
+    	//if(DEBUG) o.dump();
+    	i = otypes.indexOf(o);
+    	//for (i=0; i<otypes.size() ; i++) {
+    	//   System.out.println(o.equals((Odef)otypes.elementAt(i)));
+    	//}
+    	o = (Odef) otypes.elementAt(i);
+    	if (choice == 1) {
+    		return (o.symb);
+    	}
+    	if (choice == 2) {
+    		return (o.expl);
+    	}
+    	if (choice == 3) {
+    		return (o.abbr);
+    	}
+    	return (null);
+    }
+
+    /** 
+     * Default Edition of the Otype value
+     * @return	the "standard" explanation of hte object type
+     **/
+    public final String toString() {
+    	return (this.toString(1));
+    }
+
+    /** 
+     * Dump contents to stdout
+     * @return	the "standard" explanation of hte object type
+     **/
+    public final void dump() {
+    	System.out.println("....Otype: " + Integer.toHexString(otype));
+    }
+
+    /**
+     * Methode qui permet de transformer un otype decimal en hexadecimal
+     * @return chaine representant la valeur de otype en hexadecimal
+     */
+    public String numericToHexa() {
+    	StringBuffer str = new StringBuffer();
+    	StringTokenizer st = new StringTokenizer(this.toString(0), ".");
+    	while (st.hasMoreTokens()) {
+    		String shex = Integer.toHexString(Integer.parseInt(st.nextToken()));
+    		if (shex.length() == 1) {
+    			shex = "0" + shex;
+    		}
+    		str.append(shex);
+//			Parameters p = new Parameters();
+//			str.append(Format.sprintf("%02x",p.add(Integer.parseInt(st.nextToken()))));
+    	}
+    	return str.toString();
+    }
+
+    /**
+     * Methode qui transforme une chaine de caractere hexadecimale en otype sous forme numerique
+     * @param strHex chaine representant un otype sous forme hexadecimale
+     * @return otype sous forme numerique
+     */
+    public static String hexaToNumeric(String strHex) {
+    	StringBuffer strtmp = new StringBuffer(strHex);
+    	StringBuffer str = new StringBuffer();
+
+    	if (strHex.compareTo("0") == 0) {
+    		str.append("00.00.00.00");
+    	}
+    	else {
+    		if (strHex.charAt(0) != '0') {
+    			strtmp.insert(0, "0");
+    		}
+    		for (int i = 0; i < strtmp.length(); i += 2) {
+    			str.append(Integer.parseInt(String.valueOf(strtmp.substring(i,
+    				i + 2)), 16)).append("."); //Chaque caractere hexa est transforme en decimal
+    		}
+    		str.delete(str.length() - 1, str.length());
+    	}
+
+    	return str.toString();
+    }
+
+        /**
+         * MOD-BB 21-01-04 Ajout de cette methode.
+         * Test d'egalite de Otype.
+         * @param o Objet a comparer.
+         * @return Vrai si o est identique a this, faux sinon.
+         */
+        public boolean equals(Object o)
+        {
+          boolean res = false;
+          if(o instanceof Otype)
+            res = ((Otype)o).otype == this.otype;
+          return res;
+        }
+}
+
+/**
+ * Otype Definition object
+ * This internal class defines the basic Otype symbols
+ * loaded from a file.
+ */
+class Odef implements Serializable {
+    public int otype; // The coded object type
+    public String symb; // Main symbol of the Otype
+    public String abbr; // 3-letter abbreviation of otype
+    public String expl; // Long-text of the Symbol
+
+   /**
+    * Constructor of a otype object
+    * @param o otype numeric value
+    * @param s otype symbol (short name)
+    * @param a otype abbreviation
+    * @param text otype description
+    */
+    public Odef(int o, String s, String a, String text) {
+    	//System.out.println("...Odef: " + s + " -- " + a + " -- " + text);
+    	otype = o;
+    	symb = s;
+    	expl = text;
+    	abbr = a;
+    	if (a != null) {
+    		int len = a.length();
+    		if (len < 3) {
+    			abbr = a + "   ".substring(0, 3 - len);
+    		}
+    	}
+    }
+
+   /**
+    * Comparison of 2 Otypes
+    * @param o Object for which we would like to compare the type
+    * @return true if the two otypes are identical
+   **/
+    public final boolean equals(Object o) {
+    	Odef odef = (Odef) o;
+    	//System.out.println("....Compare " + this + " / " + odef);
+    	return (otype == odef.otype);
+    }
+
+   /**
+    * Display the object type in a string
+    * @return the string containing the otype
+    */
+    public final String toString() {
+    	StringBuffer b = new StringBuffer(80);
+    	Otype.edit(b, otype);
+    	b.append(": ");
+    		if (abbr != null) {
+    		b.append(abbr);
+    		b.append(' ');
+    		b.append('(');
+    		b.append(expl);
+    		b.append(')');
+    	}
+    	return ("" + b);
+    }
+
+   /**
+    * Display for debugging purposes the otype on stdout
+    */
+    public final void dump() {
+    	System.out.println("....Otypedef: " + toString());
+    }
+}
+
Index: aladin/cds/astro/Parsing.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Parsing.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,1459 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                Parsing class
+ *==================================================================*/
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * This class interprets text and is able to convert to numbers,
+ * or find a symbol in a list of symbols. 
+ * Numbers can use <B>...&times;10+/-exp</B> as well as 
+ *                 <B>...e+/-exp</B> notation;
+ * numbers may also be expressed in sexagesimal.<P>
+ * This class returns, for the most recently analyzed number:<UL> 
+ * <LI> the number of <em>decimals</em> (-1 indicates no decimal point)
+ * <LI> the number of significant <em>digits</em> 
+ * <LI> the <em>format</em> of the number, as <tt>Parsing.DECIMAL</tt>,
+ * 	<tt>Parsing.EFORMAT</tt>, <tt>Parsing.FACTOR</tt>, or various
+ *	calendar or sexagesimal forms with the interpretation of the symbols 
+ *	<B> </tt>: Y M D h m s d o &deg;; ' "</tt></B>
+ * <LI> the <em>status</em>, currently used only in sexagesimal and
+ * 	complex parsings:
+ * 	a <tt>Parsing.WARNING</tt> indicates the last component is 60,
+ * 	while a <tt>Parsing.ERROR</tt> indicates a component &gt;60.
+ * </UL>
+ * @author Francois Ochsenbein -- francois@astro.u-strasbg.fr
+ * @version 0.7 : 07-Sep-2002 inside Unit class<br>
+ * @version 1.0 : 28-Feb-2004 separated Udef class 
+ * @version 1.1 : 10-Aug-2004 Homogenize Parsing + Editing classes
+ * @version 1.2 : 02-Sep-2006 Interpret dates
+ * @version 1.3 : 26-Oct-2006 Accept blanks after +/-; added matchingQuote
+ * 				and toString(int len)
+ */
+
+public class Parsing extends Astroformat {
+    /** The text as an array of chars */
+    public char[] a ;		// The text as an array of chars
+    /** The length of the array, can be shorter than the actual size */
+    public int length ;		// Length of text
+    /** The current position in the array */
+    public int pos ;		// Current position in text
+    /** The flags contains the status of the last parsed number.
+     * It contains the following parts:
+     * Mask 0x000000ff: number of decimals+1 (0 = no decimal point)
+     * Mask 0x0000ff00: number of significant digits (0 = no digit)
+     * Mask 0x00ff0000: format of the number, see Astroformat
+     * Mask 0x7f000000: error detected in sexagesimal:
+     * 			1 (last number equal to 60)
+     * 			2 (one value is larger than 60)
+     * 			3 (final error)
+     * Mask 0x80000000: Internally ask for a reset.
+    **/
+    private int flags;
+    /** Error message, if any (only in parseComplex) */
+    public String error_message;
+    /** The status of the last parsing operation is OK */
+    static public final int OK=0;
+    /** The last (sexagesimal) parsing has minutes or seconds equal to 60. */
+    static public final int WARNING=1;
+    /** The last (sexagesimal) parsing has a component greater than 60 */
+    static public final int ERROR=2;
+    /** Debugging level */
+    static public int DEBUG = 0;
+    ///** A terminal error encountered, error_message set */
+    //static public final int FATAL=3;
+    /** The format of the numbers are defined in parent class Astroformat */
+    /** The acceptable abbreviations for h m s.
+     * The unit is 2=: 4=deg 6=hour 1=1/60, 9=1/3600, 3=2+1, 11=9+2
+     * flag 16 for special symbol &deg; ' "
+     */
+    static private final char[] sexa_letter = { ':', 'm', 's' };
+    static private final char[] sexa_symbol = { '\u00B0', '\'', '"' };
+    static private final char[] sexa_symb1  = {
+	':', 'd', 'o', '\u00B0', 'h', 'm', 's', '\'', '"'
+    };
+    static private final byte[] sexa_unit1  = {
+	 2 ,  4 ,  4 , 16|4,  6 , 1|6, 9|6,16|5, 20|9
+    };
+    /** The different sorts of parenthesis or brackets **/
+    static private final char[] brackets = "()[]{}<>".toCharArray();
+    /** The different sorts of error matchers */
+    static private final String[] error_symb = 
+                      { "+/-", "+", "-", "\u00B1", "[" };
+
+    /*==============================================================
+                Constructors
+     *==============================================================*/
+
+    /** 
+     * Create a Parsing unit from a string
+     * @param s the text to parse
+     */
+    public Parsing(String s) {
+	this(s, 0);
+    }
+
+    /** 
+     * Create a Parsing unit from a string + offset
+     * @param s the text to parse
+     */
+    public Parsing(String s, int offset) {
+	super();
+	length = s.length();
+	a = s.toCharArray();
+	pos = offset;
+    }
+
+    /*==============================================================
+                Change the parsing contents
+     *==============================================================*/
+
+    /** 
+     * Force the position within the Parsing piece
+     * @param n the position -- if necessary, adjusted between 0 and length
+     */
+    public final void set(int n) {
+	pos = n ;
+	if (pos > a.length) pos = a.length;
+	if (pos < 0) pos = 0 ;
+    }
+
+    /** 
+     * Install a new text in the Parsing
+     * @param text the string to parse
+     */
+    public final void set(String text) {
+	a = text.toCharArray();
+	length = text.length();
+	pos = 0;
+    }
+
+    /** 
+     * Move (forward / backward) in the Parsing piece
+     * @param n the value of the step
+     */
+    public final void advance(int n) {
+	this.set(pos+n) ;
+    }
+
+    /*==============================================================
+                Interpretations of symbols
+     *==============================================================*/
+
+    /**
+     * Get the current char
+     * @return the current character in the parsing buffer.
+     */
+    public final char currentChar() {
+	if (pos >= length) return(Character.MIN_VALUE);
+	return(a[pos]);
+    }
+
+    /**
+     * Skip the spaces in the Parsing unit
+     */
+    public final void gobbleSpaces() {
+	while ((pos < length) && Character.isWhitespace(a[pos])) pos++;
+    }
+
+    /** 
+     * Try to match a Character from a list.
+     *  @param	tSymbol table of Symbols
+     *  @return the index in table of Symbols (-1 if not found)
+    **/ 
+    public final int lookup (char[] tSymbol) {
+      char c;
+      int i;
+        if (pos >= length) return(-1);
+        c = a[pos];
+        for (i=0; i<tSymbol.length; i++) {
+	    if (tSymbol[i] == c) {
+		pos += 1;
+		return(i);
+	    }
+        }
+        return(-1) ;	// Not Found
+    }
+
+    /** 
+     * Verify we're starting by a specific character
+     *  @param	c the character to match, possibly preceded by blanks.
+     *  @return true (position changed)/false
+    **/ 
+    public final boolean match(char c) {
+      int posini = pos;
+	gobbleSpaces();
+	if ((pos<length) && (a[pos++] == c))
+	    return(true);
+	pos = posini;
+	return(false);
+    }
+
+    /** 
+     * Verify we're starting by a specific string.
+     *  Note that an, empty string will always match...
+     *  @param	text the string that should be there.
+     *  @return true (position changed)/false
+    **/ 
+    public final boolean match(String text) {
+      int posini = pos;
+      int len = text.length();
+      boolean matching = (len+pos) <= length;
+      int i;
+        for (i=0; matching && i<len; i++) 
+	    matching = a[pos++] == text.charAt(i);
+	if (matching) matching = i==len;
+        if (!matching) pos = posini;
+	return(matching);
+    }
+
+    /** 
+     * Try to match a Symbol in a defined piece of the text.
+     *  The matching is successful when a symbol of the table
+     *  with the specified length is matched.
+     *  @param	tSymbol table of Symbols
+     *  @param	len exact length of text to match
+     *  @return the index in table of Symbols (-1 if not found)
+    **/ 
+    public final int lookup (String[] tSymbol, int len) {
+      int i, j;
+	if (flags>0) { flags = 0; /* error_message = null;*/ }
+        if (pos+len <= length) for (i=0; i<tSymbol.length; i++) {
+	    if (tSymbol[i].length() != len) continue ;
+	    for (j=0; j<len; j++) {
+	        if (tSymbol[i].charAt(j) != a[pos+j]) break;
+	    }
+	    if (j >= len) {		// Symbol found -- set what's parsed
+		pos += len;
+	        return(i) ;
+	    }
+        }
+        return(-1) ;	// Not Found
+    }
+
+    /** 
+     * Try to match a Symbol in the current text.
+     * The matching is successful with the first symbol of the
+     * list that coincides -- and the position is incremented.
+     *  @param  tSymbol a table of Symbols
+     *  @return	the index in table of Symbols (-1 if not found)
+    **/ 
+    public final int lookup (String[] tSymbol) {
+      int i, j;
+      int maxlen = length - pos;
+      int symlen  = 0;
+	if (flags>0) { flags = 0; /* error_message = null;*/ }
+      	for (i=0; i<tSymbol.length; i++) {
+	    symlen = tSymbol[i].length();
+            if (symlen > maxlen) continue;
+	    for (j=0; j<symlen; j++) {
+	        if (tSymbol[i].charAt(j) != a[pos+j]) break;
+	    }
+	    if (j < symlen) continue ;
+	    pos += symlen; 
+	    return(i);
+      	}
+      	return(-1) ;	// Not Found
+    }
+
+    /** 
+     * Try to match a Symbol in the current text, case insensitive.
+     *  @param	tSymbol table of Symbols
+     *  @return the index in table of Symbols (-1 if not found)
+    **/ 
+    public final int lookupIgnoreCase(String[] tSymbol) {
+      int i, j;
+      int maxlen = length - pos;
+      int symlen  = 0;
+	if (flags>0) { flags = 0; /* error_message = null;*/ }
+	for (i=0; i<tSymbol.length; i++) {
+	    symlen = tSymbol[i].length();
+	    if (symlen > maxlen) continue;
+	    for (j=0; j<symlen; j++) {
+		if (Character.toLowerCase(tSymbol[i].charAt(j))
+		 != Character.toLowerCase(a[pos+j])) break;
+	    }
+	    if (j < symlen) continue ;
+	    pos += symlen;
+	    return(i) ;
+        }
+        return(-1) ;	// Not Found
+    }
+
+    /*==============================================================
+                Locate matching parenthesis / Quotes
+     *==============================================================*/
+
+    /** 
+     * From current position assumed to contain a parenthesis or bracket,
+     * return the location of the corresponding parenthesis.
+     * No mouvement in the Parsing structure (pos does not change)
+     * @return the position / -1 if not found
+     */
+    public final int matchingBracket() {
+      int posini = pos;
+      int i, j, depth;
+      char c, o;	
+	if (pos >= length) return(-1);
+	i = this.lookup(brackets);
+	if (i<0) return(i);	// Current char not in list of brackets...
+	pos = posini;
+	c = brackets[i];	// Note that c is also a[pos]
+	o = brackets[i^1];	// This gives the corresponding bracket
+	depth = 1;
+	j = pos;
+	if ((i&1)==0) 		// I have a left bracket. Move forward
+	  for (++j; j<length; j++) {
+	    if (a[j] == c) depth++;
+	    else if (a[j] == o) depth--;
+	    if (depth == 0) break;
+	}
+	else 			// I have a right bracket. Move backward.
+	  for (--j; j>=0 ; j--) {
+	    if (a[j] == c) depth++;
+	    else if (a[j] == o) depth--;
+	    if (depth == 0) break;
+	}
+	if (j>=length) j = -1;
+	return(j);
+    }
+
+    /** 
+     * From current position assumed to contain a Quote (' " or `)
+     * return location of the matching quote.
+     * The next character identical to the current one is searched.
+     * No quote escaping allowed.
+     * No mouvement in the Parsing structure (pos does not change)
+     * Added in V1.3
+     * @return the position / -1 if not found.
+     */
+    public final int matchingQuote() {
+      int j;
+	for (j=pos+1; (j<length) && (a[j]!=a[pos]); j++) ;
+	if (j>=length) j = -1;
+	return(j);
+    }
+
+    /*==============================================================
+                Interpretations for Numbers
+     *==============================================================*/
+
+    /** 
+     * Try to match a Positive Integer Number.
+     * No change is made in <em>pos</em> when no number could be matched;
+     *  @return	the integer read --  0 by default.
+    **/ 
+    private final int parseNum() {	// Interpret an Integer
+      int i = pos;
+      int val = 0;
+	while ((i<length) && Character.isDigit(a[i])) i++;
+	if (i>pos) val = Integer.parseInt(new String(a, pos, i-pos));
+	// Compute the number of significant digits, and set ZERO_FILL
+	if (flags == 0) {
+	    flags = (i-pos) << 8;
+	    if ((flags>256) && (a[pos]=='0') && Character.isDigit(a[pos+1]))
+	        flags |= ZERO_FILL << 16;
+	}
+	// System.out.println("....ParseNum("+this.toString()+"): val="+val
+	//                 +", flags=0x"+Integer.toHexString(flags));
+	pos = i ;
+	return(val);
+    }
+
+    /** 
+     * Try to match a Long Positive Integer Number.
+     * No change is made in <em>pos</em> when no number could be matched;
+     *  @return	the long integer read --  0 by default.
+    **/ 
+    private final long parseNum8() {	// Interpret an Integer
+      int i = pos;
+      long val = 0;
+	while ((i<length) && Character.isDigit(a[i])) i++;
+	if (i>pos) val = Long.parseLong(new String(a, pos, i-pos));
+	// Compute the number of significant digits, and set ZERO_FILL
+	if (flags == 0) {
+	    flags = (i-pos) << 8;
+	    if ((flags>256) && (a[pos]=='0') && Character.isDigit(a[pos+1]))
+	        flags |= ZERO_FILL << 16;
+	}
+	// System.out.println("....ParseLong("+this.toString()+"): val="+val
+	//                 +", flags=0x"+Integer.toHexString(flags));
+	pos = i ;
+	return(val);
+    }
+
+    /** 
+     * Try to match one of the possible NaN representations.
+     * No change is made in <em>pos</em> when no NULL representation could be
+     * matched.
+     *  @return	true (a NaN representation found) / false
+    **/ 
+    public final boolean parseNaN() {		// Interpret NaN
+      int posini = pos;
+      int postart, i;
+	gobbleSpaces();
+        if (pos>=length) { pos = posini; return(false); }
+	postart = pos;
+
+	for (i=0; i<nulls.length; i++) {
+	    if (nulls[i] == null) continue;
+	    pos = postart;
+	    if (match(nulls[i])) {
+		char c = a[pos-1];
+		while ((pos<length) && (a[pos] == c)) pos++;
+		if (pos<length) {	// Verify the word stops here.
+		    c = a[pos];
+		    if (Character.isLetterOrDigit(c)) continue;
+		    if (c == '.') continue;
+		    return(true);
+		}
+	    }
+	}
+	pos = posini; 
+	return(false);
+    }
+
+    /** 
+     * Try to match a Positive Integer Number.
+     * No change is made in <em>pos</em> when no number could be matched;
+     *  @return	the integer read --  0 by default, 0x80000000 for NaN
+    **/ 
+    public final int parsePositiveInt() {	// Interpret an Integer
+      int posini = pos;
+      int val = 0;
+	if (flags>0) { flags = 0; /* error_message = null;*/ }
+	while ((pos < length) && Character.isWhitespace(a[pos])) pos++;
+	if (pos >= length) { pos = posini; return(val); }
+	val = this.parseNum();
+	if (flags == 0) {	// Try NaN
+	    if (this.parseNaN()) val = 0x80000000;
+	    else pos = posini;
+	}
+	return(val);
+    }
+
+    /** 
+     * Try to match an Integer Number.
+     * No change is made in <em>pos</em> when no number could be matched;
+     *  @return	the integer read --  0 by default, 0x80000000 for NaN
+    **/ 
+    public final int parseInt() {	// Interpret an Integer
+      int posini = pos;
+      int val = 0;
+      int pec = 0;	// Pecularities found here: sign edited.
+      boolean minus = false;
+	if (flags>0) { flags = 0; /* error_message = null;*/ }
+	gobbleSpaces();
+	if (pos >= length) { pos = posini; return(val); }
+	if (a[pos] == '-') { minus = true; ++pos; }
+	else if (a[pos] == '+') { pec = SIGN_EDIT; ++pos; }
+	val = this.parseNum();
+	if (minus) val = -val;
+	if (flags == 0) {
+	    if (this.parseNaN()) val = 0x80000000;
+	    else pos = posini;
+	}
+	else flags |= pec << 16 ;
+	return(val);
+    }
+
+    /** 
+     * Try to match a Long Integer Number.
+     * No change is made in <em>pos</em> when no number could be matched;
+     *  @return	the integer read --  0 by default, 0x80000000 for NaN
+    **/ 
+    public final long parseLong() {	// Interpret an Integer
+      int posini = pos;
+      long val = 0;
+      int pec = 0;	// Pecularities found here: sign edited.
+      boolean minus = false;
+	if (flags>0) { flags = 0; /* error_message = null;*/ }
+	gobbleSpaces();
+	if (pos >= length) { pos = posini; return(val); }
+	if (a[pos] == '-') { minus = true; ++pos; }
+	else if (a[pos] == '+') { pec = SIGN_EDIT; ++pos; }
+	val = this.parseNum8();
+	if (minus) val = -val;
+	if (flags == 0) {
+	    if (this.parseNaN()) val = 0x8000000000000000L;
+	    else pos = posini;
+	}
+	else flags |= pec << 16 ;
+	return(val);
+    }
+
+    /** 
+     * Internal method which can accept te "x10+/-exp" notation (x10 is true)
+     * @param x10 is 10 if the notation e.g. 314.16x10-2 is acceptable.
+     * @return	the double which could be interpreted -- 1 by default.
+    **/
+    private final double parseValue(int x10) {
+      double val = 1;
+      int posini = pos;
+      int i, i1, nd;
+      int hasexpo = 0;
+      int e = 0;			// Exponent
+      int pec = 0;	// Pecularities found here: sign edited, zero_fill
+      char c = Character.MIN_VALUE;	// Terminator for Exponent
+
+	if (flags>0) { flags = 0; /* error_message = null;*/ }
+	if (pos >= length) return(val) ;
+	c = a[pos];
+	if (c == '+') { pec |= SIGN_EDIT; ++pos; }
+	else if (c == '-') pos++;
+	// i1 is set to the position of first significant digit
+	for (i1=pos; (i1<length) && (a[i1] == '0'); i1++) ;
+	// i is set to the position of first non-digit
+	for (i=i1; (i<length) && Character.isDigit(a[i]); i++) ;
+	if (((i1-pos)>0) && ((i-pos)>1)) pec |= ZERO_FILL;
+	if ((i<length) && (a[i] == '.')) {
+	    if (i1 == i) 		// No significant digit yet
+		for (++i1; (i1<length) && (a[i1] == '0'); i1++) ;
+	    else ++i1;			// To take into account the .
+	    for (nd = ++i; (i<length) && Character.isDigit(a[i]); i++) ;
+	    nd = i - nd;
+	}
+	else nd = -1;			// Indicates no decimal part
+	i1 = i - i1;			// Number of significant digits
+	if (i1 == 0) i1 = 1;
+	if (i == pos) {			// No digit at all -- could be NaN
+	    pos = posini ;
+	    if (this.parseNaN()) val = 0./0.;
+	    else pos = posini;
+	    return(val);
+	}
+
+	val = Double.valueOf(new String(a,pos,i-pos)).doubleValue();
+	if (c == '-') val = -val;
+	pos = i ;			// Could also be this.set(i)
+
+	// Set the number of decimals etc
+	// System.out.println("....ParseValue("+this.toString()+"): val="+val
+	//  +", flags=0x"+Integer.toHexString(flags)+", pec="+pec+", nd="+nd);
+	if (flags == 0) flags = (nd+1) | (i1<<8) | (pec << 16);
+
+	if (i >= (length-1)) return(val);
+	if (x10 == 0) return(val);
+
+	// Look for an Exponent part -- We may already have read 10 in 10^8
+	//  hasexpo is 2 when the '10' already read.
+	//  Note that 2^8 is also accepted -- but not 2.0^8
+	posini = pos;
+	c = Character.MIN_VALUE;	// Terminator in 10^8^
+	if ((a[i] == 'e') || (a[i] == 'E')) { hasexpo = 1; i++; }
+	else if (x10>1) {		// Can be x10^8 or just ^8
+	    if (nd < 0) hasexpo = 2;
+	    if (((a[i] == 'x') || (a[i] == '\u2715')) && (i<=(length-4))) {
+		++i ;
+		if ((a[i] == '1') && (a[i+1] == '0')) i += 2; 
+		hasexpo = 10; 
+	    }
+	    if (a[i] == '^') { c = '^'; i++; }
+	    else if ((a[i] == '+') || (a[i] == '-') || Character.isDigit(a[i]));
+	    else hasexpo = 0;
+	}
+
+	// Interpret the Exponent part
+	if (hasexpo != 0) {
+	    pos = i;
+	    flags |= 0x80000000;	// Turn into negative to avoid modify
+	    e = parseInt();
+	    flags &= 0x7fffffff;	// Turn into negative to avoid modify
+	    if (pos == i) hasexpo = 0;	// No number in exponent ??
+	}
+	if (hasexpo == 0) 
+	    pos = posini;
+	else {
+	    if (hasexpo == 2) {			// Just 10^8
+	        hasexpo = (int)val;		// Normally +/-10
+		if (hasexpo < 0) { hasexpo = -hasexpo; val = -1; }
+		else val = 1;
+	        while (e>0) { val *= hasexpo; e--; }
+	        while (e<0) { val /= hasexpo; e++; }
+		hasexpo = 0;
+	    }
+	    else val *= AstroMath.dexp(e);
+	    flags |= (hasexpo<<16);
+	    // Accept 10^8^ (2 carrets) -- c contains the ^
+	    if ((pos<length) && (a[pos] == c)) pos++;
+	}
+	return(val) ;
+    }
+
+    /** 
+     * Interpret a real number as (+/-)num.decimals.
+     * No change occurs in <em>pos</em> when no number could be matched,
+     * which can be tested to verify that a number was actually matched.
+     * @return	the double which could be interpreted (NaN if no match)
+     */
+    public final double parseDecimal() {
+      double value = parseValue(0);
+        if ((flags&0xff00) == 0) return(0./0.);
+	return value;
+    }
+
+    /** 
+     * Interpret a real number as (+/-)numE+/-pow.
+     * No change occurs in <em>pos</em> when no number could be matched,
+     * which can be tested to verify that a number was actually matched.
+     * @return	the double which could be interpreted (NaN if no match)
+     */
+    public final double parseDouble() {	// Interpret a Floating-Point
+      double value = parseValue(1);
+        if ((flags&0xff00) == 0) return(0./0.);
+	return value;
+    }
+
+    /** 
+     * Interpret a real number as (+/-)numx10+pow OR (+/-)numE+pow.
+     * No change occurs in the <em>pos</em> when no number could be matched,
+     * which can be tested to verify that a number was actually matched.
+     * @return	the double which could be interpreted -- 1 by default.
+     */
+    public final double parseFactor() {
+	return parseValue(10);
+    }
+
+    /** 
+     * Interpret a sexagesimal number.
+     * no change occurs in the <em>pos</em> when no number could be matched,
+     * which can be tested to verify that a number was actually matched.
+     * An error is stored when a component is outside [0,60[.
+     * The exponent is accepted.
+     * @return	the double which could be interpreted -- NaN by default.
+     */
+    public final double parseSexa() {	// Interpret in Sexagesimal
+      double val = 0;
+      double f = 1.;
+      boolean minus = false ;
+      int components = 0;
+      int upmost_component = 2;
+      int unit  = 0;			// 2 for :, 4 for deg, 6 for hour
+      int error = 0;
+      int pec   = 0;
+      int posini = pos;
+      double x;
+      int hms, local_flags, i;
+
+	if (flags>0) { flags = 0; error_message = null; }
+
+	/* Default (undefined) is NaN */
+
+	gobbleSpaces();
+	if (pos >= length) {
+	    pos = posini;
+	    return(0./0.) ;
+	}
+	if (a[pos] == '-')      { minus = true;    ++pos; }
+	else if (a[pos] == '+') { pec = SIGN_EDIT; ++pos; }
+	while ((pos < length) && (a[pos] == ' ')) pos++;	// 26-Oct-2006
+
+	/* Get Hours or Degrees */
+	hms = parseNum();
+	if (flags == 0) {	// No number at all ==> NaN
+	    pos = posini;
+	    if (!this.parseNaN()) pos = posini ;
+	    return(0./0.);	
+	}
+	flags |= (pec<<16);
+	val = hms;		// hours
+	local_flags = flags;
+
+	/* Look for possible fraction -- means a single component allowed */
+	if ((pos < length) && (a[pos] == '.')) {
+	    pos++;	// Gobble the decimal point
+	    upmost_component = 0;
+	    if ((pos < length) && Character.isDigit(a[pos])) {
+		--pos;  // Restore the decimal point
+		val += parseDecimal();
+		local_flags += flags;
+	    }
+	    else local_flags |= 1;	// Indicates "just a decimal point".
+        }
+
+	/* Look for possible 'd' (deg) or 'h' specification */
+	if (pos < length) {
+	    for (i=0; i<sexa_symb1.length; i++) {
+		if (a[pos] == sexa_symb1[i]) { unit = sexa_unit1[i]; break; }
+	    }
+	    // Here unit takes the values:
+	    // 1 : 1/60 (')
+	    // 2 : colon(:)
+	    // 4 : degrees; 5='; 13="
+	    // 6 : hours  ; 7=m; 15=s
+	    // 9 : 1/3600 (")
+	    // and all combinations.
+	    if (unit != 0) {
+	        if ((unit&9) != 0) {
+		    val /= 60.; f /= 60.; components++;
+		    if ((unit&8) != 0) { val /= 60.; f /= 60.; components++; }
+		    unit &= ~9;
+	        }
+		pos++;
+	    }
+	}
+
+	while (pos < length) {
+	    if (a[pos] == sexa_letter[components]) { pos++; continue; }
+	    if (a[pos] == sexa_symbol[components]) { pos++; unit|=16;continue; }
+	    if (a[pos] == ' ') { pos++; continue; }
+	    if (a[pos] == ':') { pos++; continue; }
+	    if (components >= upmost_component) break;
+	    if (!Character.isDigit(a[pos])) break;
+	    flags = 0;			// Changed by parseNum
+	    /* error_message = null;*/
+	    hms = parseNum();
+	    i = flags&0xff00;		// Number of significant digits (<< 8)
+	    if (i == 0x100) i = 0x200;	// :2: is significant as 2 digits 02
+	    local_flags += i;		// Total number of significant digits
+	    if (hms>60) { 
+		error=2; 
+		error_message = "component " + hms + ">60";
+	    }
+	    components++;
+	    f /= 60.; val += f*hms;
+	}
+	if ((components > 0) && (hms == 60) && (error == 0)) {
+	    error = 1;
+	    error_message = "";
+	}
+	if ((pos < length) && (a[pos] == '.')) {	// Get Fraction
+	    pos++; 	// Gobble the decimal point
+	    if ((pos < length) && Character.isDigit(a[pos])) {
+		--pos;	// Restore the decimal point
+		double fraction = parseDecimal();
+	        val += f*fraction;
+		if ((error == 1) && (fraction != 0.)) {
+		    error = 2;
+		    error_message = "component > 60" + fraction;
+		}
+		local_flags += flags;	// Increase both decimals+significant
+	    }
+	    else local_flags |= 1;	// Indicates "just a decimal point".
+	}
+	// Accept e.g. 1.5e-3 as a valid number.
+	if ((components == 0) && (pos < length)) {
+	    if (Character.toLowerCase(a[pos]) == 'e') {
+		++pos;
+		i = this.parseInt();
+		if (this.digits() == 0) --pos;	// Not a valid exponent
+		else {
+		    val *= AstroMath.dexp(i);
+		    i = (local_flags&0xff) - i;	// Number of decimals
+		    if (i<0)   i=0;
+		    if (i>=32) i=31;
+		    local_flags = (local_flags & ~0xff) | i 
+			        | (Astroformat.EFORMAT<<16);
+		}
+	    }
+	}
+	    
+	flags = local_flags;
+	if (minus) val = -val;
+	if (error>0) {			// Create the error message
+	    String tag = error > 1 ? "****" : "++++";
+	    error_message = tag + "parseSexa("
+		+ String.valueOf(a, posini, pos-posini) + ")" + error_message;
+	}
+	//System.out.println("....components=" + components + ", unit=" + unit);
+	if (components>0) {		// components is 1 (h:m) or 2 (h:m:s)
+	    pec = components+1+unit;
+	    if ((pec&16)!=0) pec = (pec&0xf)+8;	// SEXA2d --> SEXA2o
+	    flags |= (pec<<16) | (error<<24);
+	    // Number of decimals: no dot is equivalent to a dot in components
+	    if ((flags&0xff) == 0) flags |= 1;
+	    flags += (components*2);		// 4 decimals when h:m:s
+	}
+	else if (unit>0) {
+	    if ((unit&16)!=0) pec = SEXA1o;
+	    else if (unit==6) pec = SEXA1h;
+	    else pec = SEXA1d;
+	    flags |= (pec<<16);
+	}
+	return(val);
+    }
+
+    /** 
+     * Interpret a Date.
+     * No change occurs in the <em>pos</em> when date (Y-M-D) could not be
+     * matched. 
+     * On return, indications about format.
+     * @return	a date in MJD (Modified Julian Date = JD-2400000.5,
+     * 		or number of days elapsed since 17 Nov 1858 UTC).
+     */
+    public final int parseDate() {	// Interpret in Sexagesimal
+      int[] datelem = new int[3];	// Date elements
+      int[] datype  = new int[3];	// Date type 1=day 2=mon 4=yr
+      int   status = 0;			// Found elements: 1=day 2=mon 4=yr
+      int year, month, day;
+      int pos1, i, nc, jd;
+      int posini = pos;
+      boolean minus = false;
+      int pec = Astroformat.DATE;	// Peculiarity: DATE_alpha
+      char sep = Character.MIN_VALUE;
+      int  nc_max = 3;
+      char c; 
+
+	if (flags>0) { flags = 0; /* error_message = null;*/ }
+
+	/* Default (undefined) is NaN */
+
+	gobbleSpaces();
+	if (pos >= length) {
+	    pos = posini;
+	    return(0) ;
+	}
+	/* A negative number must be a year (BC) */
+	if (a[pos] == '-')      { minus = true;     ++pos; }
+	else if (a[pos] == '+') { pec |= SIGN_EDIT; ++pos; }
+
+	/* Get Day or Year */
+	// System.out.print("...parseDate: status=0");
+	for (i=0; i<nc_max; i++) {
+	    if (i>0) {	/* Gobble the separator - or . or / */
+	        c = currentChar();
+		if ((sep == Character.MIN_VALUE) && (i == 1) &&
+	            ((c == '-') || (c == '.') || (c == '/'))) sep = c;
+		// sep contains the first valid separator.
+		// System.out.print("...sep="+sep+"["+this+"]");
+		if (c == sep) pos++;			// Skip the separator
+		else if (sep != Character.MIN_VALUE) 	// no separator ?
+		    break;
+	    }
+	    gobbleSpaces();
+	    if (pos >= length) break;
+	    pos1 = pos;
+	    datelem[i] = parseNum();
+	    if (pos1 == pos) {		// Not a number, try month
+		if ((status&2) != 0) break;
+	        datelem[i] = lookupIgnoreCase(month_list);
+		if (datelem[i]<0) 	// Not a month either give up
+		    break;
+		pec |= DATE_alpha;	// Month is alphabetical
+		datelem[i] += 1;	// Range of month in [1..12]
+		datype[i] = 2;		// It's a month
+		while(Character.isLetter(currentChar()))
+		    pos++;
+	    }
+	    else {			// A number -- 4 digits is a year
+		// System.out.print("(len="+(pos-pos1)+")");
+		if (minus || ((pos-pos1) >= 4)) {
+		    // System.out.print("(in1)");
+		    if ((status&4)!= 0) break;	// Already a year!
+		    datype[i] = 4;
+		}
+		else if ((pos-pos1) >= 3) {	// Could be yday or year ?
+		    // System.out.print("(in2)");
+		    datype[i] = (status&3)==0 ? 1 : 4 ;
+		    if (datype[i] == 1)		// yday ==> only 2 components
+			nc_max = 2;	
+		}
+		if (minus) {
+		    datelem[i] = -datelem[i] ;
+		    minus = false;
+		}
+	    }
+	    status |= datype[i];
+	    // System.out.print(" " + status + "[+" + pos + "]");
+	}
+	nc = i;				// Number of components
+	// System.out.println(" (end)");
+
+	/* A date requires at least 2 components */
+	if (nc < 2) {
+	    pos = posini;
+	    return(0);
+	}
+
+	/* Ambiguities: when not all items are recognised,
+	 * assume ISO-8601 order year.Mon.Day 
+	 */
+	if (status == 0) {
+	    datype[0] = 4;
+	    if (nc == 2) {	// Only 2 components, assume Year.Day */
+		datype[1] = 1;
+		status = 4|1;
+	    }
+	    else { 
+		datype[1] = 2; datype[2] = 1; 
+		status = 7;
+	    }
+	}
+	for (i=0; i<nc; i++) {
+	    if (datype[i] != 0) continue;
+	    if ((status&4)==0)      datype[i] = 4;
+	    else if ((status&2)==0) datype[i] = 2;
+	    else datype[i] = 1;
+	    status |= datype[i];
+	}
+
+	/* Keep the info about what was matched  (for this.format()) */
+	if (status == 5) 		// Y+D 
+	    pec |= datype[0] == 4 ? DATE_YD : DATE_DY;
+	else if (status == 6)		// Y+M 
+	    pec |= datype[0] == 4 ? DATE_YM : DATE_MY;
+	else if (datype[0] == 4) 	// 3 components Y+...
+	    pec |= datype[1] == 2 ? DATE_YMD : DATE_DY+1;
+	else if (datype[0] == 1)	// 3 compoments D+...
+	    pec |= datype[1] == 2 ? DATE_DMY : DATE_DY-1;
+	else                    	// 3 compoments M+...
+	    pec |= datype[1] == 4 ? DATE_MYD : DATE_MDY;
+
+	/* Order the components datem as year month[0-11] day[1-31] */
+	year  = month = day = 0;	// Required by the compiler!!!
+	for (i=0; i<nc; i++) {
+	    if (datype[i] == 4) year  = datelem[i];
+	    if (datype[i] == 2) month = datelem[i]-1;	// in range [0..11]
+	    if (datype[i] == 1) day   = datelem[i];
+	}
+
+	/* Verify it's possible -- month and day in a correct range ? */
+	if ((month*30+day) > 367) {
+	    pos = posini;
+	    return(0);
+	}
+
+	// V1.3: Conversion Year Month Date to Julian Date is in Astrotime!
+	jd = (int)(Astrotime.YMD2JD(year, month, day) - 2400000.5);
+
+	flags |= (pec<<16);		// Keep what was matched.
+	return(jd);
+    }
+
+
+    /** 
+     * Interpret some Complex number (date, sexagesimal).
+     * On return, a date / angle / time
+     * @param	pic "picture" which specifies the format of the input.
+     * 		Letters are Y y (years) M (month) D (day) h (hour) m (minutes)
+     * 		s (seconds) d (degrees) f (fractions), and punctuations like
+     * 		: (colon) / (slash), etc. <b>Y</b> and <b>y</b> have slightly
+     * 		different meanings when the century is omitted (2-digit years):
+     * 		<b>YY</b> have their offset in 1900, while <b>yy</b> assumes
+     * 		dates between 1950 and 2049: e.g. <tt>01</tt> means
+     * 		1901 with <b>Y</b> and 2001 with <b>y</b>
+     *		<P>
+     * 		The text must follow exactly the "picture" when the components
+     * 		are specified with several letters. For instance, a picture
+     * 		<tt>YYYY-MM-DD</tt> indicates that a conforming text
+     * 		must be made of 4 digits representing the year, followed by a
+     * 		dash, 2 digits representing the month, a dash, and 2 digits
+     * 		representing the day -- while <tt>Y-M-D</tt> accept a variable
+     * 		number of digits in each of the components: "<tt>2006-7-5</tt>"
+     * 		would conform to the latter "picture", but not to the 
+     * 		"<tt>YYYY-MM-DD</tt>" one.
+     * @return	a date, time or angle.
+     *   Date is expressed in MJD (days elapsed since 17 Nov 1858 UTC), 
+     *   time in days or hours, angles in degrees.  The functions 
+     *   {@link Astroformat#isDate}, {@link Astroformat#isTime},
+     *   {@link Astroformat#isDate}, {@link Astroformat#isDays}
+     *   specify the actual interpretation done in the parsing.
+     * @throws  ParseException for invalid picture or non-conforming data.
+     * 		The error_message of the exception starts by:<br>
+     * 		"++++" when upper/lower case were mixed; <br>
+     * 		"****" for terminal error, and contains ((pic)) for invalid arg
+     */
+    public final double parseComplex(String pic) throws ParseException {
+      int[]  comp6 = new int[6];	// Date/time elements
+      int[]  ipic6 = new int[6];	// Position of components in pic
+      char[] pic6  = new char[6];	// Element number in pic1
+      boolean check_century = false;
+      char[] apic = pic.toCharArray();
+      int ipic = 0;			// Index in pic
+      int epic = pic.length();
+      int last_comp = 0;		// Which is the last component
+      double factor, fraction_factor;
+      double value = 0./0.;
+      int posini = pos;
+      int k = 0;			// 0=yr 1=mon 2=day 3=hr 4=min 5=s
+      int i, plen=0;			// #characters in field
+      boolean minus = false;
+      int pec = 0;
+      char c = Character.MIN_VALUE; 
+      int mixed = 0;			// Indicates an interpretation made
+      StringBuffer mixed_buf = null;	// Error message of interpretation
+
+	if (DEBUG>0) System.out.println("....cplx("+pic+")\tin=\"" 
+		+ this.toString()+"\"");
+	if (flags>0) { flags = 0; error_message = null; }
+
+	/* Initialisation */
+	comp6[0] = comp6[1] = comp6[2] = comp6[3] = comp6[4] = comp6[5] =0;
+	ipic6[0] = ipic6[1] = ipic6[2] = ipic6[3] = ipic6[4] = ipic6[5] =0;
+	pic6[0] = pic6[1] = pic6[2] = pic6[3] = pic6[4] = pic6[5] 
+	        = Character.MIN_VALUE;
+
+	if (apic[ipic] == '"') ipic++;
+	// Possible sign
+	if (pos<length) {
+	    if (a[pos] == '-')      { minus = true;     pos++; }
+	    else if (a[pos] == '+') { pec |= SIGN_EDIT; pos++; }
+	}
+
+	while ((pos<length) && (ipic<epic)) {
+	    c = apic[ipic++]; 
+	    k = pic1.indexOf(c);
+	    if (k<0) {			// Not a specification letter
+		if (c == a[pos]) { pos++; continue; }
+		if (c == ':') { continue; }		// Next field
+		if (c == '.') break;			// Decimals
+		if (c == 'f') break;			// Fraction
+		if (c == '"') break;	// Ending '"' in pic.
+		error_message = "****parseComplex((" 
+		    + pic + ")): what is '" + c + "'?";
+		throw new ParseException(error_message, ipic);
+	    }
+	    k %= 6;			// Year Month Day Hour Min Sec
+	    if (Character.isLetter(a[pos])) {	// Must be month name
+		pec |= DATE_alpha;
+		i = lookupIgnoreCase(month_list);
+		if (k == 4) { 		// error, 'm' instead of 'M'
+		    k = 1; 
+		    mixed |= (1<<k);	// mixed upper/lowercase in this element
+		}
+		if ((k!= 1) || (pic6[1] != Character.MIN_VALUE) || (i<0)) {
+		   error_message = "****parseComplex(" 
+		       + pic + "): month? "+ this.toString();
+		   throw new ParseException(error_message, ipic);
+		}
+		comp6[1] = i;		// Range 0..11
+		pic6[1] = 'a';
+	    }
+	    else if (pic6[k] != Character.MIN_VALUE) {	// Field already used ?
+		i = 5-k;		// Month <-> Minute, Day <-> Deg
+		if ((k>0) && (i>0) && (pic6[i] == Character.MIN_VALUE)) {
+		    comp6[i] = comp6[k];
+		    pic6[i]  = pic6[k];
+		    ipic6[i] = ipic6[k];
+		    k = i;
+		    mixed |= (1<<k);	// mixed upper/lowercase in this element
+		}
+	        if (pic6[k] != Character.MIN_VALUE) {  // Duplication ??
+		    error_message = "****parseComplex((" + pic + ")): "
+			+ "duplicated component '" + pic1.charAt(k) + "'";
+		    throw new ParseException(error_message, ipic);
+		}
+	    }
+	    ipic6[k] = ipic;		// Index in pic of this element.
+	    last_comp = k;
+
+	    /* Count the number of identical elements in picture */
+	    for(plen=1; (ipic<epic) && (apic[ipic] == c); ipic++) plen++;
+	    if (pic6[k] != Character.MIN_VALUE)		// Was already filled
+		continue;
+	    if (plen == 1) {		// Number of digits not specified
+		gobbleSpaces();
+		if (a[pos] == ':') pos++;
+		gobbleSpaces();
+		comp6[k] = parseNum();
+	    	pic6[k] = c;
+		if ((k == 0) && (c == 'y')) check_century = true;
+		continue;
+	    }
+	    // Number of digits given a priori
+	    if ((k == 0) && (plen == 2)) check_century = true;
+	    for (i=plen; (i>0) && (pos<length); --i, pos++) {
+		if (a[pos] == ' ') continue;
+		else if (Character.isDigit(a[pos])) 
+		    comp6[k] = comp6[k]*10 + Character.digit(a[pos], 10);
+		else {
+		    error_message = "****parseComplex(" + pic + "): "
+			+ this.toString();
+		    throw new ParseException(error_message, ipic);
+		}
+	    }
+	    pic6[k] = c;
+	}
+	if (DEBUG>0) {
+	    System.out.print("....cplx[a]=");
+	    for(i=0;i<6;i++) System.out.print("("+pic6[i]+")"+comp6[i]);
+	    System.out.println(",last_comp=" + last_comp 
+		    + ", check_century=" + check_century);
+	}
+
+	/* Verify possible mixing month[1]/min[4] */
+	if ((Character.toUpperCase(pic6[1]) == 'M') 
+	      && (pic6[4] == Character.MIN_VALUE)
+	      && (pic6[0] == Character.MIN_VALUE)) {	// No date !!
+	    pic6[4]  = pic6[1];   pic6[1] = Character.MIN_VALUE;
+	    comp6[4] = comp6[1]; comp6[1] = 0;
+	    mixed |= (1<<1);	// mixed upper/lowercase in this element
+	}
+	else if ((pic6[1] == Character.MIN_VALUE)
+	      && (pic6[4] != Character.MIN_VALUE)
+	      && (pic6[0] != Character.MIN_VALUE)
+	      && (pic6[5] == Character.MIN_VALUE)) {	// no second, no month
+	    pic6[1] = pic6[4];    pic6[4] = Character.MIN_VALUE;
+	    comp6[1] = comp6[4]; comp6[4] = 0;
+	    mixed |= (1<<4);	// mixed upper/lowercase in this element
+	}
+
+	/* Verify possible mixing day[2]/deg[3] */
+	if (     (pic6[3] == Character.MIN_VALUE)
+	      && (pic6[2] != Character.MIN_VALUE)
+	      && (pic6[0] == Character.MIN_VALUE)
+	      && (pic6[1] == Character.MIN_VALUE)) {	// No date at all...
+	    pic6[3] = pic6[2];    pic6[2] = Character.MIN_VALUE;
+	    comp6[3] = comp6[2]; comp6[2] = 0;
+	    mixed |= (1<<2);
+	}
+	else if ((pic6[2] == Character.MIN_VALUE)
+	      && (pic6[0] != Character.MIN_VALUE)) {	// Incomplete date
+	    pic6[2] = pic6[3];    pic6[3] = Character.MIN_VALUE;
+	    comp6[2] = comp6[3]; comp6[3] = 0;
+	    mixed |= (1<<3);
+	}
+
+	/* Prepare message in case of mixed picture */
+	if (mixed!=0) {
+	  String mod_pic = new String(pic) ;
+	  char[] mpic = mod_pic.toCharArray();
+	  char M, m;
+	    for (k=0; mixed!=0; mixed>>=1, k++) {
+		if ((mixed&1)==0) continue;
+		i = ipic6[k]-1;			// Position in pic
+		m = mpic[i];			// The character to change
+		M = Character.toUpperCase(m);
+		if (M == m) M = Character.toLowerCase(m);
+		while ((i<mpic.length) && (mpic[i] == m)) 
+		    mpic[i++] = M;
+	    }
+	    mixed_buf = new StringBuffer(100);
+	    mixed_buf.append("++++parseComplex(");
+	    mixed_buf.append(pic);
+	    mixed_buf.append(") interpreted as (");
+	    mixed_buf.append(mpic);
+	    mixed_buf.append(")");
+	}
+
+	/* Month must be in range 0.11 is specified numerically */
+	if ((pic6[1] != Character.MIN_VALUE) && (pic6[1] != 'a')
+		&& (comp6[1]>0)) comp6[1] -= 1;
+
+	/* Keep the info about what was matched  (for this.format()),
+	 * and compute the date part if any
+	 */
+	value = 0; factor = fraction_factor = 1;
+	if (DEBUG>0) {
+	    System.out.print("....cplx[b]=");
+	    for(i=0;i<6;i++) System.out.print("("+pic6[i]+")"+comp6[i]);
+	    System.out.println("");
+	}
+	if (pic6[0] != Character.MIN_VALUE) {		// Full date
+	    pec |= DATE;
+	    if (pic6[2] != Character.MIN_VALUE) {
+		pec |= DATE_YD;
+		if (pic6[1] != Character.MIN_VALUE)  pec |= DATE_YMD;
+	    }
+	    if (check_century && (comp6[0] < 200)) {
+		comp6[0] += 1900;
+		if ((pic6[0] != 'Y') && (comp6[0] < 1950)) 
+		    comp6[0] += 100;
+	        check_century = false;
+	    }
+	    if (minus) { comp6[0] = -comp6[0]; minus = false; }
+	    if (DEBUG>0) {
+	        System.out.print("....cplx[c]=");
+	        for(i=0;i<6;i++) System.out.print("("+pic6[i]+")"+comp6[i]);
+	        System.out.println("");
+	    }
+	    value = Astrotime.YMD2JD(comp6[0], comp6[1], comp6[2]) - 2400000.5;
+	    factor = 24.; 
+	}
+	else if (pic6[2] != Character.MIN_VALUE) {	// Elapsed days
+	    if (pic6[1] != Character.MIN_VALUE) {	// month/day, no year?
+		error_message = "****parseComplex((" + pic + ")): "
+		    + "month without year ? " + this.toString();
+		throw new ParseException(error_message, ipic);
+	    }
+	    pec |= DATE_DIFF;
+	    value = comp6[2];
+	    factor = 24.;
+	}
+	else if (Character.toLowerCase(pic6[3]) == 'h')
+	    pec |= SEXA3h;
+	for (i=3; i<6; i++) {
+	    if (pic6[i] != Character.MIN_VALUE) {
+	        if (DEBUG>0) System.out.print("    value=" + value + " => ");
+		value += comp6[i]/factor;
+	        if (DEBUG>0) System.out.println(value);
+	        if (i == last_comp) fraction_factor = factor;
+	    }
+	    factor *= 60.;
+	}
+
+	/* Look for decimal fraction -- 
+	 * c is the last char in picture 
+	 * plen is the length of last picture figure (e.g. 2 for ss)
+	 */
+	if (pos >= length) {	// Number exhausted -- skip remaining elements
+	    ipic = epic;
+	    c = Character.MIN_VALUE;
+	}
+	else if ((plen == 1) && (a[pos] == '.')) {
+	    // Always accept fractional part of last field
+	    value += parseValue(0)/fraction_factor;
+	}
+	else while ((c == 'f') && (pos<length) && Character.isDigit(a[pos])) {
+	    fraction_factor *= 10;
+	    value += Character.digit(a[pos], 10)/fraction_factor;
+	    c = ipic<epic ? apic[ipic++] : Character.MIN_VALUE;
+	    pos++;
+	}
+	if ((c != '"') && (c != Character.MIN_VALUE)) {
+	    error_message = "****parseComplex(" + pic + "): "
+		+ "mismatch from \"" + pic.substring(ipic-1) + "\": "
+		+ this.toString();
+	    throw new ParseException(error_message, ipic);
+	}
+
+	// A problem in the 'picture' is reflected by a WARNING status
+	// and an error message.
+	if (mixed_buf != null) {
+	    error_message = mixed_buf.toString();
+	    flags |= (1<<24);		// indicates WARNING
+	    // System.err.println(b.toString());
+	}
+	flags |= (pec<<16);		// Keep what was matched.
+	if (minus) value = -value;
+	if (DEBUG>0) System.out.println("....parseComplex("+pic+"): value=" 
+		+ value + ", pec="+pec+", flags="+flags);
+	return(value);
+    }
+
+
+    /*==============================================================
+                Retrieve details about the last parsing
+     *==============================================================*/
+
+    /** 
+     * Retrieves the number of decimals of the last parsed number.
+     * For a sexagesimal representation, the minutes and seconds
+     * count each for 2 decimals, i.e. 00:01:02 has 4 decimals.
+     * @return number of decimals, -1 if no decimal point exists.
+     */
+    public final int decimals() {
+	return((flags&0xff)-1);
+    }
+
+    /** 
+     * Retrieves the number of significant digits of the last parsed number.
+     * @return number of significant digits -- 0 meaning an emtpy (NaN) number.
+     */
+    public final int digits() {
+	return((flags>>8)&0xff);
+    }
+
+    /** 
+     * Retrieves the 'format' of the last parsed number.
+     * @return One of DECIMAL, EFORMAT, FACTOR, SEXA2, SEXA3, SEXA2c, SEXA3c,
+     * 	       SEXA2d, SAX2h, SEXA3d, SEXA3h, DATE
+     * 	       possibly combined with ZERO_FILL, SIGN_EDIT
+     * @see Astroformat
+     */
+    public final int format() {
+	return((flags>>16)&0xff);
+    }
+
+    /** 
+     * Retrieves the 'format' of the last parsed number as a string.
+     * @return A printable variant of format.
+     */
+    public final String form() {
+      // int k = (flags>>16)&0xff;
+      // System.out.println("....form: flags=0x"+Integer.toHexString(flags)
+      //                   +", k="+k);
+      //  return (explain_form[k&0xf] + explain_pec[k>>4]);
+	return(super.explain((flags>>16)&0xff));
+    }
+
+    /** 
+     * About the last parsed number: was it sexagesimal ?
+     * @return true if was expressed in sexagesimal
+     */
+    public final boolean isSexa() {
+	return(isSexa(flags>>16));
+    }
+
+    /** 
+     * About the last parsed number: was it expressed as a date ?
+     * @return true if parsed number contained 'h' and/or 'm' 's'
+     */
+    public final boolean isDate() {
+	return(isDate(flags>>16));
+    }
+
+    /** 
+     * About the last parsed number: does it represent days (date_diff) ?
+     * @return true if parsed number expressed time in days.
+     */
+    public final boolean isDays() {
+	return(isDays(flags>>16));
+    }
+
+    /** 
+     * About the last parsed number: was it expressed as time (hms) ?
+     * @return true if parsed number contained 'h' and/or 'm' 's'
+     */
+    public final boolean isTime() {
+	return(isTime(flags>>16));
+    }
+
+    /** 
+     * About the last parsed number: was it expressed as angle (&deg; or d)
+     * @return true if parsed number contained '&deg;' and/or ' "
+     */
+    public final boolean isAngle() {
+	return(isAngle(flags>>16));
+    }
+
+    /** 
+     * About the last parsed number: was it in error ?
+     * @return true if parsed number contained '&deg;' and/or ' "
+     */
+    public final boolean inError() {
+	return((flags&0x2000000)!=0);
+    }
+
+    /** 
+     * Retrieves the status (OK, WARNING, ERROR) of last (sexagesimal) parsing.
+     * @return One of OK, WARNING, ERROR
+     */
+    public final int  status() {
+        return(flags>>24);
+    }
+
+    /** 
+     * About the last parsed number: get the error message
+     * @return The error message, null when no error.
+     */
+    public final String getMessage() {
+	if ((flags&0x3000000) == 0) return(null);
+	return(error_message);
+    }
+
+    /*==============================================================
+                	Parse an Array
+     *==============================================================*/
+
+   /**
+    * Interpret an array (several numbers).
+    * @param vec  Array containing on output the values parsed.
+    * @return number of numbers found. 
+   **/
+    public int parseArray(double[] vec) {
+      int postart, ipos, i;
+      double x;
+        // Initialize all number to NaN.
+	for (i=0; i<vec.length; i++) vec[i] = 0./0.;
+	// Move in the text as long as possible.
+	for (i=0; (i<vec.length) && (this.pos<this.length); i++) {
+	    postart = this.pos;
+	    this.gobbleSpaces(); ipos = this.pos;
+	    x = this.parseDouble();
+	    if (this.pos == ipos) {	// Nothing found...
+		this.pos = postart;
+		break;
+	    }
+	    vec[i] = x;
+	}
+	return(i);
+    }
+
+   /**
+    * Interpret a number + Error.
+    * Text to interpret. May be "300+23-25" or "300[23]"
+    * 			or "300+/-23" or "300+/-23"
+    * @param vec  Array containing value PositiveError NegativeError
+    * @return number of numbers found (0, 1, 2 or 3). 
+    * 		When 0, the position was not changed.
+   **/
+    public int parseWithError(double[] vec) {
+      int postart, ipos, poserr, i;
+      boolean bracket = false;
+      int type = 0;	// 0=+/- 1=+ 2=- 3=+/- 4=[]
+      double x;
+        // Initialize all number to NaN.
+	for (i=0; i<vec.length; i++) vec[i] = 0./0.;
+	// Move in the text as long as possible.
+	postart = this.pos;
+	this.gobbleSpaces(); ipos = this.pos;
+	x = this.parseDouble();
+	if (this.pos == ipos) {	// Nothing found...
+	    this.pos = postart;
+	    return(0);
+	}
+	vec[0] = x;
+	// Find some error symbol.
+	poserr = ipos;
+	for (i=1; (i<vec.length) && (ipos<length); i++) {
+	    postart = this.pos;
+            type = lookup(error_symb); 
+	    if (type<0) break;
+	    bracket |= type == 4;
+	    ipos = this.pos;
+	    x = this.parseDouble();
+	    if (this.pos == ipos) {	// Error not found
+	        this.pos = postart;
+	        break;
+	    }
+	    if ((type==1) || (type==2)) vec[type] = x;
+	    else vec[i] = x;
+	}
+	if (bracket) {
+	    this.gobbleSpaces();
+	    if (match("]")) ;
+	    else { 
+		ipos=poserr; 
+		for (i=1; i<vec.length; i++) vec[i] = 0./0.;
+		i=1;
+	    }
+	}
+	return(i);
+    }
+
+    /*==============================================================
+                Edition
+     *==============================================================*/
+
+    /**
+     * View the Parsing as a String
+     * @return the not-yet-parsed part of the string.
+     */
+    public final String toString() {
+	return(new String(a, pos, length-pos)) ;
+    }
+
+    /**
+     * View a part of the Parsing as a String. Added in V1.3
+    * @param len  Length to keep (truncated if necessary)
+     * @return the not-yet-parsed part of the string.
+     */
+    public final String toString(int len) {
+	if ((len+pos) > length) len = length - pos;
+	return(new String(a, pos, len)) ;
+    }
+
+}
Index: aladin/cds/astro/Proj3.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Proj3.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,428 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro ;
+import java.text.*;	// for parseException
+
+/**
+ * Class defining the Mathematical Projections of the Celestial Sphere.
+ * This class contains only the mathematical projections ---
+ * WCS and Aladin projections are in a derived class.
+ * <P>The available projections are defined by the formulae, where
+ * <PRE>
+ *          l,b   = longitude and latitude
+ *          theta = angle to center of projection 
+ *          x,y   = projections (cartesian) along x (East) and y (North)
+ *          r,phi = projections (polar)
+ * TAN      / Standard = Gnomonic     
+ *            r = tan(theta)          phi
+ * TAN2     / Stereographic           
+ *            r = 2.tan(theta/2)      phi
+ * SIN      / Orthographic  
+ *            r = sin(theta)          phi
+ * SIN2     / Equal-area    
+ *            r = 2.sin(theta/2)      phi
+ * ARC      / Schmidt proj. 
+ *            r = theta               phi
+ * AITOFF   / Aitoff (equal area)     if D = sqrt(0.5*(1+cos(b)cos(l/2)))
+ *            x = 2cos(b)sin(l/2)/D   y = sin(b)/D
+ * SANSON   / Global Sinusoidal (equal area)
+ *            x = l cos(b)            y = b
+ * MERCATOR / with poles at infinity
+ *            x = l                   y = atanh(b)
+ * LAMBERT  / equal area projection
+ *            x = l                   y = sin(b)
+ * </PRE>
+ * <P> The typical usage of the Proj3 class consists in:<OL>
+ * <LI> Define a projection (type and the center of projection) by means of
+ *	one of the constructors; the default center is the (0,0) point.
+ * <LI> Compute the projection values <EM>X,Y</EM> from a position with
+ *	the <B>computeXY</B> method; the projections can be retrieved
+ *	either via the <B>getX</B> and <B>getY</B> methods,
+ *	or in <EM>aProj3.X</EM> and <EM>aProj3.Y</EM> elements.
+ * <LI> The reverse computation (from projections to coordinates)
+ *	is done with the <B>computeAngles</B>  method; the angles are
+ *	obtained by means of the <B>getLon</B> and <B>getLat</B> methods.
+ * </OL>
+ *
+ * @author Pierre Fernique, Francois Ochsenbein [CDS]
+ * @version 1.0 : 03-Mar-2000
+ * @version 1.1 : 24-Mar-2000: better documentation
+ * @version 1.11: 24-Apr-2006: qualified exceptions
+ */
+
+public class Proj3 {
+    protected byte type ;	// Projection type
+    private double R[][] ;	// Rotation Matrix
+    private double clon, clat;	// Center of the Projection (degrees)
+    /** The values of the projections */
+    protected double X,Y ;	// One point in the projection (cartesian)
+    /** The corresponding polar angles */
+    protected Coo point ;	// One point in the projection (original angles)
+
+    // Constants
+    public static final int NONE     = 0;
+    public static final int TAN      = 1; // Standard Gnomonic (r = tan(theta))
+    public static final int TAN2     = 2; // Stereographic (r = 2.tan(theta/2))
+    public static final int SIN      = 3; // Orthographic  (r = sin(theta))
+    public static final int SIN2     = 4; // Equal-area    (r = 2.sin(theta/2))
+    public static final int ARC      = 5; // Schmidt proj. (r = theta)
+    public static final int AITOFF   = 6; // Aitoff Projection
+    public static final int SANSON   = 7; // Global Sinusoidal
+    public static final int MERCATOR = 8; // 
+    public static final int LAMBERT  = 9; // 
+    public static final String [] name = { "-", 
+    	"Gnomonic (TAN)", "Stereographic (TAN2)", 
+	"Orthographic (SIN)", "Zenithal Equal-area (SIN2)",
+	"Schmidt (ARC)", "Aitoff", "Sanson", "Mercator", "Lambert"
+    };
+
+  //  ===========================================================
+  //		Constructors
+  //  ===========================================================
+
+  /** Creation of object used for Projections.
+   * At creation, the center and the type of projection is specified
+   * @param type     projection type -- default (standard) = TAN
+   * @param lon  longitude of the center of projection (coordinates of the tangent point)
+   *			expressed in degrees.
+   * @param lat latitude of the center of projection (coordinates of the tangent point)
+   *			expressed in degrees.
+   */
+   public Proj3(int type, double lon, double lat) {
+	this.type = (byte)type ;
+	this.clon = lon ;
+	this.clat = lat ;
+	this.point = new Coo (lon, lat) ;
+	if ((lon != 0) || (lat != 0)) 	// Keep null for unit matrix
+      	    R = Coo.localMatrix(clon,clat);
+   }
+
+  /** Creation of object used for Projections from a String.
+   * @param type     projection type 
+   * @param text     the center in a string
+   */
+   public Proj3(int type, String text) throws 
+       ParseException {
+	this.point = new Coo(text) ;
+	this.type  = (byte)type ;
+	this.clon  = this.point.lon ;
+	this.clat  = this.point.lat ;
+	if ((clon != 0) || (clat != 0)) 	// Keep null for unit matrix
+      	    R = Coo.localMatrix(clon,clat);
+   }
+
+  /** Projection at the Origin.
+   * Projection at tangent point (lon=0, lat=0)
+   * @param type     projection type 
+   */
+   public Proj3(int type) {
+	this(type, 0., 0.) ;	// Default = Standard Projection
+   }
+
+   /** Standard projection.
+    * At creation, the center and the type of projection is specified
+    * @param lon  longitude of the center of projection.
+    *             (coordinates of the tangent point)
+    * @param lat  latitude of the center of projection.
+    *             (coordinates of the tangent point)
+   **/
+   public Proj3(double lon, double lat) {
+	this(TAN, lon, lat) ;	// Default = Standard Projection
+   }
+
+  //  ===========================================================
+  //			Static Methods
+  //  ===========================================================
+
+  /*  Static methods (functions) in Java are very close to C ones;
+      they do not require any object instanciation.
+      Typical example of static methods are in the Math class
+  */
+
+  //  ===========================================================
+  //			Class Methods
+  //  ===========================================================
+
+  /** Get only the X from the object
+   * @return  the X projection
+   */
+   public final double getX() {
+	return(X) ;
+   }
+
+  /** Get only the Y from the object
+   * @return  the Y projection
+   */
+   public final double getY() {
+	return(Y) ;
+   }
+
+  /** Get only the longitude from the object
+   * @return the longitude in degrees of the point (point.lon)
+   */
+   public final double getLon() {
+	return(point.lon) ;
+   }
+
+  /** Get only the Y from the object
+   * @return the latitude in degrees of the point (point.lat)
+   */
+   public final double getLat() {
+	return(point.lat) ;
+   }
+
+	/**
+	 * Returns a definition of this projection
+	 * @return a string containing the definition
+	 */
+   public String toString() {
+     	return(name[type] + " projection centered at " + clon + " " + clat 
+	    + ": " + X + " " + Y) ;
+   }
+
+  //  ===========================================================
+  //		Projections from Angles
+  //  ===========================================================
+
+  /** Compute a projection from initial coordinates.
+   * <BR>
+   * <B>Rem :</B> the rotation matrix was computed at Constructor
+   *
+   * @param lon longitude
+   * @param lat latitude
+   * @return status true if the projection is possible 
+   *     	and false when the position can't be projected.
+   *		The values of the projections are in object.X and object.Y
+   */
+   public boolean computeXY (double lon, double lat) {
+      double x,y,z, r, w ;
+
+	/* Was this position already computed ?? */
+	if ((lon == point.lon) && (lat == point.lat)) 
+	    return(!Double.isNaN(X)) ;
+
+	/* Set angles + unit vector, but X and Y are not yet computed */
+	point.set(lon, lat) ;
+	X = 0./0.; Y = 0./0.; 
+
+	if (R == null) { x = point.x; y = point.y; z = point.z ; }
+	else {
+      	    x = R[0][0]*point.x + R[0][1]*point.y + R[0][2]*point.z ;
+      	    y = R[1][0]*point.x + R[1][1]*point.y + R[1][2]*point.z ;
+      	    z = R[2][0]*point.x + R[2][1]*point.y + R[2][2]*point.z ;
+	}
+	switch(type) {
+    	  case TAN      :	// Only 1 hemisphere valid
+	    if (x <= 0)  return false ; 
+	    X = y/x; Y = z/x; 
+	    break ;
+
+    	  case TAN2     :	// All positions valid, just opposite pole
+	    w = (1.0 + x)/2.0;
+	    if (w <= 0)  { X = 0./0.; Y = 0./0.; return false; }
+	    X = y/w; Y = z/w;
+	    break ;
+
+    	  case SIN      :	// Only 1 hemisphere valid, r <= 1
+	    if (x <= 0)  return false ; 
+	    X = y; Y = z ;
+	    break ;
+
+    	  case SIN2     :	// Whole sphere, r <= 2 (equal area)
+	    w = Math.sqrt((1.0 + x)/2.0);
+	    if (w > 0)  { X = y/w; Y = z/w; }
+	    else        { X = 2;   Y = 0;   }
+	    break ;
+
+    	  case ARC      :	// r <= pi
+	    if (x > -1.0)  { 		// Angular distance = acos(x)
+	        r = Math.sqrt(y*y + z*z) ;
+	    	if (x > 0) w = AstroMath.asinc(r);
+		else       w = Math.acos(x)/r ;
+		X = y*w; Y = z*w;
+	    }
+	    else 	{ X = Math.PI ; Y = 0 ; }
+	    break ;
+
+    	  case AITOFF   :	// Ellipse, 
+	    r = Math.sqrt(x*x + y*y) ;
+	    w = Math.sqrt (r*(r+x)/2.0);	// cos lat . cos lon/2
+	    w = Math.sqrt ((1.0 + w)/2.0);
+	    X = Math.sqrt(2.*r*(r-x)) / w ;
+	    Y = z / w ;
+	    if (y<0) X = -X ;
+	    break ;
+
+    	  case SANSON   :	// Sinusoidal |X| <= pi, Y <= pi/2
+	    r = Math.sqrt(x*x + y*y) ;
+	    Y = Math.asin(z);
+	    if (r == 0) X = 0 ;
+	    else X = Math.atan2(y,x) * r;
+	    break ;
+
+    	  case MERCATOR :
+	    r = Math.sqrt(x*x + y*y) ;
+	    if (r == 0)  return false ; 
+	    X = Math.atan2(y,x);
+	    Y = AstroMath.atanh(z);
+	    break ;
+
+    	  case LAMBERT  :	// Equal Area (lon,sin(lat))
+	    r = Math.sqrt(x*x + y*y) ;
+	    Y = z ;
+	    if (r == 0) X = 0 ;
+	    else X = Math.atan2(y,x);
+	    break ;
+	
+	  default:
+	    throw new IllegalArgumentException(
+	     "****Proj3: Invalid Projection type #" + type) ;
+	}
+	return(true) ;
+   }
+
+  //  ===========================================================
+  //		Projected values to Coordinates
+  //  ===========================================================
+
+  /** Reverse projection: compute the polar angle corresponding to (x,y)
+   * <BR>
+   * <B>Rem :</B> the rotation matrix was computed at Constructor
+   * a la creation de l'objet
+   *
+   * @param  px  x projection values
+   * @param  py  y projection values
+   * @return status true if the X / Y values are within the projection area
+   *     	and false otherwise,
+   *		The values of the angles are obtained via getLon() and getLat()
+   */
+   public boolean computeAngles (double px, double py) {
+      double x,y,z, /*x0,y0,z0,*/ r, w ;
+//      boolean angles_set = false ;
+	/* Was this position already computed ?? */
+	if ((px == this.X) && (py == this.Y)) 
+	    return(!Double.isNaN(point.lon)) ;
+
+	/* Set the projection values, bug angles not yet computed */
+	X = px; Y = py; 
+	point.lon = 0./0.; point.lat = 0./0. ;
+
+	switch(type) {
+    	  case TAN      :	// Only 1 hemisphere valid
+	    x = 1.0 / Math.sqrt(1.0 + X*X + Y*Y);
+	    y = X * x;
+	    z = Y * x;
+	    break ;
+
+    	  case TAN2     :	// All positions valid, just opposite pole
+	    r = (X*X + Y*Y)/4.0 ;
+	    w = 1.0 + r ;
+	    x = (1.0 - r)/w ;
+	    y = X/w ;
+	    z = Y/w ;
+	    break ;
+
+    	  case SIN      :	// Only 1 hemisphere valid, r <= 1
+	    w = 1.0 - X*X - Y*Y;
+	    if (w < 0) {	// Accept some rounding error
+		if (w > -2.e-16) w = 0 ;
+		else  return false ; 
+	    }
+	    x = Math.sqrt(w) ;
+	    y = X;
+	    z = Y;
+	    break;
+
+    	  case SIN2     :	// Whole sphere, r <= 2 (equal area)
+	    r = (X*X + Y*Y)/4.0 ;
+	    if (r > 1.)  return false ; 
+	    w = Math.sqrt(1.0 - r) ;
+	    x = 1.0 - 2.0 * r;
+	    y = w * X;
+	    z = w * Y;
+	    break ;
+
+    	  case ARC      :	// r <= pi
+	    r = Math.sqrt(X*X + Y*Y) ;
+	    if (r > Math.PI)  return false ; 
+	    w = AstroMath.sinc(r);
+	    x = Math.cos(r);
+	    y = w * X;
+	    z = w * Y;
+	    break ;
+
+    	  case AITOFF   :	// Ellipse, dimensions sqrt(2) x 2.sqrt(2)
+	    r = X*X/8.0 + Y*Y/2.0; 	// 1 - cos b . cos l/2
+	    if (r > 1.0)  return false ; 
+	    x = 1. - r ;		//     cos b . cos l/2
+	    w = Math.sqrt(1. - r/2.) ;	// sqrt(( 1 + cos b . cos l/2)/2)
+	    y = X * w / 2. ;
+	    z = Y * w ;
+	    // Convert from Cartesian (l/2,b) to Cartesian (l,b) 
+	    r = Math.sqrt(x*x + y*y) ;	// cos(b)
+	    if (r > 0) {
+	        w = x;
+		x = (w*w - y*y) /r;
+		y = 2.0 * w * y /r;
+	    }
+	    break ;
+
+    	  case SANSON   :	// Sinusoidal |X| <= pi, Y <= pi/2
+	    z = Math.sin(Y);
+	    r = 1 - z*z; 	// cos^2(b)
+	    if (r < 0)  return false ; 
+	    r = Math.sqrt(r);	// cosb
+	    if (r == 0) w = 0. ;
+	    else    w = X/r;	// Longitude
+	    x = r * Math.cos(w);
+	    y = r * Math.sin(w);
+	    break ;
+
+    	  case MERCATOR :
+	    r = 1./AstroMath.cosh(Y);
+	    z = AstroMath.tanh(Y) ;
+	    x = r * Math.cos(X);
+	    y = r * Math.sin(X);
+	    break ;
+
+    	  case LAMBERT  :	// Equal Area (lon,sin(lat))
+	    z = Y;
+	    r = 1 - z*z;	// cos(b) ** 2 
+	    if (r < 0)  return false ; 
+	    r = Math.sqrt(r);	// cosb
+	    x = r * Math.cos(X);
+	    y = r * Math.sin(X);
+	    break ;
+	
+	  default:
+	    throw new IllegalArgumentException(
+	     "****Proj3: Invalid Projection type #" + type) ;
+	}
+
+	/* From Cartesian: just rotate (used transposed matrix) */
+	if (R != null) point.set(
+      	    R[0][0]*x + R[1][0]*y + R[2][0]*z ,
+      	    R[0][1]*x + R[1][1]*y + R[2][1]*z ,
+      	    R[0][2]*x + R[1][2]*y + R[2][2]*z 
+	) ;
+	else point.set(x, y, z) ;
+     	return true ;
+   }
+}
Index: aladin/cds/astro/Qbox.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Qbox.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,836 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+import java.io.*;
+import java.util.*;
+import java.text.*; // for parseException
+// import cds.astro.*;
+
+/*
+ * @author	Francois Ochsenbein
+ * @author      Benoit Baranne (Stagiaire UTBM)
+ * @version 1.0	  16-sep-2002
+ * @version 1.01  Oct 2003 (MW) add a copy constructor
+ * @version 1.02 jan 2004 (BB) ajout de la methode equals dans QBox.
+ * -------------
+*/
+
+
+/**
+ * The <em>Qbox</em> divides the celestial sphere into "cells" of approximative
+ * constant size.
+ *
+ * The routines provided in this module all deal with "qboxes".
+ * A <b>qbox</b> is just a number which represents one of the cells.
+ *
+ * <P>
+ * A <em>qbox</em> number is formed by the values of the projections
+ * <em>(X,Y)</em> of the directions on the 6 faces of a cube numbered
+ *      1&#160;(<I>z=1</I>),  2&#160;(<I>y=1</I>),  3&#160;(<I>x=1</I>),
+ * 	4&#160;(<I>x=-1</I>), 5&#160;(<I>y=-1</I>) and 6&#160;(<I>z=-1</I>).
+ * <P>
+ * The faces and orientations are defined as:
+ * <FONT COLOR='Blue'>
+ * <PRE>
+ * 
+ *                  +---------+
+ *                  |    ^    |
+ *                  |    |    |
+ *                  |   1+---&gt;|
+ *                  |      x  |
+ *                  |         |
+ *        +---------+---------+---------+---------+
+ *        |    ^    |    ^    |         |         |
+ *        |    |    |    |    |         |         |
+ *        |   5+---&gt;|  3 +---&gt;|   2+---&gt;|   4+---&gt;|
+ *        |      x  |      x  |   x|    |   x|    |
+ *        |         |         |    v    |    v    |
+ *        +---------+---------+---------+---------+
+ *                  |    ^    |
+ *                  |    |x   |
+ *                  |&lt;---+    |
+ *                  |    6    |
+ *                  |         |
+ *                  +---------+
+ * </PRE>
+ * </FONT>
+ * Each cube face is divided into 4 areas; each area is further
+ * divided into four pieces, etc.
+ * The number of valid qboxes is <b>6&times;4<sup>N</sup></b>:
+ * <PRE>
+ *   Level    Lower #      qboxes   qbox_size
+ *      0           9           6     83&ordm;
+ *      1          36          24     41&ordm;
+ *      2         144          96     20&ordm;
+ *      3         576         384     10&ordm;
+ *      4        2304        1536      5&ordm;
+ *      5        9216        6144      2&ordm;30'
+ *      6       36864       24576      1&ordm;15'
+ *      7      147456       98304        40'
+ *      8      589824      393216        20'
+ *      9     2359296     1572864        10'
+ *     10     9437184     6291456         5'
+ *     11    37748736    25165824         2'30"
+ *     12   150994944   100663296         1'15"
+ * </PRE>
+ * where level is a number which can be changed at any time using
+ * <b>setLevel</b>(<EM>level</EM>) method.
+ * <P>
+ * The present implementation assumes that <EM>level<I><=12</I></EM>,
+ * corresponding to a maximum of 28 bits in the qbox number.
+ * <P>
+ * For a level 6, the qbox number is a short integer with bits
+ * (from left to right)
+ * <FONT COLOR='Blue'><TT>1ppp xyxy xyxy xyxy</TT></FONT>.
+ * The leftmost `1' bit allows the recognition of the level;
+ * bits <TT>p</TT> represent the face number (1 to 6),
+ * <TT>x</TT> and <TT>y</TT> the position, expressed with <EM>level</EM> bits,
+ * along the axises defined above for the face; going one level down
+ * in the hierarchy is therefore just a shift of 2 bits and
+ * updating the 2 rightmost bits.
+ *	<P>
+ * The selection of valid qboxes makes usage of an <b>Enumeration</b>
+ * which returns the valid qboxes via its  <b>nextElement</b> method.
+ **/
+
+public class Qbox implements Serializable {
+
+    /** The Qbox is just a number -- the lefmost bit (sign bit)
+    	 being set for a Qbox with status 'ANY' (no need to make test)
+     **/
+    int qbox; // The Qbox is just a number!!
+
+    /* Variables common to the Class: all Definitions */
+    static private final double PIO2 = Math.PI / 2.;
+    static final boolean DEBUG = true;
+    static final int ANY = 0x80000000; // The 'ANY' status
+    static final int BOX = 0x7fffffff; // The ~ANY  bits
+    static private final int MAXLEVEL = 12;
+    static public int level = 9; // The current level
+    static final int QBOX_NONE = 0;
+    static final int QBOX_ANY = -1;
+    static final int QBOX_SOME = 1;
+    static private final char[] oct = "01234567".toCharArray();
+    static private final double DEG = 180. / Math.PI;
+    static final double[] MAXRAD = /* Max radius of Qbox  */ {
+       54.735610317, /* Level  0:   radius  54.73561/ 45.00000    */
+       30.361193405, /* Level  1:   radius  30.36119/ 21.79319    */
+       16.403086517, /* Level  2:   radius  16.40309/  9.61290    */
+    	8.639594386, /* Level  3:   radius   8.63959/  4.55775    */
+    	4.449359566, /* Level  4:   radius   4.44936/  2.21341    */
+    	2.259674852, /* Level  5:   radius   2.25967/  1.08995    */
+    	1.138910823, /* Level  6:   radius   1.13891/  0.54074    */
+    	0.571763982, /* Level  7:   radius   0.57176/  0.26930    */
+    	0.286464128, /* Level  8:   radius   0.28646/  0.13438    */
+    	0.143378220, /* Level  9:   radius   0.14338/  0.06713    */
+    	0.071725727, /* Level 10:   radius   0.07173/  0.03355    */
+    	0.035872027, /* Level 11:   radius   0.03587/  0.01677    */
+    	0.017938306  /* Level 12:   radius   0.01794/  0.00838    */
+    };
+    static final double[] SINRAD = /* Sine of above radii */ {
+    	0.8164965809277260, /* Level  0: Surface  6.875e+03 / 6.875e+03  */
+    	0.5054494651244236, /* Level  1: Surface  1.719e+03 / 1.719e+03  */
+    	0.2823931345695149, /* Level  2: Surface  4.170e+02 / 4.825e+02  */
+    	0.1502185901567493, /* Level  3: Surface  9.780e+01 / 1.250e+02  */
+    	0.0775779474805375, /* Level  4: Surface  2.345e+01 / 3.154e+01  */
+    	0.0394285430318791, /* Level  5: Surface  5.729e+00 / 7.904e+00  */
+    	0.0198764347423619, /* Level  6: Surface  1.415e+00 / 1.977e+00  */
+    	0.0099789983974146, /* Level  7: Surface  3.517e-01 / 4.944e-01  */
+    	0.0049997213877594, /* Level  8: Surface  8.766e-02 / 1.236e-01  */
+    	0.0025024194021835, /* Level  9: Surface  2.188e-02 / 3.090e-02  */
+    	0.0012518497600656, /* Level 10: Surface  5.466e-03 / 7.725e-03  */
+    	0.0006260849416742, /* Level 11: Surface  1.366e-03 / 1.931e-03  */
+    	0.0003130824920569  /* Level 12: Surface  3.415e-04 / 4.828e-04  */
+    };
+    static final double[] MINRAD = /* Min radius of Qbox  */ {
+       45.000000000000, /* Level  0:   radius  54.73561/ 45.00000    */
+       21.793189128656, /* Level  1:   radius  30.36119/ 21.79319    */
+    	9.612900642866, /* Level  2:   radius  16.40309/  9.61290    */
+    	4.557754524215, /* Level  3:   radius   8.63959/  4.55775    */
+    	2.213411995038, /* Level  4:   radius   4.44936/  2.21341    */
+    	1.089949904684, /* Level  5:   radius   2.25967/  1.08995    */
+    	0.540737084594, /* Level  6:   radius   1.13891/  0.54074    */
+    	0.269302913463, /* Level  7:   radius   0.57176/  0.26930    */
+    	0.134384274203, /* Level  8:   radius   0.28646/  0.13438    */
+    	0.067125244187, /* Level  9:   radius   0.14338/  0.06713    */
+    	0.033545886680, /* Level 10:   radius   0.07173/  0.03355    */
+    	0.016768757962, /* Level 11:   radius   0.03587/  0.01677    */
+    	0.008383332446  /* Level 12:   radius   0.01794/  0.00838    */
+    };
+
+    /*==================================================================*
+      Initialisations
+     *==================================================================*/
+
+    /** Change the default Level which is 9.
+     * @param	lev the new level, between 0 and 12 -- other values do
+     *		not change it.
+     * @return	the previously defined level
+     **/
+    public static final int setLevel(int lev) {
+    	int old_lev = level;
+    	if ( (lev >= 0) && (lev <= 12)) 
+    	    level = lev;
+    	return (old_lev);
+    }
+
+    /*==================================================================*
+      Vectorial basic operations
+     *==================================================================*/
+
+    /** Compute the distance between 2 vectors
+     * @param	v1 first vector
+     * @param   v2 second vector
+     * @return	the squared distance ||v1-v2||^2
+     **/
+    static double dist2(double[] v1, double[] v2) {
+    	double r, d;
+    	r = v1[0] - v2[0];
+    	r *= r;
+    	d = v1[1] - v2[1];
+    	d *= d;
+    	r += d;
+    	d = v1[2] - v2[2];
+    	d *= d;
+    	r += d;
+    	return (r);
+    }
+
+    /** Compute the dot-product (scalar product)
+     * @param	v1 first vector
+     * @param   v2 second vector
+     * @return	the dot-product
+     **/
+    static double dotprod(double[] v1, double[] v2) {
+    	return (v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]);
+    }
+
+    /** Compute the square norm of a vector
+     * @param	v1 the vector
+     * @return	the squared norm
+     **/
+    static double norm2(double[] v1) {
+    	return (dotprod(v1, v1));
+    }
+
+    /** Compute the vectorial product
+     * @param	v1 first vector
+     * @param   v2 second vector
+     * @param   r the returned resulting vector
+     **/
+    static void vecprod(double[] v1, double[] v2, double[] r) {
+    	r[0] = v1[1] * v2[2] - v1[2] * v2[1];
+    	r[1] = v1[2] * v2[0] - v1[0] * v2[2];
+    	r[2] = v1[0] * v2[1] - v1[1] * v2[0];
+    }
+
+    /** Compute the determinant
+     * @param	v1 first vector
+     * @param   v2 second vector
+     * @param	v3 third vector
+     * @return	the determinant = (v1^v2).v3 = (v2^v3).v1 = (v3^v1).v2
+     **/
+    static double det(double[] v1, double[] v2, double[] v3) {
+    	double[] v = new double[3];
+    	vecprod(v1, v2, v);
+    	return (dotprod(v, v3));
+    }
+
+    /*==================================================================*
+      Internal Routines
+     *==================================================================*/
+
+    /** Compute the Center of a Qbox
+     * @param	qboxno the qbox number
+     * @param	XY the position of the center
+     * @return	the cube face number in range 1..6 (0 if error)
+     **/
+    private static final int center_(int qboxno, double[] XY) {
+    	int b = qboxno & BOX;
+    	int x = 0, y = 0;
+    	double f;
+    	int qlev;
+    	if (b < 9) {
+    	    XY[0] = 0.;
+    	    XY[1] = 0.;
+    	    return (0);
+    	}
+    	for (qlev = 0; (b & (~0xf)) != 0; qlev++) {
+    	    y |= (b & 1) << qlev;
+    	    b >>>= 1;
+    	    x |= (b & 1) << qlev;
+    	    b >>>= 1;
+    	}
+    	/* Now qlev is the level of this Qbox, b is the face number */
+    	f = (1 << qlev); // 2**qlev, The maximal value for this level
+
+    	XY[0] = Math.tan( ( ( (x + 0.5) / f) - 0.5) * PIO2);
+    	XY[1] = Math.tan( ( ( (y + 0.5) / f) - 0.5) * PIO2);
+    	return (b);
+    }
+
+    /** Compute the Corners of a Qbox from qbox number
+     * @param	qboxno the qbox number
+     * @param	blur the (xy) position of Bottom-Left-Up-Right points
+     * @return	the cube face number in range 1..6 (0 if error)
+     **/
+    static final int corners(int qboxno, double[] blur) {
+    	int b = qboxno & BOX;
+    	int x = 0, y = 0;
+    	int qlev;
+    	double f;
+    	if (b == 0) {
+    		return (0); // Whole Sky
+    	}
+    	/* Compute the level, and the (x,y) position in this level */
+    	for (qlev = 0; (b & (~15)) != 0; qlev++) {
+    	    y |= (b & 1) << qlev;
+    	    b >>= 1;
+    	    x |= (b & 1) << qlev;
+    	    b >>= 1;
+    	}
+    	f = (1 << qlev);
+    	/* Lower-left corner */
+    	blur[0] = Math.tan( ( (x / f) - 0.5) * PIO2);
+    	blur[1] = Math.tan( ( (y / f) - 0.5) * PIO2);
+    	x++;
+    	y++;
+    	blur[2] = Math.tan( ( (x / f) - 0.5) * PIO2);
+    	blur[3] = Math.tan( ( (y / f) - 0.5) * PIO2);
+
+    	return (b & 7);
+    }
+
+    /** Compute the 4 vectors representing the corners of a Qbox.
+     * @param	qboxno the qbox number
+     * @param	ucorn a [4][3] array
+     * @return	the cube face number in range 1..6 (0 if error)
+     **/
+    static final int ucorners(int qboxno, double[][] ucorn) {
+    	double[] XY = new double[4];
+    	int face;
+    	face = corners(qboxno, XY);
+    	if (face == 0) 
+    	    return (face);
+    	Coocube.setUvec(face, XY[0], XY[1], ucorn[0]);
+    	Coocube.setUvec(face, XY[2], XY[1], ucorn[1]);
+    	Coocube.setUvec(face, XY[2], XY[3], ucorn[2]);
+    	Coocube.setUvec(face, XY[0], XY[3], ucorn[3]);
+    	return(face);
+    }
+
+    /** Compute the box range at the default level corresponding to the
+     * box given as first argument.
+     * @param	qbox the qbox number
+     * @param	qb returned values: qb[0] = lower limit, qb[1] = upper limit+1
+     **/
+    private static final void range(int qbox, int[] qb) {
+    	int any = qbox & ANY;
+    	int mask;
+    	if ( (qbox & BOX) == 0) { // Whole Sky
+    	    qb[0] = (9 << (level << 1)) | any;
+    	    qb[1] = (15 << (level << 1)) | any;
+    	}
+    	else {
+    	    qb[0] = qb[1] = qbox;
+    	    mask = (8 << (level << 1));
+    	    while ( (qb[0] & mask) == 0) {
+    	    	qb[0] <<= 2;
+    	    	qb[1] = (qb[1] << 2) | 3;
+    	    }
+    	    qb[1]++;
+    	    qb[0] |= any;
+    	    qb[1] |= any;
+    	}
+    }
+
+    /*==================================================================*
+      Constructors
+     *==================================================================*/
+
+    /** Define the default Qbox which represents the whole sphere
+     **/
+    public Qbox() {
+    	qbox = 0;
+    }
+
+    /**
+     * Copy constructor.
+     * @param qb Qbox object to copy
+     */
+    public Qbox(Qbox qb) {
+       set(qb);
+    }
+
+    /** Define the Qbox containing a given position, at the current level.
+     * @param coo coordinates object used to create the Qbox
+     **/
+    public Qbox(Coo coo) {
+    	set(coo);
+    }
+
+    /** Transform an integer into a Qbox
+     * @param b integer to transform into a Qbox
+     **/
+    private Qbox(int b) {
+    	qbox = b;
+    }
+
+    /** Define the Qbox from a text similar to the Edited qbox (see toString)
+     * @param	text The text to interpret
+     * @throws	ParseException when the text contains invalid characters
+     **/
+    public Qbox(String text) throws ParseException {
+    	char[] a = text.toCharArray();
+    	int error = 0;
+    	int i = 0;
+    	qbox = 0;
+    	if (i >= a.length) 
+    	    return;
+    	if ( (a[i] >= '1') && (a[i] <= '6')) {
+    	    qbox = 8 | Character.digit(a[i], 8);
+    	}
+    	else {
+    	    error++;
+    	}
+    	++i;
+    	if ( (i < a.length) && (a[i] == ':')) {
+    	    i++;
+    	}
+    	while ( (i < a.length) && (a[i] >= '0') && (a[i] < '4')) {
+    	    qbox = (qbox << 2) | Character.digit(a[i], 4);
+    	    ++i;
+    	}
+    	if ( (i < a.length) && (Character.toUpperCase(a[i]) == 'A')) {
+    	    ++i;
+    	    qbox |= ANY;
+    	}
+    	if (i < a.length) {
+    	    error++;
+    	}
+    	if (error > 0) {
+    	    throw new ParseException
+    	    	("****Qbox: '" + text + "'+" + i, i);
+    	}
+    }
+
+    /*==================================================================*
+      Manipulation of Qboxes
+     *==================================================================*/
+
+    /** Compute the level of any integer considered as a qbox
+     * @param	b the integer considered as a Qbox.
+     * @return	the level corresponding to the integer (between -1 and 13)
+     **/
+    public static final int level(int b) {
+    	int n = 0;
+    	b &= BOX;
+    	if (b == 0) {
+    	    return ( -1);
+    	}
+    	if ( (b & 0x7fff0000) != 0) {
+    	    n = 7;
+    	    b >>>= 14;
+    	}
+    	while ( (b & (~0xf)) != 0) {
+    	    b >>>= 2;
+    	    n++;
+    	}
+    	return (n);
+    }
+
+    /** Actual qbox level
+     * @return	the level corresponding to the qbox (between -1 and 12)
+     **/
+    public final int level() {
+    	return (level(qbox));
+    }
+
+    /** Status of a Qbox: check whether it's completely included in
+     *  the Selection <em>(no need to make further tests on Position)</em>
+     * @return	true if the box is "any"
+     **/
+    public final boolean isAny() {
+    	return ( (qbox & ANY) != 0);
+    }
+
+    /** Set the Qbox to the 'Any' status
+     *  the Selection <em>(no need to make further tests on Position)</em>
+     * @return	true if the box is "any"
+     **/
+    public final void toAny() {
+    	qbox |= ANY;
+    }
+
+    /** Actual qbox value as an Integer
+     * @return	a box value (in the range specified in the introduction)
+     **/
+    public final int box() {
+    	return (qbox & BOX);
+    }
+
+    /** Actual qbox index
+     * @return	the index, a number between 0 and 6*4^level -1
+     **/
+    public final int index() {
+    	int n = level();
+    	int i = (qbox & BOX) - (9 << (2 * n));
+    	if (i < 0) {
+    	    i += 8;
+    	}
+    	return (i);
+    }
+
+    /** On which face is located the qbox ?
+     * @return	the face number, between 1 and 6 -- 0 for whole sphere
+     **/
+    public final int face() {
+    	int n = level();
+    	if (n < 0) {
+    	    return (0);
+    	}
+    	return ( (qbox >>> (2 * n)) & 7);
+    }
+
+    /*==================================================================*
+      Setting a Qbox from known information
+     *==================================================================*/
+
+    /** Convert a Coocube into a Qbox at the default level
+     * @param	cc the Coocube equivalent of the position
+     **/
+    public final void set(Coocube cc) {
+    	double xy;
+    	int x, y, i, count;
+    	qbox = cc.face;
+    	if (level <= 0) {
+    	    return;
+    	}
+    	qbox |= 8; // Insert bit to indicate level
+
+    	// Compute x and y, integer parts of X and Y scaled
+    	count = 1 << level; // 2**level = value of x(y) when X(Y)=+1
+    	xy = (0.5 + Math.atan(cc.X) / PIO2) * count;
+    	x = (int) xy;
+    	if (x >= count) {
+    	    x = count - 1;
+    	}
+    	xy = (0.5 + Math.atan(cc.Y) / PIO2) * count;
+    	y = (int) xy;
+    	if (y >= count) 
+    	    y = count - 1;
+
+    	    // Add the interleaved bits of x and y
+    	qbox <<= (level << 1); // Face number at its corect bit position
+    	for (count >>= 1, i = level - 1; count > 0; count >>= 1, i--) 
+    	    qbox |= ( ( (x & count) << i) << 1) | ( (y & count) << i);
+    }
+
+    /**
+     * Sets the Qbox value from another Qbox object
+     * @param qb Qbox object to copy
+     */
+    public final void set(Qbox qb) {
+       qbox = qb.qbox;
+    }
+
+    /** Convert a Position into its Qbox at the default level
+     * @param	c the Coocube equivqlent of the position
+     **/
+    public final void set(Coo c) {
+    	Coocube cc = new Coocube(c);
+    	set(cc);
+    }
+
+    /** Convert a Position into its Qbox at the default level
+     * @param	n the Coocube equivalent of the position
+     **/
+    final void set(int n) {
+    	qbox = n;
+    }
+
+    /*==================================================================*
+      Transform a Qbox into its central Position
+     *==================================================================*/
+
+    /** Convert a Qbox into the Coocube position of its center.
+     **/
+    public final Coocube center() {
+    	double XY[] = new double[2];
+    	int b;
+    	b = center_(qbox, XY);
+    	return (new Coocube(b & 7, XY[0], XY[1]));
+    }
+
+    /*==================================================================*
+      Compute accurate Qbox elements
+     *==================================================================*/
+
+    /** 
+     * Return the maximal radius (in degrees) of any Qbox at the default level
+     * @return	The maximal radius
+     **/
+    public final static double maxRadius() {
+    	return (MAXRAD[level]);
+    }
+
+    /** 
+     * Return the maximal radius (in degrees) of any Qbox at the default level
+     * @return	The maximal radius
+     **/
+    public final static double minRadius() {
+    	return (MINRAD[level]);
+    }
+
+    /** Compute the area (in square degrees) of a Qbox.
+     *	Use the ArcSin formula
+     *  		S = A_0 + A_1 + A_2 + A_3 - 2*pi
+     *		where A_i are the angles of the rectangle.
+     *		The formula is especially simple in a tangential projection.
+     * @return	The area for the Qbox in square degrees.
+     **/
+    public final double area() {
+    	double[] XY = new double[4];
+    	double S;
+    	int i;
+    	// Compute the Corners
+    	corners(qbox & BOX, XY);
+    	for (i = 0; i < 4; i++) 
+    	    XY[i] /= Math.sqrt(1. + XY[i] * XY[i]);
+    	S = Math.asin(XY[0] * XY[1]) + Math.asin(XY[2] * XY[3])
+    	  - Math.asin(XY[0] * XY[3]) - Math.asin(XY[1] * XY[2]);
+    	return (DEG * DEG * Math.abs(S));
+    }
+
+    /** Compute the radius (in degrees) of the Circle
+     * @return	The radius of the Qbox
+     **/
+    public final double radius() {
+    	double[] XY = new double[4];
+    	double[] XYc = new double[2];
+    	double s2r, num, den, denc, X, Y, rmax = 0;
+    	int i;
+    	// Compute the Center and Corners
+    	center_(qbox & BOX, XYc);
+    	corners(qbox & BOX, XY);
+    	denc = 1. + XYc[0] * XYc[0] + XYc[1] * XYc[1];
+    	for (i = 0; i < 4; i++) {
+    	    X = XY[i & 2];
+    	    Y = XY[ ( (i & 1) << 1) | 1];
+    	    den = denc * (1. + X * X + Y * Y);
+    	    num = X * XYc[1] - Y * XYc[0];
+    	    num *= num;
+    	    X -= XYc[0];
+    	    Y -= XYc[1];
+    	    num += X * X + Y * Y;
+    	    s2r = num / den;
+    	    if (s2r > rmax) {
+    	    	rmax = s2r;
+    	    }
+    	    if (DEBUG) {
+    	    	System.out.println("....radius(): i=" + i + "("
+    	         + (i & 2) + "," + ( ( (i & 1) << 1) | 1) 
+                 + ") -- X,Y=" + X + "," + Y + " -- s2r=" + s2r);
+    	    }
+    	}
+    	return (DEG * Math.asin(Math.sqrt(rmax)));
+    }
+
+    /*==================================================================*
+    	Edition
+     *==================================================================*/
+
+    /** Default Edition of the Qbox value
+     * @return	the string equivalent of the coocube
+     * 		the letter 'A' is appended for ANY IN QBOX.
+     **/
+    public final String toString() {
+    	char[] buf = new char[20];
+    	int i = buf.length;
+    	int b = qbox;
+    	if ( (b & ANY) != 0) {
+    	    buf[--i] = 'A';
+    	    b &= BOX;
+    	}
+    	while ( (b & (~0xf)) != 0) {
+    	    buf[--i] = oct[b & 3];
+    	    b >>>= 2;
+    	}
+    	if (b != 0) {
+    	    buf[--i] = ':';
+    	}
+    	buf[--i] = oct[b & 7];
+    	return (new String(buf, i, buf.length - i));
+    }
+
+    /*==================================================================*
+      Selection in a Circle
+     *==================================================================*/
+
+    private final static void call_down(int qbox, CheckPosition geom,
+    	Vector found) {
+    	int leaf = 8 << (level << 1);
+    	int status, qb, qb0, qb1;
+    	//if (DEBUG) System.out.println("....call_down(" + qbox
+    	//    + ", vector=" + found.size() + ")" + " leaf=" + leaf);
+
+    	/* The Whole sky... */
+    	if (qbox == 0) {
+    	    qb0 = 9;
+    	    qb1 = 14;
+    	}
+    	else {
+    	    qb0 = qbox << 2;
+    	    qb1 = qb0 | 3;
+    	}
+
+    	for (qb = qb0; qb <= qb1; qb++) {
+    	    status = geom.checkTarget(qb);
+    	    if (status == QBOX_NONE) {
+    	    	continue;
+    	    }
+    	    if (status == QBOX_ANY) {
+    	    	found.addElement(new Qbox(qb | ANY));
+    	    }
+    	    else if ( (qb & leaf) != 0) {
+    	    	found.addElement(new Qbox(qb));
+    	    }
+    	    else {
+    	    	call_down(qb, geom, found);
+    	    }
+    	}
+    }
+
+    /** Create a Vector of matching Qboxes in a Selection by Circle
+     * @param	center the center of the target
+     * @param	radius the target radius, in degrees.
+     * @return	a Vector with marked Qboxes
+     **/
+    static Vector in_circle(Coo center, double radius) {
+    	CheckRadius circle = new CheckRadius(center, radius);
+    	Vector vector = new Vector();
+
+    	if (radius >= 180) {
+    	    vector.addElement(new Qbox(ANY));
+    	    return (vector);
+    	}
+    	call_down(0, circle, vector);
+    	return (vector);
+    }
+
+    /*==================================================================*
+      Selection of Qboxes at the Current Level
+     *==================================================================*/
+
+    /** List in an enumeration all Qboxes corresponding to a qbox
+     * To get all qboxes, just do the following:
+     *		cq = new Qbox(); e=cq.list();
+     * @return	a list of Qboxes existing at the default level
+     *		contained in the Object.
+     **/
+    public Enumeration list() {
+    	return new Enumeration() {
+    	    int[] qb = { qbox, 0};
+       	    public boolean hasMoreElements() {
+    	    	if (qb[1] == 0)  	// Not Yet Initialized
+    	    	    range(qb[0], qb);
+    	    	return (qb[0] < qb[1]);
+    	    }
+    	    public Object nextElement() {
+    	    	Qbox e = new Qbox();
+    	    	e.qbox = qb[0]++;
+    	    	return (e);
+    	    }
+    	};
+    }
+
+    /** List in an enumeration all Qboxes selected in a Vector
+     * @param	vector a Vector of qboxes returned from a select routine
+     * @return	an Enumeration of leaf Qboxes.
+     **/
+    public static Enumeration list(final Vector vector) {
+    	return new Enumeration() {
+    	    Vector v = vector;
+    	    int pos = 0; // Position in Vector
+    	    int[] qb = { 0, 0}; // Range to cover for this vector
+
+    	    public boolean hasMoreElements() {
+    	        //if (DEBUG) System.out.println("....moreEnumVec(" + pos + "/"
+    	        //+ v.size() + ") qb=" + qb[0] + "/" + qb[1]);
+    	        if (qb[0] >= qb[1]) { // Step not yet initialized
+    		    Qbox o;
+    		    if (pos >= v.size()) return (false);
+    		    o = (Qbox) v.elementAt(pos++);
+    		    range(o.qbox, qb);
+    		    //if (DEBUG) System.out.println("......list,qbox=" + o
+    		    //   + ", range=" + qb[0] + "," + qb[1]);
+    	        }
+    	        return (true);
+    	    }
+
+    	    public Object nextElement() {
+    		Qbox e = new Qbox(qb[0]);
+    		qb[0] += 1;
+    		return (e);
+    	    }
+    	};
+    }
+
+    /** Return all Qboxes concerned by a Circular Target
+     * @param	center the target center
+     * @param	radius the target radius
+     * @return	an Enumeration of leaf Qboxes.
+     **/
+    public static Enumeration circle(Coo center, double radius) {
+    	Vector vector = in_circle(center, radius);
+    	return list(vector);
+    }
+
+    /** ------------------------------------ (removed)
+    public static Enumeration list() {
+    	 return new Enumeration() {
+    	     int abox =  9 << (level<<1);
+    	     int ebox = 15 << (level<<1);
+    	 public boolean hasMoreElements() {
+    	     return (abox < ebox);
+    	 }
+    	 public Object nextElement() {
+             Qbox e = new Qbox();
+    	     e.qbox = abox++;
+    	    return(e);
+    	 }
+      };
+    }
+    ----------------------------------------- **/
+
+    /**
+     * MOD-BB 21-01-04 Ajout de cette methode.
+     * Test d'egalite de QBox.
+     * @param o Object a comparer.
+     * @return Vrai si o est identique a this, faux sinon.
+    **/
+    public boolean equals(Object o) {
+	boolean res = false;
+	if(o instanceof Qbox)
+	res = ((Qbox)o).qbox == this.qbox;
+	return res;
+    }
+}
Index: aladin/cds/astro/QboxNumber.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/QboxNumber.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,943 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+import java.io.*;
+import java.util.*;
+import java.text.*; // for parseException
+// import cds.astro.*;
+
+/*
+ * @author	Francois Ochsenbein
+ * @author      Benoit Baranne (Stagiaire UTBM)
+ * @version 1.0	  02-Feb-2007
+ * -------------
+*/
+
+
+/**
+ * The <em>QboxNumber</em> is just a number representing a <em>cell</em>
+ * of the celestial sphere. This number is used in {@link Qbox} and
+ * {@link QboxIndex} classes.
+ *
+ * <P>
+ * A <em>qbox</em> number is formed by the values of the projections
+ * <em>(X,Y)</em> of the directions on the 6 faces of a cube numbered
+ *      1&#160;(<I>z=1</I>),  2&#160;(<I>y=1</I>),  3&#160;(<I>x=1</I>),
+ * 	4&#160;(<I>x=-1</I>), 5&#160;(<I>y=-1</I>) and 6&#160;(<I>z=-1</I>).
+ * <P>
+ * The faces and orientations are defined as:
+ * <FONT COLOR='Blue'>
+ * <PRE>
+ * 
+ *                  +---------+
+ *                  |    ^    |
+ *                  |    |    |
+ *                  |   1+---&gt;|
+ *                  |      x  |
+ *                  |         |
+ *        +---------+---------+---------+---------+
+ *        |    ^    |    ^    |         |         |
+ *        |    |    |    |    |         |         |
+ *        |   5+---&gt;|  3 +---&gt;|   2+---&gt;|   4+---&gt;|
+ *        |      x  |      x  |   x|    |   x|    |
+ *        |         |         |    v    |    v    |
+ *        +---------+---------+---------+---------+
+ *                  |    ^    |
+ *                  |    |x   |
+ *                  |&lt;---+    |
+ *                  |    6    |
+ *                  |         |
+ *                  +---------+
+ * </PRE>
+ * </FONT>
+ * Each cube face is divided into 4 areas; each area is further
+ * divided into four pieces, etc.
+ * The number of valid qboxes is <b>6&times;4<sup>N</sup></b>:
+ * <PRE>
+ *   Level    Lower #      qboxes   qbox_size
+ *      0           9           6     83&ordm;
+ *      1          36          24     41&ordm;
+ *      2         144          96     20&ordm;
+ *      3         576         384     10&ordm;
+ *      4        2304        1536      5&ordm;
+ *      5        9216        6144      2&ordm;30'
+ *      6       36864       24576      1&ordm;15'
+ *      7      147456       98304        40'
+ *      8      589824      393216        20'
+ *      9     2359296     1572864        10'
+ *     10     9437184     6291456         5'
+ *     11    37748736    25165824         2'30"
+ *     12   150994944   100663296         1'15"
+ * </PRE>
+ * where level is a number which can be changed at any time using
+ * <b>setLevel</b>(<EM>level</EM>) method.
+ * <P>
+ * The present implementation assumes that <EM>level<I><=12</I></EM>,
+ * corresponding to a maximum of 28 bits in the qbox number.
+ * <P>
+ * For a level 6, the qbox number is a short integer with bits
+ * (from left to right)
+ * <FONT COLOR='Blue'><TT>1ppp xyxy xyxy xyxy</TT></FONT>.
+ * The leftmost `1' bit allows the recognition of the level;
+ * bits <TT>p</TT> represent the face number (1 to 6),
+ * <TT>x</TT> and <TT>y</TT> the position, expressed with <EM>level</EM> bits,
+ * along the axises defined above for the face; going one level down
+ * in the hierarchy is therefore just a shift of 2 bits and
+ * updating the 2 rightmost bits.
+ **/
+
+public class QboxNumber implements Serializable {
+
+    /** Level of the chosen Qboxes (for creation), between 0 and 12 */
+    public final int level;
+    /* Variables common to the Class: all Definitions */
+    static private final double PIO2 = Math.PI / 2.;
+    static final boolean DEBUG = true;
+    static final int ANY = 0x80000000; // The 'ANY' status
+    static final int BOX = 0x7fffffff; // The ~ANY  bits
+    static private final int MAXLEVEL = 12;
+    /** Default level used in {@link #QboxNumber()}, 
+     * (default 9 or size about 10') */
+    static public int default_level = 9; // Default level: 1.6million of 10x10'
+    static private final char[] oct = "01234567".toCharArray();
+    static private final double DEG = 180. / Math.PI;
+    static final double[] MAXRAD = /* Max radius of Qbox  */ {
+       54.735610317, /* Level  0:   radius  54.73561/ 45.00000    */
+       30.361193405, /* Level  1:   radius  30.36119/ 21.79319    */
+       16.403086517, /* Level  2:   radius  16.40309/  9.61290    */
+    	8.639594386, /* Level  3:   radius   8.63959/  4.55775    */
+    	4.449359566, /* Level  4:   radius   4.44936/  2.21341    */
+    	2.259674852, /* Level  5:   radius   2.25967/  1.08995    */
+    	1.138910823, /* Level  6:   radius   1.13891/  0.54074    */
+    	0.571763982, /* Level  7:   radius   0.57176/  0.26930    */
+    	0.286464128, /* Level  8:   radius   0.28646/  0.13438    */
+    	0.143378220, /* Level  9:   radius   0.14338/  0.06713    */
+    	0.071725727, /* Level 10:   radius   0.07173/  0.03355    */
+    	0.035872027, /* Level 11:   radius   0.03587/  0.01677    */
+    	0.017938306  /* Level 12:   radius   0.01794/  0.00838    */
+    };
+    static final double[] SINRAD = /* Sine of above radii */ {
+    	0.8164965809277260, /* Level  0: Surface  6.875e+03 / 6.875e+03  */
+    	0.5054494651244236, /* Level  1: Surface  1.719e+03 / 1.719e+03  */
+    	0.2823931345695149, /* Level  2: Surface  4.170e+02 / 4.825e+02  */
+    	0.1502185901567493, /* Level  3: Surface  9.780e+01 / 1.250e+02  */
+    	0.0775779474805375, /* Level  4: Surface  2.345e+01 / 3.154e+01  */
+    	0.0394285430318791, /* Level  5: Surface  5.729e+00 / 7.904e+00  */
+    	0.0198764347423619, /* Level  6: Surface  1.415e+00 / 1.977e+00  */
+    	0.0099789983974146, /* Level  7: Surface  3.517e-01 / 4.944e-01  */
+    	0.0049997213877594, /* Level  8: Surface  8.766e-02 / 1.236e-01  */
+    	0.0025024194021835, /* Level  9: Surface  2.188e-02 / 3.090e-02  */
+    	0.0012518497600656, /* Level 10: Surface  5.466e-03 / 7.725e-03  */
+    	0.0006260849416742, /* Level 11: Surface  1.366e-03 / 1.931e-03  */
+    	0.0003130824920569  /* Level 12: Surface  3.415e-04 / 4.828e-04  */
+    };
+    static final double[] MINRAD = /* Min radius of Qbox  */ {
+       45.000000000000, /* Level  0:   radius  54.73561/ 45.00000    */
+       21.793189128656, /* Level  1:   radius  30.36119/ 21.79319    */
+    	9.612900642866, /* Level  2:   radius  16.40309/  9.61290    */
+    	4.557754524215, /* Level  3:   radius   8.63959/  4.55775    */
+    	2.213411995038, /* Level  4:   radius   4.44936/  2.21341    */
+    	1.089949904684, /* Level  5:   radius   2.25967/  1.08995    */
+    	0.540737084594, /* Level  6:   radius   1.13891/  0.54074    */
+    	0.269302913463, /* Level  7:   radius   0.57176/  0.26930    */
+    	0.134384274203, /* Level  8:   radius   0.28646/  0.13438    */
+    	0.067125244187, /* Level  9:   radius   0.14338/  0.06713    */
+    	0.033545886680, /* Level 10:   radius   0.07173/  0.03355    */
+    	0.016768757962, /* Level 11:   radius   0.03587/  0.01677    */
+    	0.008383332446  /* Level 12:   radius   0.01794/  0.00838    */
+    };
+    static private final boolean[] move_x = /* for adjacent boxes */ {
+	true, false, false, true 	// 0=+x, 1=+y, 2=-y, 3=-x
+    };
+    /* List of adjacent faces, when moving toward one of +x +y -y -x
+     * The face is flagged by 8 when a rotation of the axes occurs
+     * at the border (always a rotation of +pi/2)
+     */
+    static private final byte[][] adj_face = {
+	{0,  2,8|6,8|2,  6,  3,8|3,0},	// ... when x >= 1 (0)
+	{0,8|4,  4,  1,8|5,8|1,  5,0},	// ... when y >= 1 (1)
+	{0,  3,8|3,8|6,  2,  6,8|2,0},	// ... when y < -1 (2)
+	{0,8|5,  1,  5,8|1,8|4,  4,0}	// ... when x < -1 (3)
+    };
+    static private final byte[][] adj_move = {
+	{ 2, 3, 4, 5 },			// (0) toward +x
+	{ 1, 4, 3, 6 },			// (1) toward +y 
+	{ 5, 0, 7, 2 },			// (2) toward -y 
+	{ 6, 7, 0, 1 }			// (3) toward -x
+    };
+    /* Neighbour coordinate indices for the computation of corners
+     * (4=Xo, 5=Yo) */
+    static private final byte[] nearby_xy = {
+	025, 043, 041, 005, 023, 021, 001, 003 
+    };
+
+    /*==================================================================*
+      			Initialisations
+     *==================================================================*/
+
+    /** 
+     * Change the default level.
+     * It is a change of the <em>static</em> <b>default_level</b> variable.
+     * This means that the creation of a class from the default
+     * {@link #QboxNumber()} will use the specified level.
+     * @param	lev the default level, between 0 and 12.
+     * 		Values outside the [0..12] range are ignored.
+     * @return	the previously defined default level
+     **/
+    public static final int setLevel(int lev) {
+    	int old_lev = default_level;
+    	if ( (lev >= 0) && (lev <= 12)) 
+    	    default_level = lev;
+    	return (old_lev);
+    }
+
+    /*==================================================================*
+      			Vectorial basic operations
+     *==================================================================*/
+
+    /** Compute the distance between 2 vectors
+     * @param	v1 first vector
+     * @param   v2 second vector
+     * @return	the squared distance ||v1-v2||^2
+     **/
+    static double dist2(double[] v1, double[] v2) {
+    	double r, d;
+    	r = v1[0] - v2[0];
+    	r *= r;
+    	d = v1[1] - v2[1];
+    	d *= d;
+    	r += d;
+    	d = v1[2] - v2[2];
+    	d *= d;
+    	r += d;
+    	return (r);
+    }
+
+    /** Compute the dot-product (scalar product)
+     * @param	v1 first vector
+     * @param   v2 second vector
+     * @return	the dot-product
+     **/
+    static double dotprod(double[] v1, double[] v2) {
+    	return (v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]);
+    }
+
+    /** Compute the square norm of a vector
+     * @param	v1 the vector
+     * @return	the squared norm
+     **/
+    static double norm2(double[] v1) {
+    	return (dotprod(v1, v1));
+    }
+
+    /** Compute the vectorial product
+     * @param	v1 first vector
+     * @param   v2 second vector
+     * @param   r the returned resulting vector
+     **/
+    static void vecprod(double[] v1, double[] v2, double[] r) {
+    	r[0] = v1[1] * v2[2] - v1[2] * v2[1];
+    	r[1] = v1[2] * v2[0] - v1[0] * v2[2];
+    	r[2] = v1[0] * v2[1] - v1[1] * v2[0];
+    }
+
+    /** Compute the determinant
+     * @param	v1 first vector
+     * @param   v2 second vector
+     * @param	v3 third vector
+     * @return	the determinant = (v1^v2).v3 = (v2^v3).v1 = (v3^v1).v2
+     **/
+    static double det(double[] v1, double[] v2, double[] v3) {
+    	double[] v = new double[3];
+    	vecprod(v1, v2, v);
+    	return (dotprod(v, v3));
+    }
+
+    /*==================================================================*
+      			Internal Routines
+     *==================================================================*/
+
+    /** Compute the Center of a Qbox
+     * @param	qboxno the qbox number
+     * @param	XY the position of the center
+     * @return	the cube face number in range <b>[1..6]</b> (0 if error)
+     **/
+    private static final int center_(int qboxno, double[] XY) {
+    	int b = qboxno & BOX;
+    	int x = 0, y = 0;
+    	double f;
+    	int qlev;
+    	if (b < 9) {		// Whole sphere
+    	    XY[0] = 0.;
+    	    XY[1] = 0.;
+    	    return (0);
+    	}
+    	for (qlev = 0; (b & (~0xf)) != 0; qlev++) {
+    	    y |= (b & 1) << qlev;
+    	    b >>>= 1;
+    	    x |= (b & 1) << qlev;
+    	    b >>>= 1;
+    	}
+    	/* Now qlev is the level of this Qbox, b is the face number */
+    	f = (1 << qlev); // 2**qlev, The maximal value for this level
+
+    	XY[0] = Math.tan( ( ( (x + 0.5) / f) - 0.5) * PIO2);
+    	XY[1] = Math.tan( ( ( (y + 0.5) / f) - 0.5) * PIO2);
+    	return(b&7);
+    }
+
+    /** Compute the Corners of a Qbox from qbox number
+     * @param	qboxno the qbox number
+     * @param	blur the (xy) position of Bottom-Left-Up-Right points
+     * @return	the cube face number in range 1..6 (0 if error)
+     **/
+    static final int corners(int qboxno, double[] blur) {
+    	int b = qboxno & BOX;
+    	int x = 0, y = 0;
+    	int qlev;
+    	double f;
+    	if (b == 0) {
+    		return (0); // Whole Sky
+    	}
+    	/* Compute the level, and the (x,y) position in this level */
+    	for (qlev = 0; (b & (~15)) != 0; qlev++) {
+    	    y |= (b & 1) << qlev;
+    	    b >>= 1;
+    	    x |= (b & 1) << qlev;
+    	    b >>= 1;
+    	}
+    	f = (1 << qlev);
+    	/* Lower-left corner */
+    	blur[0] = Math.tan( ( (x / f) - 0.5) * PIO2);
+    	blur[1] = Math.tan( ( (y / f) - 0.5) * PIO2);
+    	x++;
+    	y++;
+    	blur[2] = Math.tan( ( (x / f) - 0.5) * PIO2);
+    	blur[3] = Math.tan( ( (y / f) - 0.5) * PIO2);
+
+    	return (b & 7);
+    }
+
+    /** Compute the 4 vectors representing the corners of a Qbox.
+     * @param	qboxno the qbox number
+     * @param	ucorn a [4][3] array
+     * @return	the cube face number in range 1..6 (0 if error)
+     **/
+    static final int ucorners(int qboxno, double[][] ucorn) {
+    	double[] XY = new double[4];
+    	int face;
+    	face = corners(qboxno, XY);
+    	if (face == 0) 
+    	    return (face);
+    	Coocube.setUvec(face, XY[0], XY[1], ucorn[0]);
+    	Coocube.setUvec(face, XY[2], XY[1], ucorn[1]);
+    	Coocube.setUvec(face, XY[2], XY[3], ucorn[2]);
+    	Coocube.setUvec(face, XY[0], XY[3], ucorn[3]);
+    	return(face);
+    }
+
+    /*==================================================================*
+      			Which level, from resolution
+     *==================================================================*/
+
+    /** 
+     * Estimate level from resolution.
+     * The level is such that any source having a diameter up to 
+     * <em>arcmin</em> is not larger than a Qbox, i.e. requires to look only
+     * at the target Qbox and its neighbours (see {@link #nearby})
+     * @param  arcmin  resolution, in arcmin.
+     * @return the suggested level, in range <b>[0..12]</b>
+     **/
+    static final int level(double arcmin) {
+	int i = MINRAD.length;
+	double rad = arcmin/60.;
+	while (--i>0) {
+	    if (MINRAD[i] > rad) 
+		return(i);
+	}
+	return(0);
+    }
+
+    /*==================================================================*
+      			Constructors
+     *==================================================================*/
+
+    /** 
+     * Class of Qbox numbers with default level.
+     * Notice that the <em>static</em> default level may be changed 
+     * with the {@link #setLevel} method.
+     */
+    public QboxNumber() {
+	this.level = default_level;
+    }
+
+    /** 
+     * Class of Qbox numbers with a specified level
+     * @param level the level to use as default
+     * Notice that the <em>static</em> default level may be changed 
+     * with the setLevel method.
+     */
+    public QboxNumber(int level) {
+	this.level = level;
+    }
+
+    /** 
+     * Class of Qbox numbers with a specified resolution.
+     * The level computed is such that any source having a diameter up to 
+     * <em>arcmin</em> is not larger than a Qbox, i.e. requires to look only
+     * at the target Qbox and its neighbours (see {@link #nearby})
+     * @param  arcmin  resolution, in arcmin.
+     **/
+     public QboxNumber(double arcmin) {
+	 this.level = level(arcmin);
+     }
+
+    /** 
+     * Interpret an edited Qbox number (see {@link #toString(int)})
+     * @param	text The text to interpret
+     * @throws	ParseException when the text contains invalid characters
+     **/
+    static public int qbox(String text) throws ParseException {
+    	char[] a = text.toCharArray();
+    	int error = 0;
+    	int qbox = 0;
+    	int i = 0;
+
+	// Skip leading blanks
+	while ((i<a.length) && (a[i] == ' ')) i++;
+
+	// An empty string means "whole sphere" (value 0)
+    	if (i >= a.length) 
+    	    return(qbox);
+
+	// Get face number
+    	if ( (a[i] >= '1') && (a[i] <= '6')) 
+    	     qbox = 8 | Character.digit(a[i], 8);
+    	else error++;
+    	++i;
+
+	// Accept : or . between face# and cell#
+    	if ( (i < a.length) && ((a[i] == ':')||(a[i] == '.')))
+    	    i++;
+
+	// Interpret the cell# made of digits in base 4.
+    	while ( (i < a.length) && (a[i] >= '0') && (a[i] < '4')) {
+    	    qbox = (qbox << 2) | Character.digit(a[i], 4);
+    	    ++i;
+    	}
+
+	// Accept trailing 'A' for 'All'
+    	if ( (i < a.length) && (Character.toUpperCase(a[i]) == 'A')) {
+    	    ++i;
+    	    qbox |= ANY;
+    	}
+
+	// Accept final blanks
+	while ((i<a.length) && (a[i] == ' ')) i++;
+
+	// Verify all characters interpreted.
+    	if (i < a.length)
+    	    error++;
+    	if (error > 0) {
+    	    throw new ParseException
+    	    	("****QboxNumber: '" + text + "'+" + i, i);
+    	}
+	return(qbox);
+    }
+
+    /*==================================================================*
+      			Manipulation of Qboxes
+     *==================================================================*/
+
+    /** 
+     * Derive the level of a Qbox number.
+     * @param	qbox a Qbox number.
+     * @return	the level corresponding to the integer (between -1 and 12)
+     **/
+    public static final int level(int qbox) {
+    	int n = 0;
+    	qbox &= BOX;
+    	if (qbox == 0) 		// While sphere
+    	    return ( -1);
+	// Speed-up
+    	if ( (qbox & 0x7fff0000) != 0) {
+    	    n = 7;
+    	    qbox >>>= 14;
+    	}
+    	while ( (qbox & (~0xf)) != 0) {
+    	    qbox >>>= 2;
+    	    n++;
+    	}
+    	return (n);
+    }
+
+    /** 
+     * Interpret the qbox as an index (offset) number.
+     * @param	qbox a Qbox number.
+     * @return	a number between <b>0</b> and <b>6&times;4<sup>N</sup>-1</b>
+     * 		which can be used e.g. as an index in an array.
+     **/
+    public static final int index(int qbox) {
+    	int n = level(qbox);
+    	int i = (qbox & BOX) - (9 << (n<<1));
+    	if (i < 0) {
+    	    i += 8;
+    	}
+    	return(i);
+    }
+
+    /** 
+     * Face number on which the qbox is located.
+     * @return	the face number, between <b>1</b> and <b>6</b> .
+     * A value of <b>0</b> is returned when <tt>qbox=0</tt> (whole sphere)
+     **/
+    static public final int face(int qbox) {
+    	int n = level(qbox);
+    	if (n < 0) 
+    	    return (0);
+    	return ( (qbox >>> (n<<1)) & 7);
+    }
+
+    /*==================================================================*
+      			Setting a Qbox from known information
+     *==================================================================*/
+
+    /** 
+     * Compute qbox number at the specified level.
+     * @param	level the level, between <b>0</b> and <b>12</b>
+     * @param	face  the face number, between <b>1</b> and <b>6</b>
+     * @param	X     projection along X-axis, in range <b>[-1 ... +1[</b>
+     * @param	Y     projection along Y-axis, in range <b>[-1 ... +1[</b>
+     **/
+    static private final int boxno(int level, int face, double X, double Y) {
+    	double xy;
+    	int x, y, i, count;
+    	int qbox = face;
+    	qbox |= 8; 	// Insert bit which gives the level
+
+    	// Compute x and y, integer parts of X and Y scaled
+    	count = 1 << level;	// 2**level = value of x(y) when X(Y)=+1
+    	xy = (0.5 + Math.atan(X) / PIO2) * count;
+    	x = (int) xy;
+    	xy = (0.5 + Math.atan(Y) / PIO2) * count;
+    	y = (int) xy;
+    	if (x >= count) x = count - 1;
+    	if (y >= count) y = count - 1;
+	if (x < 0) x = 0;
+	if (y < 0) y = 0;
+
+    	// Add the interleaved bits of x and y
+    	qbox <<= (level << 1);	// Face number at its corect bit position
+    	for (count >>= 1, i = level - 1; count > 0; count >>= 1, i--) 
+    	    qbox |= ( ( (x & count) << i) << 1) | ( (y & count) << i);
+        return(qbox);
+    }
+
+    /** 
+     * Identifies the Qbox containing a position given by RA and Dec.
+     * @param	lon   the longitude (RA), degrees
+     * @param	lat   the latitude  (Dec), degrees
+     **/
+    public final int qbox(double lon, double lat) {
+    	double[] XY = new double[2];
+    	double[]  u = new double[3];
+	Coo.setUvec(lon, lat, u);	// compute direction cosines
+	int qbox = Coocube.setXY(u, XY);
+    	return(boxno(level, qbox, XY[0], XY[1]));
+    }
+
+    /** 
+     * Identifies the Qbox containing a position given by a Coocube.
+     * @param	cc the Coocube equivalent of the position
+     **/
+    public final int qbox(Coocube cc) {
+    	return(boxno(level, cc.face, cc.X, cc.Y));
+    }
+
+    /** 
+     * Identifies the Qbox containing a given position.
+     * @param	c the Coocube equivalent of the position
+     **/
+    public final int qbox(Coo c) {
+    	double[] XY = new double[2];
+	double[]  u = new double[3];
+	u[0] = c.x; u[1] = c.y; u[2] = c.z;
+    	int qbox = Coocube.setXY(u, XY);
+	return(boxno(level, qbox, XY[0], XY[1]));
+    }
+
+    /*==================================================================*
+      			Transform a Qbox into its central Position
+     *==================================================================*/
+
+    /** 
+     * Get the central position of a Qbox
+     * @param	qbox   a Qbox number
+     **/
+    static public final Coo center(int qbox) {
+	double[]  u = new double[3];
+    	double[] XY = new double[2];
+	int face = center_(qbox, XY);
+	if (DEBUG) System.out.println("....center: face=" + face 
+		+ ", XY=" + XY[0] + "," + XY[1]);
+	Coocube.setUvec(face, XY[0], XY[1], u);
+	Coo coo = new Coo(u[0], u[1], u[2]);
+	coo.dump("Center");
+    	return(coo);
+    }
+
+    /** 
+     * Set the central position of a Qbox
+     * @param	qbox   a Qbox number
+     * @param	coo    a Coo, filled with the position.
+     **/
+    static public final void center(int qbox, Coo coo) {
+	double[]  u = new double[3];
+    	double[] XY = new double[2];
+	int face = center_(qbox, XY);
+	Coocube.setUvec(face, XY[0], XY[1], u);
+	coo.set(u[0], u[1], u[2]);
+    }
+
+    /*==================================================================*
+      			Compute accurate Qbox elements
+     *==================================================================*/
+
+    /** 
+     * Radius of circle containing any Qbox. 
+     * It is the radius of a small circle centered at a Qbox center
+     * which includes any Qbox (at level).
+     * @return	The maximal radius
+     **/
+    public final double maxRadius() {
+    	return (MAXRAD[level]);
+    }
+
+    /** 
+     * Radius of circle included in any Qbox.
+     * It is the radius of a small circle centered at a Qbox center
+     * which is completely included within any Qbox (at level).
+     * @return	The minimal radius
+     **/
+    public final double minRadius() {
+    	return (MINRAD[level]);
+    }
+
+    /** Compute the area (in square degrees) of a Qbox.
+     *	Use the ArcSin formula
+     *  		S = A_0 + A_1 + A_2 + A_3 - 2*pi
+     *		where A_i are the angles of the rectangle.
+     *		The formula is especially simple in a tangential projection.
+     * @param  qbox the Qbox number
+     * @return	The area for the Qbox in square degrees.
+     **/
+    static public final double area(int qbox) {
+    	double[] XY = new double[4];
+    	double S;
+    	int i;
+    	// Compute the Corners
+    	corners(qbox & BOX, XY);
+    	for (i = 0; i < 4; i++) 
+    	    XY[i] /= Math.sqrt(1. + XY[i] * XY[i]);
+    	S = Math.asin(XY[0] * XY[1]) + Math.asin(XY[2] * XY[3])
+    	  - Math.asin(XY[0] * XY[3]) - Math.asin(XY[1] * XY[2]);
+    	return (DEG * DEG * Math.abs(S));
+    }
+
+    /** 
+     * Compute radius (degrees) of the Circle including a Qbox.
+     * @param  qbox the Qbox number
+     * @return	The radius of a circle centered at the Qbox center and
+     * 		containing the Qbox.
+     **/
+    static public final double radius(int qbox) {
+    	double[] XY = new double[4];
+    	double[] XYc = new double[2];
+    	double s2r, num, den, denc, X, Y, rmax = 0;
+    	int i;
+    	// Compute the Center and Corners
+    	center_(qbox & BOX, XYc);
+    	corners(qbox & BOX, XY);
+    	denc = 1. + XYc[0] * XYc[0] + XYc[1] * XYc[1];
+    	for (i = 0; i < 4; i++) {
+    	    X = XY[i & 2];
+    	    Y = XY[ ( (i & 1) << 1) | 1];
+    	    den = denc * (1. + X * X + Y * Y);
+    	    num = X * XYc[1] - Y * XYc[0];
+    	    num *= num;
+    	    X -= XYc[0];
+    	    Y -= XYc[1];
+    	    num += X * X + Y * Y;
+    	    s2r = num / den;
+    	    if (s2r > rmax) {
+    	    	rmax = s2r;
+    	    }
+    	    if (DEBUG) {
+    	    	System.out.println("....radius(): corner#" + i + "("
+    	         + (i & 2) + "," + ( ( (i & 1) << 1) | 1) 
+                 + ") -- X,Y=" + X + "," + Y 
+		 + "\n          s2r=" + s2r);
+    	    }
+    	}
+    	return (DEG * Math.asin(Math.sqrt(rmax)));
+    }
+
+    /*==================================================================*
+    				Nearby boxes
+     *==================================================================*/
+
+    /** 
+     * Find the adjacent qbox in the specified direction.
+     * @param	qboxno the starting qbox
+     * @param	direction A direction, as a number 0 to 3.
+     * 		The direction has the values 
+     * 		<b>0</b>=<b>+x</b>
+     * 		<b>1</b>=<b>+y</b>
+     * 		<b>2</b>=<b>-y</b>
+     * 		<b>3</b>=<b>-x</b>
+     * @return	the qbox (at the same level) contiguous in the specified 
+     * 		direction.
+     **/
+    static public final int adjacent(int qboxno, int direction) {
+	int r = 0;		// remainder of qboxno
+	int shifted = 0;	// how many shifts in the hierarchy
+	int qb = qboxno;	// qbox number to return
+	int dir = direction&3;	// any direction is valid...
+	int k;
+
+	/* We try first to move in the 2x2 cell.
+	 * If not possible, move up 1 level in the hierarchy.
+	 * There is a problem when the face number changes,
+	 * which is indicated by a level<0, or qb < 15
+	 */
+	while ((qb&(~15)) != 0) {
+	    k = adj_move[dir][qb&3];
+	    if ((k&4)!=0) {	// At the limit of the 2x2 cells
+		r |= (k^4)<<shifted;
+		qb >>= 2;	// ... one level up
+		shifted += 2;
+	    }
+	    else {
+		qb = (qb&(~3))|k;
+		break;
+	    }
+	}
+	
+	if ((qb&(~15)) == 0) {		// We're here at problematic level=0...
+	    k = adj_face[dir][qb&7];	// Here k>=8 when axis direction changes
+	    if ((k&8)!=0) {
+		// Change of axes: rotation of pi/2, i.e. x-->-y, y-->x
+		int comb = 0;		// "comb" to select y bits
+		for (qb=shifted; qb>0; qb -= 2) 
+		    comb = (comb<<2) | 2;
+		if (move_x[dir])	// Change the "comb" to pick x bits
+		    comb >>= 1;
+		r = (qboxno&comb)^comb;	// r contains now (-y) or (-x) bits
+		if (move_x[dir]) r <<= 1;	
+		else             r >>= 1;
+		// Move toward negative x/y: cell value is maximal.
+		if ((dir&2)!=0)     r |= comb;
+	    }
+	    qb = 8|k;
+	}
+
+	if (shifted>0) {
+	    qb <<= shifted;
+	    qb |= r;
+	}
+
+	return(qb);
+    }
+
+    /** 
+     * Identifies the 8 qboxes contiguous to one qbox.
+     * @param	qboxno the starting qbox
+     * @param	contig [8] the eight contiguous qboxes.
+     * The 8 contiguous qboxes are given in the following order:
+     * <FONT COLOR='Blue'><PRE>
+     *    +---+---+---+
+     *    | 7 | 1 | 4 |
+     *    +---+---+---+
+     *    | 3 | . | 0 |
+     *    +---+---+---+
+     *    | 6 | 2 | 5 |
+     *    +---+---+---+
+     * </PRE> </FONT>
+     * Notice that near the corners, only 7 contiguous qboxes exist;
+     * the value of the missing qbox is set to 0. And at the zero level
+     * (i.e. only 6 qbxoes) there are only 4 contiguous qboxes.
+     **/
+    static public final void nearby(int qboxno, int[] contig) {
+	// Highest index, used to decide whether 2 qboxes lie on the same face.
+	int qbmax = 1 << (level(qboxno)<<1);
+	int nb = 4;		// Number of boxes found.
+	boolean[] same_face 	// adjacent qboxes on the same face as qboxno ?
+	    = new boolean[4];
+	int i;
+
+	// First first the 4 adjacent qboxes
+	for (i=0; i<4; i++) {
+	    contig[i] = adjacent(qboxno, i);
+	    same_face[i] =  (contig[i] ^ qboxno) < qbmax;
+	}
+
+	// Explore how to deal with corners :
+	contig[4] = contig[5] = contig[6] = contig[7] = 0;
+	if (same_face[0]) {
+	    contig[4] = adjacent(contig[0], 1);
+	    contig[5] = adjacent(contig[0], 2);
+	    nb += 2;
+	}
+	if (same_face[3]) {
+	    contig[6] = adjacent(contig[3], 1);
+	    contig[7] = adjacent(contig[3], 2);
+	    nb += 2;
+	}
+	if (nb>=7) return;
+
+	// Not all contiguous qboxes could be found:
+	if (same_face[1]) {
+	    if (contig[4]==0) {			
+		contig[4] = adjacent(contig[1], 0);	// #1 toward +x 
+		nb++; 
+	    }
+	    if (contig[7]==0) {
+		contig[7] = adjacent(contig[1], 3);	// #1 toward -x
+		nb++;
+	    }
+	}
+	if (nb>=7) return;
+
+	// Still not all contiguous qboxes found...
+	if (same_face[2]) {
+	    if (contig[5] == 0) {
+		contig[5] = adjacent(contig[2], 0);	// #5 toward +x
+		nb++; 
+	    }
+	    if (contig[6] == 0) {
+		contig[6] = adjacent(contig[2], 3);	// #5 toward -x
+		nb++;
+	    }
+	}
+    }
+
+    /** 
+     * Identifies the 9 qboxes close to a target position.
+     * @param	center a Coo position
+     * @param	contig [9] the 9 neighbouring qboxes, ordered by increasing
+     * 		distance fom <em>center</em>
+     * @param	sin2d2 [9]    closest squared distance 
+     * 		(in <em>SIN2</em> projection where <em>r=2.sin(r/2)</em>).
+     * 		The actual distance between  <em>center</em> and 
+     * 		<em>contig[i]</em> (in <em>degrees</em>)
+     * 		can be computed as 
+     * 		<em>r = 2. * AstroMath.asind(0.5 * Math.sqrt(sin2d2))</em>
+     * @return  Number of qboxes (5, 8 or 9) in the <em>contig</em> 
+     * 		and <em>in2d2</em> arrays.
+     **/
+    public final int nearby(Coo center, int[] contig, double[] sin2d2) {
+	// First the qbox containing the position!
+	int qbox = qbox(center);
+	double[]  cXY = new double[2];	// Coordinates of center
+	double[] coin = new double[4];	// corners
+	double[]    u = new double[3];	// Direction cosine
+	double[]   XY = new double[2];	// Projected coordinates
+	int face = corners(qbox, coin);
+	int i, ix, iy;
+	int nb = 9;			// Numpber of qboxes returned.
+	double du, w;
+
+	nearby(qbox, contig);		// get the 4, 7 or 8 nearby qboxes
+	u[0] = center.x; u[1] = center.y; u[2] = center.z;
+    	Coocube.setXY(u, cXY);		// compute cXY
+
+	/* Compute the distances (4sin^2(r/2)) of 8 neighbors */
+	for (i=0; i<8; i++) {
+	    if (contig[i] == 0)	{	// in a corner of the cube
+		sin2d2[i] = 4.;		// corresponds to a 180deg distance
+		--nb;
+		continue;
+	    }
+	    ix = nearby_xy[i]>>3;	// 1st octal number
+	    iy = nearby_xy[i] &7;	// 2nd octal number
+	    XY[0] = (ix&4)==0 ? coin[ix] : cXY[ix^4];
+	    XY[1] = (iy&4)==0 ? coin[iy] : cXY[iy^4];
+	    Coocube.setUvec(face, XY[0], XY[1], u);
+	    du = (u[0] - center.x); w  = du*du;
+	    du = (u[1] - center.y); w += du*du;
+	    du = (u[2] - center.z); w += du*du;
+	    sin2d2[i] = w;
+	}
+	// Simple swap sort
+	for (ix=0; ix<7; ix++) for (iy=ix+1; iy<8; iy++) {
+	    if (sin2d2[ix] <= sin2d2[iy]) continue;
+	    // swap distances & qbox#
+	    w = sin2d2[ix]; sin2d2[ix] = sin2d2[iy]; sin2d2[iy] = w;
+	    i = contig[ix]; contig[ix] = contig[iy]; contig[iy] = i;
+	}
+	// Move target qbox as the first.
+	for (i=8; i>0; i--) {
+	    contig[i] = contig[i-1];
+	    sin2d2[i] = sin2d2[i-1];
+	}
+	contig[0] = qbox;
+	sin2d2[0] = 0;
+
+	return(nb);
+    }
+
+    /*==================================================================*
+    				Edition
+     *==================================================================*/
+
+    /** 
+     * Edition of a Qbox value
+     * @return	the string equivalent of the coocube
+     * 		the letter 'A' is appended for ANY IN QBOX.
+     **/
+    static public final String toString(int qbox) {
+    	char[] buf = new char[20];
+    	int i = buf.length;
+    	int b = qbox;
+    	if ( (b & ANY) != 0) {
+    	    buf[--i] = 'A';
+    	    b &= BOX;
+    	}
+    	while ( (b & (~0xf)) != 0) {
+    	    buf[--i] = oct[b & 3];
+    	    b >>>= 2;
+    	}
+    	if (b != 0) {
+    	    buf[--i] = ':';
+    	}
+    	buf[--i] = oct[b & 7];
+    	return (new String(buf, i, buf.length - i));
+    }
+
+    /** 
+     * Edition of Qbox level
+     * @return	a string.
+     **/
+    public final String toString() {
+	return("[QboxNumber(" + level + ")]");
+    }
+
+}
Index: aladin/cds/astro/Supergal.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Supergal.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,99 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/*==================================================================
+                Galactic  (Astroframe -> Supergal)
+ *==================================================================*/
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * The Supergalactic frame is defined such (0,0) represents the direction 
+ * toward the center of the Local Group of galaxies.
+ * The Supergalactic frame is defined by reference to the Galactic System.
+ *  
+ * @author Francois Ochsenbein (CDS)
+ *
+ */
+
+public class Supergal extends Astroframe {
+
+  /**
+   * Name of this frame
+  **/
+    static public String class_name = "Supergal";
+
+  /** 
+   * Supergalactic is defined on Galactic.
+   * We therefore need the knowledge of the Galactic system.
+  **/
+
+   /**
+    * Constants for Galactic to SuperGalactic.
+    * Pole of SuperGalactic at (Glon, Glat) = 47.37 +06.32
+    * longitude of ascending node = 0.0
+   **/
+
+   /** 
+    * Rotation matrix to move from Galactic to Supergalactic. 
+   **/
+    static public final double[][] supergal = {  // Euler(-90, 83.68, -47.37)
+      {-0.7357425748043749, 0.6772612964138942,        0.},
+      {-0.0745537783652337,-0.0809914713069767, 0.9939225903997749},
+      { 0.6731453021092076, 0.7312711658169645, 0.1100812622247821}
+    };
+
+   // ===========================================================
+   // 			Constructor
+   // ===========================================================
+
+  /**
+   * Instanciate an Supergal frame. Default epoch is B1950.
+  **/
+    public Supergal() {
+    	this.precision = 5;	// Intrinsic precision = 1arcsec 
+	this.name = class_name;
+	epoch = 2000.;		// May be changed by setFrameEpoch()
+    }
+
+   // ===========================================================
+   // 			toICRSmatrix
+   // ===========================================================
+
+   /**
+    * Defines the rotation matrix to rotate to ICRS
+    * @return the 3x3 rotation matrix to convert a position in ICRS frame
+    * = (supergal * gal_2000)<sup>t</sup>
+   **/
+    public double[][] toICRSmatrix() {
+	if (ICRSmatrix == null) ICRSmatrix = AstroMath.m3t(
+		AstroMath.m3p(supergal, Galactic.gal_2000));
+    	return(ICRSmatrix);
+    }
+
+   // ===========================================================
+   // 			Convert to FK5
+   // ===========================================================
+
+   // Default methods are OK.
+
+}
Index: aladin/cds/astro/Udef.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Udef.java	2012-09-27 15:30:32.000000000 +0200
@@ -0,0 +1,66 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/**
+ *==========================================================================
+ * @author: Francois Ochsenbein -- francois@astro.u-strasbg.fr
+ * @version: 0.7 07-sep-2002
+ * @version: 0.9 15-sep-2002: 
+ * @version: 1.0 01-sep-2006: <tt>orig</tt> added
+ *==========================================================================
+ */
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/**
+ * This class defines what is a unit; it is required for the Unit class.
+ * It is used by Unit, and is not public.
+ */
+
+class Udef {
+    public String symb;	// Symbol, in principle letters only
+    public String expl;	// Text used in 'explain' method
+    public   long mksa;	// The interpretation in terms of units
+    public double fact;	// How to convert to SI
+    public double orig;	// Origin from SI unit.
+
+    /* CONSTRUCTOR */
+    public Udef(String s, String text, long m, double f) {
+	symb = s;
+	expl = text ;
+	mksa = m;
+	fact = f;
+	orig = 0.;
+    }
+    public Udef(String s, String text, long m, double f, double o) {
+	symb = s;
+	expl = text ;
+	mksa = m;
+	fact = f;
+	orig = o;
+    }
+
+    /* EDITOR */
+    public final String toString() {
+	return(symb + ": " + expl);
+    }
+}
Index: aladin/cds/astro/Unit.java
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ aladin/cds/astro/Unit.java	2012-09-27 15:30:34.000000000 +0200
@@ -0,0 +1,2416 @@
+// Copyright 2010 - UDS/CNRS
+// The Aladin program is distributed under the terms
+// of the GNU General Public License version 3.
+//
+//This file is part of Aladin.
+//
+//    Aladin is free software: you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation, version 3 of the License.
+//
+//    Aladin is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+//
+//    The GNU General Public License is available in COPYING file
+//    along with Aladin.
+//
+
+package cds.astro;
+
+/**
+ *==========================================================================
+ * @author  Fran&ccedil;ois Ochsenbein -- francois@astro.u-strasbg.fr
+ * @version 0.7 07-sep-2002
+ * @version 0.9 15-sep-2002: 
+ * @version 1.0 15-Aug-2004: added getUnit getValue setUnit setValue parse
+ * @version 1.1 02-Sep-2006: Unicode symbols
+ * @version 1.2 02-Nov-2006: Conversion of dates
+ *==========================================================================
+ */
+
+import java.util.*;
+import java.text.*;	// for parseException
+
+/*==================================================================
+                Unit class
+ *==================================================================*/
+
+/**
+ * Class able to deal with scientific units and make the appropriate
+ * conversions. 
+ * This class is an application of the
+ * "Adopted Standards for Astronomical Catalogues"
+ * (http://vizier.u-strasbg.fr/doc/catstd.htx).
+ * It is tightly related to the class {@link Converter} which can
+ * define <em>non-standard</em> conversions.
+ * <P>
+ * Basically, a unit consists in a <em>value</em> associated to a 
+ * <em>unit symbol</em> which is itself related to the SI 
+ * <em>(Syst&egrave;me International)</em>. Most of the unit symbols in use in 
+ * astronomy are included, but it is possible to add the definition of new units
+ * with their equivalence via the {@link #addSymbol} method.
+ * <P>
+ * The class can also deal with units expressed in <em>log scale</em> like
+ * <b>[km/s]</b> equivalent to <em>log(km/s)</em>, or in <em>mag scale</em>
+ * which is defined as <em>-2.5log</em>. Values may be transformed between the
+ * linear and log scales with the <b>log</b>, <b>mag</b> and <b>dexp</b>
+ * methods; conversions may also be performed via the <b>convert</b> methods.
+ * <P>
+ * The operations on units include the basic operations <b>plus</b>, 
+ * <b>minus</b>, <b>mult</b>, <b>div</b> and <b>power</b> and 
+ * the square root <b>sqrt</b>.  Addition or multiplications on physical values
+ * would however better use the <b>sum</b> or <b>prod</b> methods, which take
+ * care of converting the log scales. To illustrate the differences, assuming
+ * that <em>u1</em> and <em>u2</em> have the same content of <tt>5mag</tt>,
+ * the operation <tt>u1.add(u2)</tt> gives the result <tt>10mag</tt>,
+ * while <tt>u1.sum(u2)</tt> gives a value around <tt>4.25mag</tt>
+ * corresponding to the brightness of a source merging the two brightnesses.
+ * <P>
+ * For repetitive operations, like working on values from a table, it is
+ * suggested to use the <b>setValue</b> method which assigns the value
+ * but keeps the unit symbol and definition.
+ * <P>
+ * The numbers with their associated unit are edited as a single word
+ * (without embedded blanks); the SI equivalent may be edited with the
+ * <b>toStringInSI</b> method.
+ * The numbers in their edited form use an exponential notation 
+ * <em>m</em><tt>x10+</tt><em>n</em>; the classical form 
+ * <em>m</em><tt>E+</tt><em>n</em> is also correctly interpreted.
+ * Values in sexagesimal notation are also interpreted correctly in
+ * <b>setValue</b> provided their associated unit is <tt>"h:m:s"</tt> (time)
+ * or <tt>"d:m:s"</tt> (angle) --- note that the quotes <tt>"</tt> around the
+ * unit symbol are required!
+ * <P>
+ * An example of a program reading data all with the same <em>km/s</em> unit
+ * could be:
+ * <PRE>
+ * Unit aUnit = new Unit("km/s") ; 
+ * while (true) {
+ *     aUnit.setValue(stdin.readLine()) ;
+ *     System.out.println("Complete Value: " + aUnit);
+ *     System.out.println(" SI Equivalent: " + aUnit.toStringInSI());
+ *     System.out.println("  Unit Meaning: " + aUnit.explainUnit());
+ * }
+ * </PRE>
+ * 
+ * <P>The recursive (BNF) definition of a <b>Unit</b> is as follows:
+ * <PRE>
+ * Full_Unit = factor Complex_unit
+ * Complex_Unit = single_Unit
+ * 	        | single_Unit OP single_Unit
+ * 	        | "log[" single_Unit OP single_Unit "]"
+ * 	        | "mag[" single_Unit OP single_Unit "]"
+ * single_Unit  = extended_UnitSymbol
+ * 	        | extended_UnitSymbol power
+ * extended_UnitSymbol = UnitSymbol
+ * 	   	       | Magnitude_Prefix UnitSymbol
+ * 		       | "(" Full_Unit ")"
+ * power = Number
+ * 	 | +Number
+ * 	 | -Number
+ * OP	 = . | /
+ * </PRE>
+ *
+ */
+
+public class Unit {
+  /** The value, expressed in unit <B>symbol</B> */
+  public double value;		// The value expressed in "symbol" unit
+  /** The symbolic unit, like <em>km/s</em> */
+  public String symbol;		// The symbol for this Unit
+  /* protected String explain; */ /* Detailed explanation of the unit */
+  /** Exponents in 8 units "mag", "kg", "m", "s", "A", "K", "cd", "mol" */
+  private long mksa;		// Exponents in mag kg m s A K cd mol
+  private double factor;	// Factor to convert "symbol" into "SI"
+  private double offset;	// Shift from SI value
+
+  //  ===========================================================
+  //			Constants
+  //  ===========================================================
+  /** Definitions of the SI basic units */
+
+  /* The exponent in each component of SI is stored in a 6-bit (2 octal 
+   * digits), the 'zero' being represented by the _e0 (32=040) value.
+   * except for the Magnitude where it's represented by 02.
+   * The sign (leftmost) bit of the MKSA indicates a log scale
+   * of the unit; associated to the 'mag' bit (_mag), this
+   * indicates a 'mag' scale (-2.5log)
+  */
+  static final char[]  x = "0123456789abcdef".toCharArray();
+  static boolean initialized = false;
+  // static private byte accuracy = 8;	// Number of Significant Digits
+  static int DEBUG = 0;
+  static final private byte _e0 = 0x30 ;		// Unitless MKSA
+  static final private byte _m0 = 0x02 ;		// Unitless mag
+  static final private long _    = 0x0230303030303030L;	// Unitless
+  static final private long _LOG = 0x8100000000000000L;	// Mag or Log (~02)
+  static final private long _log = 0x8000000000000000L;	// Log scale
+  static final private long _mag = 0x0100000000000000L;	// Mag scale
+  static final private long _MJD = 0x4230303130303030L;	// Absolute (date)
+  static final private long _pic = 0x2000000000000000L;	// Use picture
+  static final private long _sex = 0x1000000000000000L;	// Use Sexagesimal
+  static final private long _abs = 0x4000000000000000L;	// Absolute flag
+  static final Editing editing = new Editing("-- ");	// Default NULL
+  // static private double scaling = 10.e-8;
+  static private Hashtable hUnit = new Hashtable(149);
+  static private Vector    aUnit = null;		// Additional Units
+  static private Hashtable hConv = new Hashtable(31);	// Special conversions
+  /** The list of basic symbols */
+  static final private String[] MKSA = {
+     "mag",               "kg", "m", "s", "A", "K", "cd", "mol"
+  };
+  static final private char[] MKSAdim = {
+      Character.MIN_VALUE, 'M', 'L', 'T', 'A', 'K', 
+      Character.MIN_VALUE, Character.MIN_VALUE };
+  static final private String[] mul_symb = {
+	"mu",		"da",		"k",		"m",
+	"c",		"u",		"M",		"n",
+	"G",		"d",		"h",		"p",
+	"T",		"f",		"P",		"a",
+	"E",		"z",		"Z",		"y",
+	"Y",		"\u00B5"
+  } ;
+  static final private String[] mul_text = {
+	"micro",	"deca",		"kilo",		"milli",
+	"centi",	"micro",	"mega",		"nano",
+	"giga",		"deci",		"hecto",	"pico",
+	"tera",		"femto(10-15)",	"peta(10+15)",	"atto(10-18)",
+	"exa(10+18)",	"zepto(10-21)",	"zetta(10+21)",	"yocto(10-24)",
+	"yotta(10+24)",	"micro"
+  } ;
+  static final private int[] mul_fact = {
+	-6,		1,		3,		-3,
+	-2,		-6,		6,		-9,
+	9,		-1,		2,		-12,
+	12,		-15,		15,		-18,
+	18,		-21,		21,		-24,
+	24,		-6
+  } ;
+
+  static final private String[] op_symb = {
+	"2",		"3",		"+",		"-",	
+	"/",		".",		"*",		" "
+  } ;
+  static final private String[] op_text = {
+	"square ",	"cubic ",	"power+",	"power-",	
+	"per ",		"times ",	"times ",	"times "
+  } ;
+
+  /* WARNING: index of "mag" in the following array must be >= 4 */
+  static final private String[] log_symb = {
+   	"log(",		"log[",		"[", 		"dex",
+	"mag(",		"mag["
+  } ;
+  static final private char[]   log_end = {
+  	')',		']',		']',	Character.MIN_VALUE,
+	')',		']'
+  };
+
+  //  ===========================================================
+  //                    Definitions of all symbols
+  //		(generated from  "gawk -f unit.awk")
+  //  ===========================================================
+
+  /*** List of ALL Symbols ***/
+
+  static final private Udef[] uDef = { 
+    new Udef("---"        , "",
+			     0x0230303030303030L, 1.0),
+    new Udef("%"          , "percent",
+			     0x0230303030303030L, 1.e-2),
+    new Udef("h"          , "hour ",
+			     0x0230303130303030L, 3.6e3),
+    new Udef("min"        , "minute ",
+			     0x0230303130303030L, 60.),
+    new Udef("s"          , "second ",
+			     0x0230303130303030L, 1.0),
+    new Udef("mag"        , "magnitude ",
+			     0x0330303030303030L, 1.0),
+    new Udef("Jy"         , "Jansky(10-26W/m2/Hz) ",
+			     0x0231302e30303030L, 1.e-26),
+    new Udef("deg"        , "degree ",
+			     0x0230303030303030L, (1./360.)),
+    new Udef("rad"        , "radian ",
+			     0x0230303030303030L, (0.5/Math.PI)),
+    new Udef("sr"         , "steradian ",
+			     0x0230303030303030L, (0.25/Math.PI)),
+    new Udef("arcmin"     , "minute of arc ",
+			     0x0230303030303030L, (1./21600.)),
+    new Udef("arcsec"     , "second of arc ",
+			     0x0230303030303030L, (1.e-3/1296.)),
+    new Udef("mas"        , "milli-second of arc ",
+			     0x0230303030303030L, (1.e-6/1296.)),
+    new Udef("uas"        , "micro-second of arc ",
+			     0x0230303030303030L, (1.e-9/1296.)),
+    new Udef("Sun"        , "Solar unit ",
+			     0x0230303030303030L, 1.0),
+    new Udef("solMass"    , "solar mass ",
+			     0x0231303030303030L, 1.989e+30),
+    new Udef("solRad"     , "solar radius ",
+			     0x0230313030303030L, 6.9599e+8),
+    new Udef("solLum"     , "solar luminosity ",
+			     0x0231322d30303030L, 3.826e+26),
+    new Udef("geoMass"    , "Earth mass ",
+			     0x0231303030303030L, 5.976e+24),
+    new Udef("jovMass"    , "Jupiter mass ",
+			     0x0231303030303030L, 1.902e+27),
+    new Udef("m"          , "metre ",
+			     0x0230313030303030L, 1.0),
+    new Udef("Hz"         , "Herz ",
+			     0x0230302f30303030L, 1.0),
+    new Udef("kg"         , "kilogram ",
+			     0x0231303030303030L, 1.0),
+    new Udef("g"          , "gram ",
+			     0x0231303030303030L, 1.e-3),
+    new Udef("K"          , "Kelvin ",
+			     0x0230303030313030L, 1.0),
+    new Udef("Pa"         , "Pascal ",
+			     0x02312f2e30303030L, 1.0),
+    new Udef("T"          , "Tesla ",
+			     0x0231302e2f303030L, 1.0),
+    new Udef("V"          , "Volt ",
+			     0x0231322d2f303030L, 1.0),
+    new Udef("W"          , "Watt ",
+			     0x0231322d30303030L, 1.0),
+    new Udef("J"          , "Joule ",
+			     0x0231322e30303030L, 1.0),
+    new Udef("eV"         , "electron-Volt ",
+			     0x0231322e30303030L, 1.602177e-19),
+    new Udef("Ry"         , "Rydberg(13.6eV) ",
+			     0x0231322e30303030L, 21.798948e-19),
+    new Udef("yr"         , "year ",
+			     0x0230303130303030L, 31.5576e+6),
+    new Udef("a"          , "year ",
+			     0x0230303130303030L, 31.5576e+6),
+    new Udef("d"          , "day ",
+			     0x0230303130303030L, 86.4e+3),
+    new Udef("AU"         , "astronomical unit ",
+			     0x0230313030303030L, 1.49598e+11),
+    new Udef("au"         , "astronomical unit ",
+			     0x0230313030303030L, 1.49598e+11),
+    new Udef("pc"         , "parsec ",
+			     0x0230313030303030L, 3.0857e+16),
+    new Udef("al"         , "light-year ",
+			     0x0230313030303030L, .946053e+16),
+    new Udef("JD"         , "Julian Date ",
+			     0x0230303130303030L|_abs, 86400,-86400.*2400000.5),
+    new Udef("pix"        , "pixel ",
+			     0x0230303030303030L, 1.0),
+    new Udef("ct"         , "count ",
+			     0x0230303030303030L, 1.0),
+    new Udef("ph"         , "photon ",
+			     0x0230303030303030L, 1.0),
+    new Udef("A"          , "Ampere ",
+			     0x0230303031303030L, 1.0),
+    new Udef("barn"       , "barn(10-28m2) ",
+			     0x0230323030303030L, 1.e-28),
+    new Udef("bit"        , "binary information unit ",
+			     0x0230303030303030L, 1.0),
+    new Udef("byte"       , "byte(8bits) ",
+			     0x0230303030303030L, 1.0),
+    new Udef("C"          , "Coulomb ",
+			     0x0230303131303030L, 1.0),
+    new Udef("D"          , "Debye (dipole)",
+			     0x0230313131303030L, (1.e-29/3.)),
+    new Udef("cd"         , "candela(lumen/sr) ",
+			     0x0230303030303130L, 1.0),
+    new Udef("F"          , "Farad ",
+			     0x022f2e3432303030L, 1.0),
+    new Udef("H"          , "Henry ",
+			     0x0231322e2e303030L, 1.0),
+    new Udef("lm"         , "lumen ",
+			     0x0230303030303130L, (0.25/Math.PI)),
+    new Udef("lx"         , "lux(lm/m2) ",
+			     0x02302e3030303130L, (0.25/Math.PI)),
+    new Udef("mol"        , "mole ",
+			     0x0230303030303031L, 1.0),
+    new Udef("N"          , "Newton ",
+			     0x0231312e30303030L, 1.0),
+    new Udef("Ohm"        , "Ohm(V/A) ",
+			     0x0231322d2e303030L, 1.0),
+    new Udef("S"          , "Siemens(A/V) ",
+			     0x022f2e3332303030L, 1.0),
+    new Udef("Wb"         , "Weber(V.s) ",
+			     0x0231322e2f303030L, 1.0),
+    new Udef("u"          , "atomic mass unit ",
+			     0x0231303030303030L, 1.6605387e-27),
+    new Udef("\u00B5as"   , "micro-second of arc ",
+			     0x0230303030303030L, (1.e-9/1296.)),
+    new Udef("\"d:m:s\""  , "degree arcminute arcsecond (sexagesimal angle from degree)",
+			     0x0230303030303030L|_sex, (1./360.)),
+    new Udef("\"h:m:s\""  , "hour minutes seconds (sexagesimal time from hours)",
+			     0x0230303130303030L|_sex, 3600.0),
+    new Udef("\"h:m\""    , "hour minutes (sexagesimal time from hours)",
+			     0x0230303130303030L|_pic, 3600.0),
+    new Udef("\"m:s\""    , "minutes seconds (sexagesimal time from minutes)",
+			     0x0230303130303030L|_pic, 60.0),
+    new Udef("\"hhmmss\"" , "hour minutes seconds (sexagesimal time without separator)",
+			     0x0230303130303030L|_pic, 3600.0  ),
+    new Udef("\"ddmmss\"" , "degree arcminute arcsecond (sexagesimal angle without separator)",
+			     0x0230303030303030L|_pic, (1./360.)),
+    new Udef("\"date\""   , "Fully qualified date",
+			     0x0230303130303030L|_MJD, 86400.),
+    new Udef("\"datime\"",  "Fully qualified date/time (ISO-8601)",
+			     0x0230303130303030L|_MJD, 86400.),
+    new Udef("\"YYYYMMDD\"" , "Fully qualified date (without separator)",
+			     0x0230303130303030L, 86400.),
+    new Udef("\"month\""  , "Month name or number (range 1..12)",
+			     0x0230303030303030L, 86400.),
+    new Udef("\"MM/YY\""  , "Month/Year(from 1900)",
+			     0x0230303130303030L, 86400.),
+    new Udef("\"MM/yy\""  , "Month/Year(from 2000 when yy<50)",
+			     0x0230303130303030L, 86400.),
+    new Udef("\"day\""    , "Day of month number",
+			     0x0230303030303030L, 86400.),
+    new Udef("pi"         , "pi(=3.14...)",
+			     0x0230303030303030L, Math.PI),
+    new Udef("\u03C0"     , "pi(=3.14...)",
+			     0x0230303030303030L, Math.PI),
+    new Udef("c"          , "c(speed_of_light)",
+			     0x0230312f30303030L, 299792458.),
+    new Udef("G"          , "G(gravitation constant)",
+			     0x022f332e30303030L, 6.673e-11),
+    new Udef("\\h"        , "hbar(Planck constant)",
+			     0x0231322f30303030L, 1.0545716e-34),
+    new Udef("\u210F"     , "hbar(Planck constant)",
+			     0x0231322f30303030L, 1.0545716e-34),
+    new Udef("e"          , "e(electron_charge) ",
+			     0x0230303131303030L, 1.602177e-19),
+    new Udef("k"          , "k(Boltzmann) ",
+			     0x0231322e302f3030L, 1.38065e-23),
+    new Udef("R"          , "R(gas_constant) ",
+			     0x0231322e302f302fL, 8.3143),
+    new Udef("mp"         , "mp(proton_mass) ",
+			     0x0231303030303030L, 1.672661e-27),
+    new Udef("me"         , "me(electron_mass) ",
+			     0x0231303030303030L, 9.109382e-31),
+    new Udef("a0"         , "(Bohr radius) ",
+			     0x0230313030303030L, 5.29177208e-11),
+    new Udef("eps0"       , "(electric constant) ",
+			     0x022f2d3432303030L, 8.854187817620389e-12),
+    new Udef("mu0"        , "(magnetic constant) ",
+			     0x0231312e2e303030L, (4.e-7*Math.PI)),
+    new Udef("\u00B50"    , "(magnetic constant) ",
+			     0x0231312e2e303030L, (4.e-7*Math.PI)),
+    new Udef("alpha"      , "(fine structure constant) ",
+			     0x0230303030303030L, (1./137.036)),
+    new Udef("muB"        , "(Bohr magneton) ",
+			     0x0230323031303030L, /* e.hbar/2me */9.274009e-28),
+    new Udef("degC"       , "Celsius ",
+			     0x0230303030313030L, 1.0, 273.15),
+    new Udef("MJD"        , "Modified Julian Date (JD-2400000.5) ",
+			     0x0230303130303030L|_abs, 86.4e+3),
+    new Udef("atm"        , "atmosphere ",
+			     0x02312f2e30303030L, 101325.),
+    new Udef("mmHg"       , "mercury_mm ",
+			     0x02312f2e30303030L, 133.3224),
+    new Udef("l"          , "litre ",
+			     0x0230333030303030L, 1.e-3),
+    new Udef("hr"         , "hour(use 'h') ",
+			     0x0230303130303030L, 3.6e3),
+    new Udef("sec"        , "second (use 's')",
+			     0x0230303130303030L, 1.0),
+    new Udef("inch"       , "inch ",
+			     0x0230313030303030L, 2.54e-2),
+    new Udef("t"          , "ton ",
+			     0x0231303030303030L, 1.e+3),
+    new Udef("\"month\""  , "month ",
+			     0x0230303030303030L, 1.0),
+    new Udef("erg"        , "erg(10-7J) ",
+			     0x0231322e30303030L, 1.e-7),
+    new Udef("dyn"        , "dyne(10-5N) ",
+			     0x0231312e30303030L, 1.e-5),
+    new Udef("bar"        , "bar(10+5Pa) ",
+			     0x02312f2e30303030L, 1.e+5),
+    new Udef("gauss"      , "Gauss(10-4T) ",
+			     0x0231302e2f303030L, 1.e-4),
+    new Udef("cal"        , "calorie ",
+			     0x0231322e30303030L, 4.1854),
+    new Udef("\u00C5",      "Angstroem(0.1nm) ",
+			     0x0230313030303030L, 1.e-10),
+    new Udef("Angstrom"   , "Angstroem(0.1nm) ",
+			     0x0230313030303030L, 1.e-10),
+    new Udef("lyr"        , "light-year (c*yr) ",
+			     0x0230313030303030L, .946053e+16),
+    new Udef("degF"       , "Fahrenheit ",
+			     0x0230303030313030L, (5./9.), (273.15-(32.*5./9.))),
+};
+
+    //  ===========================================================
+    //                    Initialisation
+    //  ===========================================================
+    private static synchronized void init() {
+        for (int i=0; i < uDef.length; i++) 
+          hUnit.put(uDef[i].symb, new Integer(i)) ;
+	// Accept conversions d:m:s <-> h:m:s
+        initialized = true;
+	Converter hms2dms = new Converter("\"h:m:s\"", "\"d:m:s\"", 15.);
+	Converter dms2hms = new Converter("\"d:m:s\"", "\"h:m:s\"", 1./15.);
+    }
+
+    /*
+     **** REMOVED --- no accuracy defined here.
+     ** Change the default number of significant digits for Editions (8)
+     * @param	digits the number of significant digits
+     * @return	the previously defined number of significant digits
+    ** 
+    public static final int setAccuracy(int digits) {
+      int old_value = accuracy;
+	if (!initialized) init();
+        if (digits < 2) accuracy = 2;
+	else if (digits > 16) accuracy = 16;
+	else accuracy = (byte)digits;
+	scaling = AstroMath.dexp(1-accuracy);
+	return(old_value);
+    }
+    */
+
+    /*==================================================================
+			Management of the List of Units
+     *==================================================================*/
+
+  /** Retrieve one definition of the units from its symbol
+   * @param	symbol the symbol to find out
+   * @return	its object
+  **/
+    private static final Udef uLookup (String symbol) {
+      int i;
+      Udef u;
+	if (!initialized) init();
+        Object o = hUnit.get(symbol) ;	// hUnit may contain aliases
+	if (o instanceof String) o = hUnit.get((String)o);
+        if (o instanceof Integer) ; else return(null);
+	i = ((Integer)o).intValue();
+	if (i < uDef.length) 		// In basic list
+	    return(uDef[i]) ;
+	i -= uDef.length;		// Is in additional list
+	u = (Udef)aUnit.elementAt(i);
+	return(u);
+    }
+
+  /** Retrieve one definition of the units from its dimension
+   * @param	symbol the symbol to find out
+   * @return	its object
+  **/
+    private static final Udef uLookup (long mksa) {
+      int i;
+      Udef u = null;
+	if (!initialized) init();
+	// Among the possible units, return the one without offset, and
+	// if possible having a factor of 1.
+	for (i=0; i<uDef.length; i++) {
+	    if ((uDef[i].mksa == mksa) && (uDef[i].orig == 0)) {
+		if (uDef[i].fact == 1) return(uDef[i]);
+		if (u == null) u = uDef[i];
+	    }
+	}
+	if (u != null) return(u);
+	// Maybe in additinal list ?
+        if (aUnit != null) { 
+	    int n = aUnit.size();
+	    for(i=0; i<n; i++) {
+		u = (Udef)aUnit.elementAt(i);
+		if (u.mksa == mksa) return(u);
+	    }
+	}
+	return(u);
+    }
+
+  /** Retrieve one definition of the units from the uDef table
+   * @param	t text to lookup
+   * @param len length of the text
+   * @return	its object
+  **/
+    private static final Udef uLookup (Parsing t, int len) {
+      String symb = new String(t.a, t.pos, len);
+      Udef u = uLookup(symb);
+        if (u != null) t.pos += len;
+	return(u);
+    }
+
+  /** 
+   * List all symbols.
+   * Basic symbols only (without the multiplicity indexes) are listed.
+   * Use {@link #checkSymbol} to verify one symbol.
+   * @return	an Enumeration of the symbols. 
+   *		The symbols can be used as argument in the <b>explain</b>
+   *		method to get details.
+  **/
+    public static final Enumeration symbols() {
+	if (!initialized) init();
+	return(hUnit.keys());
+    }
+
+  /** Introduce a new Symbol into the list of Symbols.
+   * An example could be 
+   * <tt>Unit.addSymbol("Rayleigh", "10+6/(4*pi).ph.cm-2.s-1.sr-1", 
+   * 		"apparent emission rate")</tt>
+   *
+   * @param	symbol the text of the symbol -- made of <em>letters</em> only,
+   *		or letters preceded by a backslash, or surrounded by quotes
+   * @param	equiv the definition of the symbol in terms of existing symbols
+   * @param	explain the text to be used for explanation 
+   *		<em>(should be terminated by a blank)</em>
+   * @return	The unit having the same symbol which was removed, or null
+   * @throws	ParseException when <em>equiv</em> can't be interpreted.
+  **/
+    public static synchronized Unit addSymbol (String symbol, String equiv, 
+      String explain) throws ParseException {
+      Udef old_def, new_def;
+      Unit new_unit, old_unit;
+      int i;
+
+	// if (!initialized) init(); -- executed in uLookup
+	old_def = uLookup(symbol) ; 
+	if (old_def == null) old_unit = null;
+	else old_unit = new Unit(old_def.symb);
+	new_unit = new Unit(equiv);
+
+	if (DEBUG>0) System.out.println("----addSymbol(" + symbol + ") = " 
+		+ equiv + " = " + new_unit);
+
+	// Create a vector of additional units if not existing
+	if (aUnit == null) aUnit = new Vector(16);
+
+	// Transform the unit into a new definition
+	if (!Double.isNaN(new_unit.value)) {
+	    if ((new_unit.mksa&_LOG) != 0) {	// Convert the log scale
+	      Unit u = new Unit(new_unit);
+	        u.dexp();
+		new_unit.factor = u.factor * u.value;
+	    }
+	    else new_unit.factor *= new_unit.value;
+	}
+	new_def = new Udef(symbol, explain, new_unit.mksa, new_unit.factor);
+
+	// Add the new unit into the Vector, and into the Hashtable
+	i = aUnit.size() + uDef.length;		// Index of new unit for Htable
+	aUnit.addElement(new_def);
+	hUnit.put(symbol, new Integer(i));
+
+	if (DEBUG>0) System.out.println("====Added units #" + i + " = " 
+		+ new_def);
+
+	// Return the old Explanation
+	return(old_unit);
+    }
+
+  /** Introduce a new Symbol into the list of Symbols.
+   * @param	symbol the text of the symbol -- made of <em>letters</em> only,
+   *		or letters preceded by a backslash, or surrounded by quotes
+   * @param	equiv the definition of the symbol in terms of existing symbols
+   * @return	The text of the explanation of the unit previously defined 
+   *		having the same symbol
+   * @throws	ParseException when <em>equiv</em> can't be interpreted.
+  **/
+    public static synchronized Unit addSymbol (String symbol, String equiv) 
+      throws ParseException {
+	return(addSymbol(symbol, equiv, equiv + " ")) ;
+    }
+
+  /** 
+   * Introduce a special converter.
+   *	Converters created by the {@link Converter} class 
+   *	are automatically registered (no need to register them).
+   *	Once registered, the converter is used by {@link #convert},
+   *	{@link #convertFrom} and {@link #convertTo} preferably to
+   *	the standard conversion rules.
+   * @param	source_unit symbol of source unit, e.g. <tt>mag</tt>
+   * @param	target_unit symbol of target unit, e.g. <tt>Jy</tt>
+   * @param	special_converter a {@link Converter} object
+  **/
+    public static synchronized void registerConverter (String source_unit, 
+	    String target_unit, Converter special_converter) {
+	String symbols = source_unit +  Converter.SEP + target_unit;
+	hConv.put(symbols, special_converter);
+    }
+
+  /** 
+   * Retrieve a special converter.
+   * 	(previously registered by {@link #registerConverter})
+   * @param	source_unit symbol of source unit, e.g. <tt>"d:m:s"</tt>
+   * @param	target_unit symbol of target unit, e.g. <tt>"h:m:s"</tt>
+   * @return	The known {@link Converter} object.
+   * 		Object which know how to convert <em>source_unit</em> into 
+   * 		<em>target_unit</em>
+  **/
+    public static Converter getConverter (String source_unit, 
+	    String target_unit) {
+	String symbols = source_unit +  Converter.SEP + target_unit;
+	Converter c = (Converter)hConv.get(symbols);
+	return(c);
+    }
+
+  /** 
+   * Check whether a symbol exists.
+   * Use {@link #symbols} to get all symbols.
+   * @param	symbol the text of the symbol -- made of <em>letters</em> only,
+   *		or letters preceded by a backslash, or surrounded by quotes
+   * @return	<b>true</b> if the symbol exists, <b>false</b> if the
+   * 		symbol was not registered.
+  **/
+    public static boolean checkSymbol (String symbol) {
+	return(uLookup(symbol)!=null) ;
+    }
+
+    /*==================================================================
+			Constructors
+     *==================================================================*/
+
+    /** Define the default unit: <em>unitless</em> undefined value 
+    **/
+    public Unit() {
+	this.set();
+    }
+
+    /** Define a Unit and Value from an existing one (clone)
+     * @param	u the Unit to clone
+    **/
+    public Unit(Unit u) {		// Just copy the instance
+	this.set(u);
+    }
+
+    /** Define a Value+Unit by interpreting a String
+     * @param	symbol a text to interpret, e.g. 20km/s, or 2(75km/s/Mpc)
+     * @throws  ParseException when the argument contains non-interpretable
+     * 		text
+    **/
+    public Unit(String symbol) throws ParseException {
+        this.set(symbol) ;
+    }
+
+    /*==================================================================
+		Get the contents of a Unit
+     *==================================================================*/
+
+    /** 
+     * Get the value of a unit (identical to unit.value)
+     * @return	the value, expressed in units <b>getUnit()</b>
+    **/
+    public double getValue() {
+	return(value);
+    }
+
+    /** 
+     * Get the value converted to SI system
+     * @return	the value, expressed in units <b>getSIunit()</b>
+    **/
+    public double getSIvalue() {
+	return(value*factor + offset);
+    }
+
+    /** 
+     * Get a representation of the unit dimension.
+     *     The result is unique for a combination of basic dimensions.
+     * @return	the value
+    **/
+    public long getSIdim() {
+	return(mksa);
+    }
+
+    /** 
+     * Get a representation of the unitless dimension
+     * @return	the representation of a unitless dimension.
+    **/
+    static public long unitless() {
+	return(_);
+    }
+
+    /** 
+     * Get the unit symbol (identical to unit.symbol)
+     * @return	the symbol representing the unit
+    **/
+    public String getUnit() {
+	return(symbol);
+    }
+
+    /** 
+     * Get the unit expressed in terms of SI units.
+     * @return	the symbol representing the unit
+    **/
+    public String getSIunit() {
+      StringBuffer b = new StringBuffer(64);
+	toSI(b, 0);
+	return(""+b);
+    }
+
+    /*==================================================================
+		Very Basic Utilities
+     *==================================================================*/
+    /** Add the () to transform an expression into a simple expression
+     *  The () are added only if the string contains non-letter.
+     * @param s string to transform
+    **/
+    private static final String toExpr(String s) {
+      char[] b = s.toCharArray();
+      int i;
+	for (i=0; (i<b.length) && Character.isLetter(b[i]); i++) ;
+	if (i<b.length) return("(" + s + ")");
+	return(s) ;		// Just letters
+    }
+
+    /** Remove the enclosing parentheses in a StringBuffer.
+     *  Changes the length of the buffer, and returns
+     *  the position of the first significant character.
+     * @param b buffer to modify
+    **/
+    private static final int skipBrackets(StringBuffer b) {
+      int len1 = b.length()-1;
+      int ini1 = 0;
+	if (len1 <= 0) return(0);
+	while ((b.charAt(ini1) == '(') && (b.charAt(len1) == ')')) {
+	    while (b.charAt(--len1) == ' ');
+	    while (b.charAt(++ini1) == ' ');
+	    b.setLength(++len1);
+	}
+	return(ini1);
+    }
+
+    /*==================================================================
+		Operations on a single Unit
+     *==================================================================*/
+
+    /** Compute the power of the text, from (...)+/-p or symb+/-p
+     *  @return as an int the power.
+     *  Remark 1: set the `position' at the location where the power starts
+     *  Remark 2: no change when the returned power is 0.
+    **/
+    private static final int getPower(Parsing t) {
+      char s='+';		// Exponent Sign
+      int pow=0;		// Exponent Value
+      int inum=0;		// Index of exponent
+      int posini=t.pos;
+	//System.out.print("....getPower on '" + this + "', pos=" + pos + ": ");
+	t.pos = t.length-1;
+	if (Character.isDigit(t.a[t.pos])) {
+	    while (Character.isDigit(t.a[t.pos])) --t.pos;
+	    s = t.a[t.pos];
+	    if ((s == '+') || (s == '-')) ;	// Exponent starts here
+	    else ++t.pos;
+	    inum = t.pos;
+	    pow = t.parseInt();
+	//System.out.print("found pow=" + pow + ",pos=" + pos);
+	}
+	if (pow != 0) {		// Verify the power is meaningful
+	    if (t.a[0] == '(') {
+	        if (t.a[inum-1] != ')') pow = 0;
+	    }
+	    else {		// could be e.g. m2
+	        for (int i=0; i<inum; i++) {
+	    	// Verify the unit is not a complex one
+	            if (!Character.isLetter(t.a[i])) pow = 0;
+	        }
+	    }
+	}
+	if (pow == 0) t.pos = posini;
+	else t.pos = inum;
+	//System.out.println(" pow=" + pow + ", pos=" + pos);
+	return(pow);
+    }
+
+    /** Convert a value to a decimal log scale
+     * @throws ArithmeticException when the unit contains already logs
+    **/
+    public final void log() throws ArithmeticException {
+	if ((mksa&_LOG) != 0) throw new ArithmeticException
+	    ("****Unit: log(" + symbol + ")") ;
+	value = AstroMath.log(value);
+	mksa |= _log;
+	if (symbol != null) 
+	    symbol = "[" + symbol + "]";	// Enough to indicate log
+    }
+
+    /** Convert a value to a mag scale
+     * @throws  ArithmeticException when the unit contains already logs
+    **/
+    public final void mag() throws ArithmeticException {
+	if ((mksa&_LOG) != 0) throw new ArithmeticException
+	    ("****Unit: mag(" + symbol + ")") ;
+	value = -2.5*AstroMath.log(value);
+	if ((mksa == _) && (factor == 1)) {	// Now we've mag
+	    mksa |= _mag;
+	    if (symbol != null) symbol = "mag";
+	} else {
+	    mksa |= (_log|_mag);
+	    if (symbol != null) symbol = "mag[" + symbol + "]";
+	}
+    }
+
+    /** Convert a value to its linear scale
+     * @throws  ArithmeticException when the unit is not a log
+    **/
+    public final void dexp() throws ArithmeticException {
+      double ls; char c; int i, last;
+        if ((mksa&_log) == 0) throw new ArithmeticException 
+            ("****Unit: dexp("  + symbol + ")") ;
+	ls = (mksa&_mag) != 0 ? -2.5 : 1.;
+        value = AstroMath.dexp(value/ls);
+	mksa &= (~_LOG) ;
+	if (symbol == null) return;
+
+      	// Change the symbol
+      	i = -1; last = symbol.length()-1;
+      	c = symbol.charAt(last);		// Closing bracket
+	if (c == ']') i = symbol.indexOf('[');
+	else if (c == ')') i = symbol.indexOf('(');
+	if (i >= 0) symbol = symbol.substring(i+1, last);
+	else { 					// Symbol can't be found, use SI
+	  StringBuffer b = new StringBuffer(64);
+	    toSI(b, 0);
+	    symbol = "" + b;
+	}
+    }
+
+    /** Compute the Power of a number/unit
+     * @param	expo Power value
+     * @throws  ArithmeticException when the power is too large
+    **/
+    public final void power (int expo) throws ArithmeticException {
+      double error = 0;
+      int i = expo; 
+      double r = 1;
+      double v = 1; 
+      long u = _;
+    	if ((mksa&(_log|_mag)) != 0) throw new ArithmeticException
+	    ("****Unit: can't power log[unit]: " + symbol );
+    	while (i > 0) { 
+	    r *= factor; v *= value; 
+	    u += mksa; u -= _;  
+	    if ((u&0x8480808080808080L) != 0) error++;
+	    i--; 
+	}
+    	while (i < 0) { 
+	    r /= factor; v /= value; 
+	    u += _; u -= mksa;
+	    if ((u&0x8480808080808080L) != 0) error++;
+	    i++; 
+	}
+	if (error > 0) throw new ArithmeticException
+	   ("****Unit: power too large: (" + ")^" + expo) ;
+    	factor = r;
+	value = v;
+	mksa = u;
+	/* Decision for the new symbol */
+	if ((expo != 1) && (symbol != null)) {
+	    if (expo == 0) symbol = "";
+	    else if (symbol.length()>0) {
+	      Parsing t = new Parsing(symbol);
+	      int pow;
+	        pow = getPower(t);
+		if (pow == 0) symbol = toExpr(symbol) + expo;
+		else {			// Combine exponents
+		    i=0;
+		    pow *= expo;
+		    if (t.a[0] == '(') { i = 1; t.advance(-1); }
+		    if (expo == 1) symbol = symbol.substring(i,t.pos);
+		    else symbol = toExpr(symbol.substring(i,t.pos)) + pow;
+		}
+	    }
+	}
+    } 
+
+    /** Take Square Root of a Value/Unit
+     * @throws  ArithmeticException when the unit is not a log, or not-even
+    **/
+    public final void sqrt() throws ArithmeticException {
+	if ((mksa&_LOG) != 0) throw new ArithmeticException
+	    ("****Unit: log(" + symbol + ")") ;
+	if ((mksa&0x0101010101010101L)!=0) throw new ArithmeticException
+	    ("****Unit: sqrt(" + symbol + ") is impossible");
+	value = Math.sqrt(value);
+	factor = Math.sqrt(factor);
+	mksa = (mksa+_)>>1;
+	/* Try to remove the squared edition */
+	if ((symbol != null) && (symbol.length()>1)) {
+          Parsing t = new Parsing(symbol);
+	  int i=0;
+	  int pow=0;
+	    pow = getPower(t);
+	    if ((pow&1) != 0) 	// Odd power not possible
+	      pow = 0;
+	    if (t.a[0] == '(') { i = 1; t.advance(-1); }
+	    if (pow == 2) symbol = symbol.substring(i, t.pos);
+	    else if (pow != 0) {
+		pow /= 2;
+		symbol = toExpr(symbol.substring(i,t.pos)) + pow;
+	    }
+	    if ((pow == 0) && (t.length>0)) symbol = "sqrt(" + symbol + ")";
+	}
+    }
+
+    /*==================================================================
+		Conversion of a Unit into another one
+     *==================================================================*/
+
+    /** Checks whether a number has no unit (is unitless)
+     * @return	true if unit has no associated dimension
+    **/
+    public final boolean isUnitless () {
+	return((mksa&(~_log)) == _);
+    }
+
+    /** 
+     * Checks whether 2 units are compatible.
+     * Compatible units can be summed via the <b>sum</b> method, as e.g.
+     * <b>m/s</b> and <b>[km/h]</b>
+     * @param	unit another Unit, to be verified.
+    **/
+    public final boolean isCompatibleWith (Unit unit) {
+	if (((unit.mksa|this.mksa)&_abs) != 0) 		// Special dates
+	    return((this.mksa^_abs) == unit.mksa) ;
+	return((mksa&(~(_log|_mag))) == (unit.mksa&(~(_log|_mag)))) ;
+    }
+
+    /** 
+     * Check whether 2 quantities are equal.
+     * Two units are equal when these have the same physical dimension, and
+     * have the same numeric value
+     * (e.g. 100cm and 1m should be equal).
+     * @param   o any object
+     * @return  true if identical values.
+    **/
+    public final boolean equals(Object o) {
+	boolean res = false;
+	if(o instanceof Unit) {
+	    Unit u = (Unit)o;
+	    if (u.mksa == this.mksa) res = (mksa&_log) != 0 ? 
+		this.factor == u.factor && this.value == u.value :	// LOG
+		this.factor*this.value == u.factor*u.value ;	// linear
+	}
+	return(res);
+    }
+
+    /** 
+     * Convert a unit+value into another unit+value.
+     * 		The conversion uses first the registered conversions
+     * 		(via {@link #registerConverter})
+     * @param	source_unit the value+unit to convert.
+     *		This value is unchanged.
+     * @param	target_unit the resulting value+unit.
+     *		On return, its <tt>value</tt> part is modified.
+     * @throws  ArithmeticException when source_unit is not compatible with
+     * 		target_unit
+    **/
+    public static void convert(Unit source_unit, Unit target_unit) 
+    throws ArithmeticException {
+      String s = source_unit.symbol + Converter.SEP + target_unit.symbol;
+      Object o = hConv.get(s);
+      	if (o != null) {
+	    Converter c = (Converter)o;
+	    double r = c.convert(source_unit.value);
+	    target_unit.value = r;
+	    return;
+      	}
+      	convertUnit(source_unit, target_unit);
+    }
+
+    /** 
+     * Convert a unit+value into another unit+value.
+     * 		The conversions registered via {@link #registerConverter}
+     * 		are <b>not</b> used.
+     * @param	source_unit the value+unit to convert.
+     *		This value is unchanged.
+     * @param	target_unit the resulting value+unit.
+     *		On return, the <tt>value</tt> part is modified.
+     * @throws  ArithmeticException when source_unit is not compatible with
+     * 		target_unit
+    **/
+    public static void convertUnit(Unit source_unit, Unit target_unit) 
+    throws ArithmeticException {
+      double f = source_unit.factor/target_unit.factor;
+      double ls;
+
+        if (DEBUG>0) {
+	    source_unit.dump("...convert:source="); 
+	    target_unit.dump("...convert:target="); 
+	}
+
+	if (target_unit.mksa == source_unit.mksa) {
+	    if ((target_unit.mksa&_log) == 0) 
+		target_unit.value = f*source_unit.value 
+		+ (source_unit.offset-target_unit.offset)/target_unit.factor;
+	    else {	// Convert to log scale: log(km) --> log(m)+log(k)
+		if ((source_unit.offset != 0) || (target_unit.offset != 0)) 
+		    throw new ArithmeticException
+		   ("****Unit: can't convert non-standard unit " 
+		    + source_unit.symbol + " into " + target_unit.symbol);
+		f = AstroMath.log(f);
+	        if ((target_unit.mksa&_mag) != 0) f = -2.5*f;
+		target_unit.value = source_unit.value + f;
+	    }
+	    return ;
+	}
+
+	if ((target_unit.mksa&(~_LOG)) != (source_unit.mksa&(~_LOG))) {	
+	    throw new ArithmeticException
+	    ("****Unit: can't convert " + source_unit.symbol 
+	                     + " into " + target_unit.symbol);
+	}
+
+	/* Convert to / from Log scale */
+	if ((target_unit.mksa&_log) == 0) {		// Remove the log
+	    ls = (source_unit.mksa&_mag) != 0 ? -2.5 : 1.;
+            target_unit.value = f*AstroMath.dexp(source_unit.value/ls);
+	    return;
+	}
+
+	/* The target is a log. Check whether the source is also in log scale */
+	if ((source_unit.mksa&_log) != 0) {	// Convert from log to log
+	    target_unit.value = (source_unit.mksa&_mag) != 0 ? 
+	        -0.4*source_unit.value : 	// From a magnitude
+		source_unit.value;
+	    target_unit.value += AstroMath.log(f);  // Target assumed to be log
+	    if ((target_unit.mksa&_mag) != 0) 	// Target is a magnitude
+	        target_unit.value *= -2.5;
+	    return ;
+	}
+
+	/* The target is a log, the source is in a linear scale. */
+	ls = (target_unit.mksa&_mag) != 0 ? -2.5 : 1.;
+	target_unit.value = ls*AstroMath.log(f*source_unit.value);
+    }
+
+    /** 
+     * Convert the value in argument to the target Unit.
+     * @param	source_unit the value+unit to convert.
+     *		This value is unchanged.
+     * @throws  ArithmeticException when source_unit is not compatible with
+     * 		the unit of <tt>this</tt>.
+    **/
+    public void convertFrom(Unit source_unit) throws ArithmeticException {
+	convert(source_unit, this);
+    }
+
+    /** 
+     * Convert the value into another unit.
+     * @param	unit the target unit (unchanged)
+     * 	On return, <tt>this</tt> contains the value in another unit.
+     * @throws  ArithmeticException when the units are not compatible
+    **/
+    public void convertTo(Unit unit) throws ArithmeticException {
+      double f = factor/unit.factor;
+
+	if(DEBUG>0) {
+	    this.dump("...convertTo:source= "); 
+	    unit.dump("...convertTo:target= "); 
+	}
+
+	if ((mksa == unit.mksa) && ((mksa&_log) == 0)) {
+	    	value  = (value*factor + offset - unit.offset)/unit.factor;
+		factor = unit.factor;
+		offset = unit.offset;
+		symbol = unit.symbol;
+		return;
+	}
+	// More complex transformation: Use convertFrom
+	Unit temp = new Unit(this);
+	symbol = unit.symbol;
+	mksa   = unit.mksa;
+	factor = unit.factor;
+	offset = unit.offset;
+	convertFrom(temp);
+	return;
+    }
+
+    /*==================================================================
+		Addition of 2 Units
+     *==================================================================*/
+
+    /** 
+     * Addition of 2 quantities.
+     * Compute the Addition of 2 numbers with their associated units.
+     * @param	unit 2nd Unit, to add.
+     * @throws  ArithmeticException when the units are not compatible
+    **/
+    public final void plus (Unit unit) throws ArithmeticException {
+      boolean error = false;
+        if (((mksa|unit.mksa)&_abs)!=0) {	// Special dates
+	    if (mksa != (_abs^unit.mksa)) error = true;
+	    else mksa |= _abs;			// Result is a date
+	}
+	else error = (mksa&(~_pic)) != (unit.mksa&(~_pic));
+	if (error) throw new ArithmeticException
+	    ("****Unit: can't combine: " + symbol + " + " + unit.symbol);
+	/* Addition in log scale: a+b=a+f*log(1.+10^((b-a)/f)) */
+	value += (unit.value*unit.factor)/factor;
+    }
+
+    /** 
+     * Subtraction of 2 quantities.
+     * Compute the Subtraction of 2 numbers with their associated units.
+     * @param	unit 2nd Unit to be subtracted
+     * @throws  ArithmeticException when the units are not compatible
+    **/
+    public final void minus (Unit unit) throws ArithmeticException {
+      boolean error = false;
+	if (((mksa|unit.mksa)&_abs)!=0) {	// Special dates
+	    if (mksa == unit.mksa)		// date1 - date2
+		mksa ^= _abs;			// ... not a date any more
+	    else if ((unit.mksa&_abs)!=0) error = true;
+	}
+	else error = (mksa&(~_pic)) != (unit.mksa&(~_pic));
+	if (error) throw new ArithmeticException
+	    ("****Unit: can't combine: " + symbol + " - " + unit.symbol);
+	value -= (unit.value*unit.factor)/factor;
+    }
+
+    /** 
+     * Sum of 2 quantities.
+     * Compute the Sum of 2 numbers with their associated units;
+     * The difference with "plus" exists only for log scales or magnitudes:
+     *     the resulting value corresponds to a physical sum (e.g. of fluxes),
+     *     whereas the "plus" corresponds to an arithmetic sum.
+     * @param	unit 2nd Unit 
+     * @throws  ArithmeticException when the units are not compatible
+    **/
+    public final void sum (Unit unit) throws ArithmeticException {
+      double ls, dv;
+      int error = 0;
+      long rlog, ulog;
+      	if (((mksa|unit.mksa)&_LOG) == 0) { 	// No log scale at all !
+	    this.plus(unit); 
+	    return; 
+	}
+	if (DEBUG>0) { dump("...sum:term1"); unit.dump("...sum:term2"); }
+	if ((mksa&(~_LOG)) != (unit.mksa&(~_LOG))) throw new ArithmeticException
+	    ("****Unit: can't sum: " + symbol + " + " + unit.symbol);
+	rlog = mksa&(_log|_mag);
+	ulog = unit.mksa&(_log|_mag);
+	if (rlog != ulog) {		// Not the Same log scale -- convert
+	  Unit tunit = new Unit(this);
+	    tunit.convertFrom(unit);	// Convert the argument unit to target.
+	    this.sum(tunit);		// Now, the units are the same!
+	    return;
+	}
+	// Here, we have the same log scales
+	// if (rlog == 0) { this.plus(unit); return; } -- already seen
+	ls = (rlog&_mag) != 0 ? -2.5 : 1.0 ;
+	/* Addition in log scale: a+b=a+f*log(1.+10^((b-a)/f)) */
+	dv = unit.value - value;
+	value += ls*AstroMath.log(1.+(unit.factor/factor)*Math.exp(dv/ls)) ;
+    }
+
+    /*==================================================================
+		Multiplication of 2 Units
+     *==================================================================*/
+
+    /** Multiplication by a Scalar.
+     * @param	s Scalar value for the multiplication
+     * @throws ArithmeticException when the units can't be combined
+    **/
+    public final void mult (double s) throws ArithmeticException {
+	if (((mksa&_abs)!=0) && (s != 1)) throw new 	// On a date
+	    ArithmeticException("****Unit.mult on a date!");
+	value *= s;
+	// Offset not changed.
+    }
+
+    /** 
+     * Multiplication of 2 quantities.
+     * Compute the arithmetic Multiplication of 2 numbers with their 
+     * associated units.
+     * The difference with <b>prod</b> exists only for log scales or magnitudes.
+     * @param	unit 2nd Unit
+     * @throws  ArithmeticException when the units can't be combined
+    **/
+    public final void mult (Unit unit) throws ArithmeticException {
+      long u = mksa ; double r = factor; double v = value; double o = offset;
+	/* dump("mult:this "); unit.dump("mult:unit"); */
+        if (((mksa&_abs)!=0) && (unit.factor != 1)) throw	// On a date
+	    new ArithmeticException("****Unit.mult on a date!");
+        if (((mksa|unit.mksa)&_log) != 0) {
+	    if ((mksa == _) && (factor == 1.)) ;
+	    else if ((unit.mksa == _) && (unit.factor == 1.)) ;
+	    else throw new ArithmeticException
+	    ("****Unit: can't multiply logs: " + symbol + " x " + unit.symbol);
+	}
+        /* As soon as there is an operation, the offset is ignored 
+	 * except if one of the factors is unity.
+	 */
+        if ((offset!=0) || (unit.offset!=0)) {
+	    if (mksa == _) offset = unit.offset;
+	    else if (unit.mksa == _) ;
+	    else offset = 0;
+	}
+	v *= unit.value; 
+	r *= unit.factor;
+      	u += unit.mksa; u -= _;
+	if ((u&0x0c80808080808080L) != 0) throw new ArithmeticException
+	    ("****too large powers in: " + symbol + " x " + unit.symbol);
+	mksa = u;
+	factor = r;
+	value  = v;
+	/* Decision for the new symbol */
+	if ((symbol != null) && (unit.symbol != null)) {
+	    if ((unit.mksa == _) && (unit.factor == 1)) return;	// No unit ...
+	    if ((     mksa == _) && (     factor == 1)) symbol = unit.symbol;
+	    else if ((symbol.equals(unit.symbol)) && (factor == unit.factor))
+		 symbol = toExpr(symbol) + "2" ;
+	    else symbol = toExpr(symbol) + "." + toExpr(unit.symbol) ;
+	}
+    }
+
+    /** 
+     * Division of 2 quantities.
+     * Compute the Division of 2 numbers with their associated units.
+     * @param	unit 2nd Unit
+     * @throws  ArithmeticException when the units can't be combined
+    **/
+    public final void div (Unit unit) throws ArithmeticException {
+      long u = mksa ; double r = factor; double v = value;
+        if (((mksa&_abs)!=0) && (unit.factor != 1)) throw	// On a date
+	    new ArithmeticException("****Unit.div  on a date!");
+        if (((mksa|unit.mksa)&_log) != 0) {
+	    if ((mksa == _) && (factor == 1.)) ;
+	    else if ((unit.mksa == _) && (unit.factor == 1.)) ;
+	    else throw new ArithmeticException
+	    ("****Unit: can't divide logs: " + symbol + " x " + unit.symbol);
+	}
+        /* As soon as there is an operation, the offset is ignored 
+	 * except if one of the factors is unity.
+	 */
+        if ((offset!=0) || (unit.offset!=0)) {
+	    if (mksa == _) offset = unit.offset;
+	    else if (unit.mksa == _) ;
+	    else offset = 0;
+	}
+	v /= unit.value; 
+	r /= unit.factor; 
+      	u += _; u -= unit.mksa;
+	if ((u&0x8c80808080808080L) != 0) throw new ArithmeticException
+	    ("****too large powers in: " + symbol + " / " + unit.symbol);
+	mksa = u;
+	factor = r;
+	value  = v;
+	/* Decision for the new symbol */
+	if ((symbol != null) && (unit.symbol != null)) {
+	    if ((unit.mksa == _) && (unit.factor == 1)) return;	// No unit ...
+	    if ((     mksa == _) && (     factor == 1))
+		symbol = toExpr(unit.symbol) + "-1";
+	    else if (symbol.equals(unit.symbol)) symbol = edf(factor);
+	    else symbol = toExpr(symbol) + "/" + toExpr(unit.symbol) ;
+	}
+    }
+
+    /** 
+     * Product of 2 quantities.
+     * Compute the Product of 2 numbers with their associated units.
+     * The difference with "mult" exists only for log scales or magnitudes:
+     *     the resulting value corresponds to a physical product 
+     *     whereas the "mult" corresponds to an arithmetic multiplication.
+     * @param	unit 2nd Unit 
+     * @throws  ArithmeticException when the units are not compatible
+    **/
+    public final void prod (Unit unit) throws ArithmeticException {
+      Unit runit, tunit;
+
+	if (((mksa&_log)==0) && ((unit.mksa&_log)==0)) {
+            mult(unit); 
+	    return; 
+	}
+
+        /* Convert to non-log Unit */
+	runit = new Unit(this);
+	tunit = new Unit(unit);
+	if ((runit.mksa&_log) != 0) {
+	    runit.mksa &= ~(_log|_mag);
+	    runit.convertFrom(this);
+	}
+	if ((tunit.mksa&_log) != 0) {
+	    tunit.mksa &= ~(_log|_mag);
+	    tunit.convertFrom(this);
+	}
+	runit.mult(tunit) ;
+	if ((mksa&_log) != 0) {		// Convert to log scale
+	    if ((mksa&_mag) != 0) runit.mag() ;
+	    else runit.log() ;
+	}
+	// Copy the result
+	set(runit);
+	// System.arraycopy(runit, 0, this, 0, 1) ; // this = runit;
+    }
+
+    // ==================================================================
+    //		Internal Parsing for Unit Interpretation
+    // ==================================================================
+    /** 
+     * Interpret for a SimpleUnit as  
+     *  [multiplicator-prefix]Unit-Symbol[power]<br>
+     * Only the UNIT part (value not touched)
+     * @param  	text text to interpret
+     * @param  	edited result of edited unit (may be null)
+     * @return	the number of bytes interpreted
+    **/
+    private final int unit1 (Parsing text, StringBuffer edited) 
+      throws ParseException {
+      int posini = text.pos;		// Initial position in text
+      Udef theUnit = uDef[0];		// Default Unit = Unitless
+      int mult_index = -1;		// Index in mul_fact by e.g. &mu;
+      int power = 1;
+      char op = Character.MIN_VALUE;	// Operator power
+      int error = 0;			// Error counter
+      boolean close_bracket = false;	// () not edited when buffer empty
+      int edited_pos = -1;
+      int i, s;
+    
+    	/* Initialize the Unit to unitless */
+    	mksa = _; factor = 1.;
+    	if (text.pos >= text.length) return(0);	// Unitless
+
+	if (DEBUG>0) System.out.println("....unit1(" + text + ")");
+    	switch(text.a[text.pos]) {
+      	  case '(':		/* Match parenthesized expression */
+	    theUnit = null;	// Parenthese do NOT define any unit.
+	    text.pos++;		// Accept the '('
+	    close_bracket = (edited != null) ; /*&& (edited.length() > 0)*/
+	    if (close_bracket) {
+		edited_pos = edited.length();	// where to insert 'square'
+	        edited.append('(') ;
+	    }
+	    this.unitec(text, edited) ;
+	    if ((text.pos < text.length) && (text.a[text.pos] == ')'))
+	        text.pos++;
+	    else throw new ParseException
+		("****Unit: Missing ) in '" + text + "'", text.pos);
+	    if (close_bracket) {
+	        // Remove the Ending blanks, before closing the bracket
+		i = edited.length(); 
+		while ((--i >= 0)  && (edited.charAt(i) == ' ')) ;
+		edited.setLength(++i);
+	        edited.append(')') ;
+		close_bracket = false;
+	    }
+	    break ;
+      	  case '"':		/* Quoted units must match exactly */
+	    i = text.matchingQuote();
+	    if (i<text.length) i++;	// Matching quote
+	    theUnit = uLookup(text, i-text.pos);
+	    if (theUnit == null) throw new ParseException
+	        ("****Unit: quoted unit does not match", text.pos);
+	    break ;
+      	  case '-':		// Unitless ?
+	    s = text.pos++;
+	    if (text.pos >= text.length) break;
+	    if (Character.isDigit(text.a[text.pos])) { 	// Number ?
+	        text.pos = s;
+	        break;
+	    }
+	    while ((text.pos<text.length) && (text.a[text.pos]=='-')) 
+	        text.pos++;	// Accept unitless as "--" or "---"
+	    break;
+      	  case '%':
+	    theUnit = uLookup(text, 1);
+	    break;
+      	  case '\\':		// Special constants
+	    for (i=text.pos+1; (i<text.length) && Character.isLetter(text.a[i]); 
+	  	i++) ;
+	    theUnit = uLookup(text, i-text.pos) ;
+	    if (theUnit == null) error++ ;
+	    break;
+      	  default:
+	    for (i=text.pos; (i<text.length) && Character.isLetter(text.a[i]); 
+	  	i++) ;
+	    // A unit may be terminated by 0 (a0 = classical electron radius)
+	    if ((i<text.length) && (text.a[i] == '0')) i++;
+	    theUnit = uLookup(text, i-text.pos) ;
+	    if (theUnit != null) break;
+	    /* Simple unit not found. Look for multiple prefix */
+	    s = text.pos ;	// Save 
+	    if ((text.length-text.pos)>1) 
+	        mult_index = text.lookup(mul_symb) ;
+	    if (mult_index < 0) break;
+	    theUnit = uLookup(text, i-text.pos) ;
+	    if (theUnit == null) text.pos = s; 
+    	}
+    	/* Look now for a Power: */
+    	if ((error == 0) && (text.pos < text.length)) 
+	    op = text.a[text.pos];
+	/* Power is however not acceptable for complex and date numbers */
+	if (theUnit != null) {
+	    if ((theUnit.mksa&(_abs|_pic)) != 0)
+		op = Character.MIN_VALUE;
+	}
+	if ((op == '+') || (op == '-') || (op == '^') || 
+		(Character.isDigit(op) && (op != '0'))) {
+	    if (DEBUG>0) System.out.print("    look for power with op=" + op);
+	    if (op == '^') text.pos += 1;
+	    if (text.pos < text.length) {
+	        op = text.a[text.pos];
+	        if (op == '+') text.pos++ ;
+	        if (op != '-') op = '+';
+	        power = text.parseInt() ;
+		// A zero-power is illegal !!
+		if (power == 0) error++;
+	        // 'square' or 'cubic' is spelled out BEFORE the unit name
+	        else if ((power > 0) && (power < 10) && (edited != null)) {
+		    text.pos--;		// Now text is the digit of power
+		    i = text.lookup(op_symb) ;
+		    if (i >= 0) { 	// Square or cubic
+			if (edited_pos >= 0)
+			     edited.insert(edited_pos, op_text[i]);
+			else edited.append(op_text[i]) ; 
+			op = ' '; 	// Power is now edited
+		    }
+		    else text.pos++;
+	        }
+		if (DEBUG>0) System.out.print(", power=" + power);
+	    }
+	    else error++;
+	    if (DEBUG>0) System.out.println(", error=" + error);
+	}
+
+    	if (error>0) throw new ParseException
+	    ("****Unit: '" + text + "'+" + text.pos, text.pos) ;
+
+    	if (mult_index >= 0) {		// Multiplicities like 'k', '&mu;', ...
+	    factor *= AstroMath.dexp(mul_fact[mult_index]);
+	    if (edited != null) edited.append(mul_text[mult_index]) ;
+        }
+
+    	if (theUnit != null) {
+	    factor *= theUnit.fact ;
+	    mksa = theUnit.mksa;
+	    offset = theUnit.orig;
+            if (edited != null)
+	        edited.append(theUnit.expl) ;
+    	}
+
+    	if (power != 1) {
+	    this.power (power) ;
+	    if ((op != ' ') && (edited != null)) {
+	        edited.append("power") ;
+	        if (power>=0) edited.append(op);	// - sign included...
+	        edited.append(power);			// by this edition!
+	    }
+   	}
+	s = text.pos - posini;
+	if (DEBUG>0) System.out.println("  =>unit1: return=" + s 
+		+ ", f="+factor + ", val="+value);
+    	return(s);
+    }
+
+    /** Interpret for a CompoundUnit
+     *  [factor] SimpleUnit [operator unit]<br>
+     * Only the UNIT part (value not touched)
+     * @param	text text to interpret
+     * @param  	edited result of edited unit
+     * @return 	false when nothing could be interpreted
+    **/
+    private final boolean unitec (Parsing text, StringBuffer edited) 
+      throws ParseException {
+      int posini = text.pos;
+      Unit tunit = null;		// Temporary Unit
+      int log_index = -1;		// Index in log_symb
+      char op =  Character.MIN_VALUE;	// Operator
+      char end = Character.MIN_VALUE;
+      int error = 0;
+      int i, s;
+
+    	/* Initialize the Unit to unitless */
+    	mksa = _; 
+
+	if (DEBUG>0) System.out.print("....unitec(" + text + "): factor=");
+	//System.out.println("..unitec(0): edited=<" + edited + ">");
+	/* Ignore the leading blanks */
+	text.gobbleSpaces();
+
+	/* Possibly all as Log */
+	log_index = text.lookup(log_symb) ;
+	if (log_index >= 0) {		// A log(...) or mag(...)
+	    end = log_end[log_index] ;
+	    if (edited != null) edited.append(log_symb[log_index&(~3)]) ;
+	}
+
+    	/* Interpret the Factor */
+	s = text.pos;			// Save
+	factor = text.parseFactor();	// Default is 1.0
+	if (DEBUG>0) System.out.println(factor);
+	if ((edited != null) && (s != text.pos))
+	    edited.append(text.a, s, text.pos-s) ;
+
+	/* Find out the Units and Operators */
+	s = -1;					// Index of Operator in op_symb
+	while (text.pos < text.length) {
+	    if (text.a[text.pos] == end) break;	/* Closing the log() */
+	    if (op == Character.MIN_VALUE) {
+		i = this.unit1(text, edited);
+	        if (DEBUG>0) { if (tunit != null) tunit.dump("..unitec"); }
+		op = 'x';			// Default operator
+	    }
+	    else {
+	        if (tunit == null) tunit = new Unit();
+		i = tunit.unit1(text, edited);
+	    	//System.out.println("..unitec(1): edited=<" + edited + ">");
+	        if (DEBUG>0) {
+		    tunit.dump("..unitec");
+	    	    System.out.println("    combining with op=" + op);
+		    System.out.println("    this=" + this + " \tfactor=" + this.factor);
+		    System.out.println("    temp=" + tunit+ " \tfactor=" + tunit.factor);
+		}
+	        // if (i == 0) break;		// Accept Nothing matched
+	        if (op == '/') this.div(tunit) ;
+	        else this.mult(tunit) ;
+	    }
+
+	    /* V1.1: offset may be specified with #+/- , e.g.  K#+273.15 */
+	    if (text.match('#')) { 
+		int old_pos = text.pos-1;	// Just before the #
+		double o = text.parseFactor();
+		if (text.pos <= old_pos+3) 	// Not an offset, need 3 bytes
+		    text.pos = old_pos;
+		else this.offset = o;
+		if ((edited != null) && (this.offset != 0)) {
+		    edited.append("(offseted by ");
+		    editing.editDouble(edited, this.offset, 
+			    Astroformat.SIGN_EDIT);
+		    edited.append(')');
+		}
+	    }
+
+	    /* Which operator is applied on on the value ? */
+	    if ((mksa&_abs)!=0) s = -1;		// No operator on date...
+	    else s = text.lookup(op_symb);	// Can there be an Operator ?
+	    if (s < 0) break;			// Can't interpret continuation
+
+	    op = op_symb[s].charAt(0);		// Is always '/' for division
+
+	    if (edited != null) {		// Edit the Operator
+	        // Remove the Ending blanks, to install a single blank
+		i = edited.length(); 
+		while ((--i >= 0)  && (edited.charAt(i) == ' ')) ;
+		edited.setLength(++i);
+		edited.append(' ');
+		edited.append(op_text[s]);
+		//System.out.println("..unitec(2): edited=<" + edited + ">");
+	    }
+	}
+
+	/* Close the log() */
+	if (log_index >= 0) {
+	    if (edited != null) {		// Close the parenthese
+	        // Remove the Ending blanks
+		i = edited.length(); 
+		while ((--i >= 0)  && (edited.charAt(i) == ' ')) ;
+		edited.setLength(++i);
+	        edited.append(log_end[log_index&(~3)]) ;
+	    }
+	    if ((text.pos < text.length) && (end != Character.MIN_VALUE)
+	          &&(text.a[text.pos] == end)) {
+	        end = Character.MIN_VALUE;
+	        text.pos++;
+	    }
+	    mksa |= _log ;
+	    if ((log_index&4) != 0) mksa |= _mag;
+	}
+
+	/* Final Verifications */
+	if (s >= 0) throw new ParseException	// Missing 2nd argument
+	    ("****Unit.text+" + text.pos + " (missing operand): " + text, 
+	    text.pos) ;
+	if (end != Character.MIN_VALUE) throw new ParseException
+	    ("****Unit.text+" + text.pos + " (missing '" + end + "'): " + text, 
+	    text.pos) ;
+
+	/* Skip the trailing blanks */
+	text.gobbleSpaces();
+	if (DEBUG>0) System.out.println("  =>unitec: return=" 
+		+ (text.pos > posini) + "\tfactor=" + factor);
+    	return(text.pos > posini);
+    }
+
+
+    /*==================================================================
+		Set components of a Unit
+     *==================================================================*/
+
+    /** 
+     * Reset a unit to unitless.
+    **/
+    public final void set () {	
+	symbol = null;	
+    	mksa = _; factor = 1;
+	value = 0./0.;			// NaN
+	offset = 0.;
+    }
+
+    /** 
+     * Copy a quantity.
+     * Define a Unit and Value from an existing one (clone)
+     * @param	u the Unit to clone
+    **/
+    public final void set (Unit u) {		// Just copy the instance
+      	  mksa = u.mksa ;
+      	symbol = u.symbol ;
+      	value  = u.value  ;
+      	factor = u.factor ;
+	offset = u.offset ;
+    }
+
+    /** 
+     * Interpret a string for a value + Unit.
+     * @param  	t text to interpret. For instance <br>
+     *	100km/s is interpreted as  Unit=<b>km/s</b>; Value=<b>100</b><br>
+     *		To add a numeric factor in Unit, use parentheses, e.g. <br>
+     *		123(100km/s) is: Unit: <b>100km/s</b>; Value=<b>123</b>.
+     *		The unit symbol may <em>precede</em> the value -- 
+     *		this way is required for sexagesimal and dates.
+     * @return	true if something found, false if nothing found.
+    **/
+    public boolean parsing (Parsing t) {
+      int posini = t.pos;
+      boolean has_value, has_symbol;
+      int pos, j;
+      double val;
+        if (!initialized) init();		// Be sure everyting in place
+
+	t.gobbleSpaces();			// Ignore the leading blanks
+	pos = t.pos;
+
+	if (DEBUG>0) System.out.print("....parsing(" + t + "):");
+
+	/* Interpret the Value, if any */
+	val  = t.parseFactor();			// Default value is 1
+	if (DEBUG>0) System.out.print(" val=" + val);
+	has_value = t.pos > pos; 		// NaN when nothing interpreted
+
+        /* Skip blanks between value and Unit */
+	t.gobbleSpaces();
+
+	/* It may happen that interpreting the Value first generates an error,
+	   for instance 1/4. That means that the number (1) is part of the
+	   unit, and is not the value in front of the unit.
+	*/
+	if (t.lookup(op_symb) >= 0) {
+	    has_value = false;
+	    t.pos = pos;
+	    if (DEBUG>0) System.out.print("(FALSE!)");
+	}
+
+	/* Interpret the Unit */
+	pos    = t.pos;				// To keep the Unit symbol
+	offset = 0.;
+	symbol = null;
+	if (DEBUG>0) System.out.println("\n    Interpret '" + t + "'");
+      	try { 
+	    has_symbol = unitec(t, null); 
+	    symbol = String.copyValueOf(t.a, pos, t.pos-pos);
+	    Object o = hUnit.get(symbol);
+	    if (o instanceof String) symbol = (String)o;
+	    if (has_value & (mksa&_pic) != 0) {	// A misinterpretation ? Rescan
+		int pos_end = t.pos;
+		t.set(posini); t.gobbleSpaces();
+		try { t.parseComplex(symbol); t.set(pos_end); }
+		catch(Exception e) { 
+		    t.set(posini); 
+		    return(false); 
+		}
+	    }
+	}
+	catch(Exception e) { 
+	    if (DEBUG>0) {
+	         System.out.println("++++unitec catched: " + e);
+	         e.printStackTrace();
+	         try { Thread.sleep(2000); } catch(Exception i) {;}
+	    }
+	    has_symbol = false; 
+	    t.pos = pos;
+	}
+	if (DEBUG>0) System.out.println("\n    interpret '" + t 
+		+ "', has_value=" + has_value);
+
+	// Default value in log scale is 0 !
+	// if (no_value && ((mksa&_log) != 0)) value = 0;
+	/* Skip the trailing blanks */
+
+	/* The value may follow the unit -- only for dates and "special"
+	 * quoted unit
+	 */
+	if ((!has_value) && (t.pos < t.length)) {
+	    pos = t.pos;
+	    // The symbol may be a "picture" e.g. "YYYY/MMM/DD"
+	    if ((!has_symbol) && (t.currentChar() == '"')) {
+		if ((j = t.matchingQuote()) > 0) {
+		    Udef u; int ip1, ip2;
+		    String msg;
+		    if (DEBUG>0) System.out.println(
+			    "....parsing: t.matchingQuote()=" + j);
+		    j -= pos; j++;		// Length including quotes
+		    symbol = t.toString(j);
+		    t.advance(j);
+		    t.gobbleSpaces();
+		    pos = t.pos;
+		    try { val = t.parseComplex(symbol); }
+		    catch(ParseException e) {	// Mismatch: could be mixed up
+			msg = e.getMessage();
+			if (msg.indexOf("parseComplex((")>=0) 	// ERROR in pic
+			    System.err.println(e);
+			t.set(posini);
+			return(false);
+		    }
+		    if (t.status() != 0) {	// Something wrong in 'picture'
+			msg = t.error_message;
+			if ((ip1 = msg.indexOf(" interpreted as (")) >0) {
+			    ip1 = msg.indexOf('(', ip1);
+			    ip2 = msg.indexOf(')', ip1);
+			    String correct_symbol = msg.substring(ip1+1, ip2);
+			    if (DEBUG>0) System.out.println(
+				    "....parsing: adding Hash "+symbol
+				    +" => "+correct_symbol);
+			    /* Add the new 'picture' as an alias 
+			     * to the correctly spelled one.
+			     */
+			    hUnit.put(symbol, correct_symbol);
+			    symbol = correct_symbol;
+			    t.pos = pos;
+			    try { val = t.parseComplex(symbol); }
+			    catch (ParseException pe) {
+				System.err.println(pe);
+				pe.printStackTrace();
+				t.set(posini);
+				return(false);
+			    }
+			}
+			else {
+			    System.err.println(msg);
+			    t.set(posini);
+			    return(false);
+			}
+		    }
+		    has_value = true;
+		    if (t.isDate())      u = uLookup("MJD");
+		    else if (t.isDays()) u = uLookup("d");
+		    else if (t.isTime()) u = uLookup("\"h:m:s\"");
+		    else                 u = uLookup("\"d:m:s\"");
+		    // The quoted symbol is added, to speed up its retrieval
+		    // in the next search.
+		    try {
+		      addSymbol(symbol, u.symb, Parsing.explainComplex(symbol));
+		      u = uLookup(symbol);
+		      u.mksa |= _pic;
+		    }
+		    catch (ParseException pe) {
+			System.err.println(pe); 
+			pe.printStackTrace();
+		    }
+		    mksa   = u.mksa;
+		    factor = u.fact;
+		}
+	    }
+	    if (has_symbol && (t.pos<t.length)) {
+	    if (DEBUG>0) System.out.println("....parsing: symbol=" + symbol 
+		    + ", interpret: " + t);
+		if (mksa == _MJD) {		// Get Date + Time
+		    if (DEBUG>0) System.out.print("    parsing via Astrotime(");
+		    Astrotime datime = new Astrotime();
+		    if (Character.isLetter(symbol.charAt(0)))
+			t.set(posini);		// JD or MJD followed by number
+		    if (DEBUG>0) System.out.print(t + ") symbol=" + symbol);
+		    has_value = datime.parsing(t);
+		    if (has_value) val = datime.getMJD();
+		    if (DEBUG>0) {
+			System.out.println(" has_value=" + has_value 
+			    + ", MJD=" + val);
+			datime.dump("datime ");
+		    }
+		}
+		else if ((mksa&_pic) != 0) {	// Interpret complex
+		     try { val = t.parseComplex(symbol); has_value = true; }
+		     catch (Exception e) { t.set(posini); return(false); }
+		}
+		//* No other case! else val = t.parseFactor();
+	    }
+	}
+
+	// Final: Store the results.
+	value = has_value ? val : 0./0.;
+	if (has_symbol|has_value) {
+	    return(true);
+	}
+	t.pos = posini;
+	return(false);				// Nothing found...
+    }
+
+
+    /** Interpret a String to a Unit + Value
+     * @param  	text text to interpret. For instance <br>
+     *	100km/s is interpreted as  Unit=<b>km/s</b>; Value=<b>100</b><br>
+     *		To add a numeric factor in Unit, use parentheses, e.g. <br>
+     *		123(100km/s) is: Unit: <b>100km/s</b>; Value=<b>123</b>.
+     *		The unit symbol may <em>precede</em> the value -- 
+     *		this way is required for sexagesimal and dates.
+     * @throws  ParseException when the argument contains non-interpretable
+     * 		text
+    **/
+    public void set (String text) throws ParseException {
+      Parsing t = new Parsing(text);
+      boolean p;
+        this.set();				// Reset
+        p = this.parsing(t);
+	t.gobbleSpaces();
+	/* Accept NULL */
+	if (DEBUG>0) System.out.println("....Unit.set("+text+")" + p 
+		+ " => " + this.toString());
+      	if (t.pos < t.length) throw new ParseException
+           ("****Unit: set '"  + text + "'+" + t.pos, t.pos);
+    }
+
+    /** 
+     * Examine a String for a Unit + Value
+     * @param  	text text to interpret; for instance <br>
+     *	100km/s is interpreted as  Unit=<b>km/s</b>; Value=<b>100</b><br>
+     *		To add a numeric factor in Unit, use parentheses, e.g. <br>
+     *		123(100km/s) is: Unit: <b>100km/s</b>; Value=<b>123</b>
+     * @param  	offset where to start in the text string.
+     * @return	the new position in text following what's interpretated
+     * 		text
+    **/
+    public int parse (String text, int offset) {
+      Parsing t = new Parsing(text, offset);
+      if (true) {
+	this.parsing(t);
+      }
+      else {				//*** OLD CODE
+        double val;
+        int pos1, pos2, pos3;
+        boolean has_value, has_unit;
+        if (!initialized) init();	// Be sure everyting in place
+
+        /* Ignore the leading blanks */
+	t.gobbleSpaces();
+	pos1 = t.pos;			// Just before the possible value
+
+	/* Interpret the Value, if any */
+	val  = t.parseFactor();		// Default value is 1
+	pos2 = t.pos;			// After interpretation of Value
+	has_value = pos2 > pos1; 	// Something was found.
+
+        /* Skip blanks between value and Unit */
+	t.gobbleSpaces();
+
+	/* It may happen that interpreting the Value first generates an error,
+	   for instance 1/4. That means that the number (1) is part of the
+	   unit, and is not the value in front of the unit.
+	*/
+	if (t.lookup(op_symb) >= 0) {
+	    has_value = false;
+	    t.pos = pos1;
+	    pos2  = pos1;
+	}
+
+	/* Interpret the Unit */
+	has_unit = true;
+	pos3 = t.pos;			// Starting offset of unit
+      	try { unitec(t, null) ; }
+	catch (Exception e) {
+	    has_unit = false;
+	    t.pos = pos2;
+	    if (!has_value) t.pos = offset;
+	}
+	if (has_unit) symbol = text.substring(pos3, t.pos);
+	value = has_value ? val : 0./0. ;
+      }
+      return(t.pos);
+    }
+
+
+    /** 
+     * Look in the input string for a Unit
+     * @param  	text to be interpreted as a Unit.
+     * 		The value part is always set to NaN.
+     * @param  	offset where to start in the text string.
+     * @return	the new position in text following what's interpretated
+    **/
+    public int parseUnit (String text, int offset) {
+      int o = parse(text, offset);
+	this.setUnit();
+	return(o);
+    }
+
+    /** 
+     * Look in the input string for a value
+     * @param  	text value (set to NaN when not correct), which can use the
+     *		exponential notation like <tt>10+8</tt> to express 
+     *		<b>10<sup>8</sup></b>
+     * @param  	offset where to start in the text string.
+     * @return	the new position in text following what's interpretated
+    **/
+    public int parseValue (String text, int offset) {
+      Parsing t = new Parsing(text, offset);
+      int posini;
+        /* Ignore the leading blanks */
+	t.gobbleSpaces();
+	posini = t.pos;
+	/* Take care of units requiring data in Sexagesimal */
+	if ((mksa&_sex) != 0)
+	     value  = t.parseSexa();
+	else value  = t.parseFactor();
+	if (t.pos == posini) 		// Nothing (NaN checked in Parsing)
+	    return(offset);
+	    // while ((t.pos < t.length) && (t.a[t.pos] == '-')) t.pos++;
+	return(t.pos);
+    }
+
+    /** 
+     * Convert the current number+Unit into a Unit.
+     * 		For instance, if value is 100 and unit is km/s,
+     * 		the value becomes 1 and the unit becomes (100km/s).
+     * 		Similar to setUnit(toString())
+    **/
+    public void setUnit () {
+      double f = factor;
+        /* Transform the value as a part of Unit */
+        if (Double.isNaN(value)) return;
+	if ((mksa&_log) != 0) {
+	    if ((mksa&_mag) != 0) value *= -2.5;
+	    factor *= AstroMath.dexp(value);
+	    value = 0;
+	}
+	else {
+	    factor *= value;
+	    value = 1.;
+	}
+	// Transform also the symbol
+	if (f != factor) {
+	    if (symbol == null) symbol = edf(factor);
+	    else symbol = edf(factor) + toExpr(symbol);
+	}
+    }
+
+    /** 
+     * Assigns the Unit.
+     * The value of the quantity is unchanged.
+     * @param  	text to be interpreted as a Unit.
+     * 		The value part is always set to NaN.
+     * @throws  ParseException when the argument text which does not 
+     *		represent a number
+    **/
+    public void setUnit (String text) throws ParseException {
+        this.set(text);
+	this.setUnit();
+    }
+
+    /** 
+     * Assign the <em>value</em>.
+     * The unit of the quantity is unchanged.
+     * @param  	text value (set to NaN when not correct), which can use the
+     *		exponential notation like <tt>10+8</tt> to express 
+     *		<b>10<sup>8</sup></b>
+     * @throws  ParseException when the argument text which does not 
+     *		represent a number
+    **/
+    public void setValue (String text) throws ParseException {
+      Parsing t = new Parsing(text);
+      int posini;
+        /* Ignore the leading blanks */
+	t.gobbleSpaces();
+	posini = t.pos;
+	/* Take care of units requiring data in Sexagesimal */
+	if ((symbol.charAt(0) == '"') && (symbol.indexOf(':')>0)) 	// "
+	     value  = t.parseSexa();
+	else value  = t.parseFactor();
+	if (t.pos == posini) {		// Nothing (NaN checked in Parsing)
+	    value = 0./0. ;
+	    // while ((t.pos < t.length) && (t.a[t.pos] == '-')) t.pos++;
+	}
+	/* Skip the trailing blanks */
+	t.gobbleSpaces();
+	if (t.pos < t.length) throw new ParseException
+           ("****Unit: setValue '" + text + "'+" + t.pos, t.pos);
+    }
+
+    /** 
+     * Assign the <em>value</em>.
+     * The unit of the quantity is unchanged.
+     * @param  	value value to set
+    **/
+    public void setValue (double value) {
+      this.value = value;
+    }
+
+    // ==================================================================
+    //		Internal methods for Editing Units
+    // ==================================================================
+
+    /** 
+     * Edition of a single factor number if differs from 1 <br>
+     * Edition as x.fraction&times;10&pm;pow
+     * @param	buf  the edition buffer to which the edited number is appended
+     * @param	factor the number to edit
+     * @return	the number of bytes added to buf
+    **/
+    private static final StringBuffer edf (StringBuffer buf, double factor) {
+        /* Finally, return the edition with the appropriate routine */
+        return(editing.editDouble(buf, factor, Editing.FACTOR));
+    }
+
+    /** 
+     * Edition of a single factor number if differs from 1 as a String
+     * @param	factor the number to edit
+     * @return	the edited factort
+    **/
+    private static final String edf (double factor) {
+      StringBuffer buf ;
+	if (factor == 1) return("") ;
+	buf = new StringBuffer(32);
+	edf(buf, factor);
+	return("" + buf);
+    }
+	
+    /** 
+     * Edit the MKSA part, choose the most appropriate unit
+     * @param  	buf edition buffer
+     * @param  	mksa the 'dimension' of the unit (the 'log' is ignored)
+     * @param  	option 0 = only basic SI; 1 = try best
+     * @return 	the number of bytes used to explain the MKSA
+    **/
+    private static final int edu (StringBuffer buf, long mksa, int option) {
+      int len0 = buf.length();
+      int i, e, o, xff;
+      int nu=0; 
+      boolean sep = false;
+      long m;
+
+	/* Remove the 'log' or 'mag[]' part */
+	if ((mksa&_log) != 0) {
+	    mksa &= ~_log;
+	    if ((mksa&_mag) != 0) mksa &= ~_mag;
+	}
+
+    	/* Check unitless -- edited as empty string */
+    	if (mksa == _) return(0);
+
+	/* Find the best symbol for the physical dimension */
+	if (option > 0) {
+	    nu = (mksa&_mag) == 0 ? 0 : 1;
+    	    for (m=(mksa<<8)>>8; m!=0; m >>>= 8) {
+                if ((m&0xff) != _e0 ) nu++ ;
+    	    }
+
+    	    /* Find whether this number corresponds to a composed unit */
+    	    for (i=0; i<uDef.length; i++) {
+                if (uDef[i].mksa != mksa) continue;
+	        if (uDef[i].fact != 1) continue;
+	        buf.append(uDef[i].symb) ;
+	        break;
+    	    }
+
+    	    // A basic unit need no explanation 
+    	    if (nu == 1) return(buf.length() - len0) ;
+
+    	    // Add the explanation in MKSA within parenthesis
+    	    if (buf.length() != len0) buf.append(" [") ;
+    	    else nu = 0;	// nu used as an indicator to add the ) 
+	}
+
+	o = _m0;	// Zero power of magnitude
+	xff = 7;	// Mask for magnitude
+    	for (i=0; i<8; i++) {
+	    e = (int)((mksa>>>(56-(i<<3)))&xff) - o;
+	    o = _e0 ;	// Other units: the mean is _e0 
+	    xff = 0xff;	// Other units
+	    if (e == 0) continue;
+	    if (sep) buf.append("."); sep = true;
+	    buf.append(MKSA[i]);
+	    if (e == 1) continue;
+	    if (e>0) buf.append("+") ;
+	    buf.append(e) ;
+    	}
+    	if (nu>0) buf.append("]");
+    	return(buf.length() - len0) ;
+    }
+
+    /** 
+     * Edit the unit in terms of SI basic units.
+     * @param 	b Buffer to fill
+     * @param 	option level of Explanation
+     *		0 = only SI, 1 = detail
+     * @return 	the explanation with basic SI units
+    **/
+    private void toSI (StringBuffer b, int option) {
+	boolean close = false;
+	if ((mksa&_log) != 0) b.append(
+	    (mksa&_mag) != 0 ? "mag[" : "log[");
+	if (factor != 1) {
+	    edf(b, factor);
+	    if (offset != 0) { b.append('('); close = true; }
+	}
+	edu(b, mksa, option);
+	if (offset != 0) {	// V1.1: Edit offset
+	    b.append("#");
+	    edf(b, -offset);
+	    if (close) b.append(')'); 
+	}
+	if ((mksa&_log) != 0) b.append("]") ;
+    }
+
+    /*==================================================================
+		Editions of Units
+     *==================================================================*/
+
+    /** 
+     * Dump the details.
+     * Essentially for debugging purposes.
+     * @param	title title of dump
+    **/
+    public void dump (String title) {
+      char[] xdim = new char[24];
+      long m;
+      int i;
+	/* Hexadecimal edition of mksa */
+	for (m=mksa, i=24; i>0; ) {
+	    xdim[--i] = x[(int)(m&15)]; m>>>=4; 
+	    xdim[--i] = x[(int)(m&15)]; m>>>=4; 
+	    xdim[--i] = '.';
+	}
+	xdim[i] = 'x';
+	System.out.println(title + ": symbol='" + symbol 
+	  + "', value=" + value);
+	System.out.print  ("        factor=" + factor 
+	  + ", Dim0" + new String(xdim));
+	if (offset!=0) System.out.print(" offset=" + offset);
+	System.out.println("");
+    }
+
+   /**
+    * Edit the physical dimension of a unit.
+    * @param buf  Buffer where the result is appended. A question mark (?)
+    * 			indicates problems.
+    * @return   the StringBuffer
+    */
+    public final StringBuffer editDimension(StringBuffer buf) {
+	int i, dim;
+	for (i=1; i<MKSAdim.length; i++) {
+	    if (MKSAdim[i] == Character.MIN_VALUE) continue;
+	    dim = (int)((mksa>>((7-i)*8))&0xff) - _e0;
+	    if (dim == 0) continue;
+	    buf.append(MKSAdim[i]);
+	    if (dim>0) buf.append('+');
+	    buf.append(dim);
+	}
+	return(buf);
+    }
+
+   /**
+    * Physical dimension of a unit.
+    * @return   the dimension with <b>MLTAK</b> and exponent.
+    *  		The symbols mean Mass, Length, Time, Ampere
+    * 		and Kelvin respectively.
+    */
+    public final String dimension() {
+	StringBuffer b = new StringBuffer(16);
+	this.editDimension(b);
+	return(b.toString());
+    }
+
+
+   /**
+    * Edit the value in a StringBuffer
+    * @param buf  Buffer where the result is appended
+    * @return   the StringBuffer
+    */
+    public final StringBuffer editValue(StringBuffer buf) {
+
+	if (Double.isNaN(value)) 
+	    return(edf(buf, value));
+
+	if (mksa == _MJD) {				// Date
+	    if (symbol.startsWith("\"dat")) {
+		double mjd = value + offset/factor;
+		int day = (int)mjd;
+		if (value<0) --day;
+	        double sec = (mjd - day)*86400;		// seconds.
+		editing.editDate(buf, day);
+		if (symbol.startsWith("\"datim")) {
+		    buf.append('T');
+		    editing.editSexa(buf, sec/3600., 2, 
+			    -10 /* precision up to micro-sec */, 
+			    editing.ZERO_FILL|editing.SEXA3c);
+		}
+		else if (sec >= 1.e-6) 		// Edit fraction of day
+		    editing.editDecimal(buf, sec/86400., 0 /* No fraction! */,
+			    -11 /* 10-11day =~ 1 micro-sec */, 0);
+	    }
+	    else if (symbol.charAt(0) == '"') 
+		editing.editComplex(buf, value, symbol);
+	    else { 				// JD or MJD 
+		// Precision = 10-10day if JD, 10-11d if MJD
+		int ndec = symbol.charAt(0) == 'J' ? -10 : -11;
+		editing.editDecimal(buf, value, 0, ndec, 0);
+	    }
+	}
+	else if ((mksa&_pic) != 0)
+	    editing.editComplex(buf, value, symbol);
+	else if ((mksa&_sex) != 0)
+	    editing.editSexa(buf, value, 1, -9, editing.SEXA3c);
+	else edf(buf, value);
+	return(buf);
+    }
+
+    /** 
+     * Edition of the quantity.
+     * This edition expresses the value and its associated unit;
+     * the unit is attached to the value as e.g. <b>10km/s</b>,
+     * but precedes the value for complex values or dates as e.g.
+     * <b>MJD51234</b> or <b>"h:m:s"23:59:58</b>
+     * @param buf  Buffer where the result is appended
+     * @return 	the edited value and unit
+    **/
+    public final StringBuffer edit(StringBuffer buf) {
+      boolean symb_edited = false;
+      int symlen = 0;
+	if (DEBUG>0) dump("unit.edit");
+	if (symbol != null) symlen = symbol.length();
+	// For dates & pictures, edit the symbol first
+	if ((mksa&(_pic|_abs|_sex)) != 0) {
+	    symb_edited = true;
+	    buf.append(symbol);
+	}
+	// When no value given, there must be a representation.
+        if ((!Double.isNaN(value)) || (symlen == 0)) {
+	    editValue(buf);
+	}
+	if ((mksa == _) && (factor == 1));
+	else if (!symb_edited) {
+	    if (symlen > 0) buf.append(symbol) ;
+	    else { buf.append('('); toSI(buf, 0); buf.append(')'); }
+	}
+	return(buf);			// Buffer converted to String
+    }
+
+
+   /** 
+    * Explain the unit given in argument.
+    * Interpret a String representing a Unit, and return
+    *          a complete explanation.
+    * @param  	text the text containing the units to explain
+    * @return 	the full explanation of the Unit -- or a text 
+    * 		<tt>?***bad Unit</tt> when <em>text</em> is not interpretable
+   **/
+    public static final String explainUnit (String text) {
+      Parsing  t = new Parsing(text);
+      StringBuffer b = new StringBuffer(120) ;
+      Unit u = new Unit();
+      int ini1 = 0;
+	if (!initialized) init();
+      	try { u.unitec(t, b); }
+	catch (Exception e) { 
+	    if (DEBUG>0) {
+	        System.out.println("++++explainUnit: catched: " + e); 
+	        try { Thread.sleep(2000); } catch(Exception i) {;}
+	    }
+	    if (t.currentChar() == '"') {	// "picture" unit
+	 	b.append(Parsing.explainComplex(t.toString()));
+	    }
+	    else { String prefix = "?***bad Unit <";
+	        b.insert(0, prefix);
+	        b.insert(prefix.length(), text);
+	        b.insert(prefix.length() + text.length(), "> ");
+	    }
+	}
+	//System.out.println("\n..explainUni........<" + b + ">");
+	ini1 = skipBrackets(b);			// Remove enclosing Parentheses
+	// return(""+b.substring(ini1));	// Java>=1.2
+	return(b.toString().substring(ini1));	// AnyJavaVersion
+    }
+
+    /** 
+     * Give a full explanation of the unit.
+     * @return 	the explanation in terms of SI units
+    **/
+    public final String explainUnit () {
+      StringBuffer b = new StringBuffer(120) ;
+      Parsing  t = new Parsing(symbol);
+      Unit u = new Unit();
+      int ini1 = 0;
+	try { u.unitec(t, b); }
+	catch (Exception e) {
+	    if (DEBUG>0) {
+		System.out.println("++++explainUnit: catched: " + e);
+		try { Thread.sleep(2000); } catch(Exception i) {;}
+	    }
+	    if (t.currentChar() == '"') {	// "picture" unit
+	 	b.append(Parsing.explainComplex(t.toString()));
+	    }
+	    else { String prefix = "?***bad Unit <";
+	        b.insert(0, prefix);
+	        b.insert(prefix.length(), symbol);
+	        b.insert(prefix.length() + symbol.length(), "> ");
+	    }
+	}			// Should never happen!
+	ini1 = skipBrackets(b);			// Remove enclosing Parentheses
+	b.append(" ("); toSI(b, 1); b.append(")") ;
+      	// return(""+b.substring(ini1));	// Java>=1.2
+	return(b.toString().substring(ini1));	// AnyJavaVersion
+    }
+
+    /** Explain the Unit+Value in terms of SI units
+     * (Convert to non-log)
+     * @return 	the explanation with basic SI units
+    **/
+    public final String toStringInSI() {
+      StringBuffer b = new StringBuffer(64) ;
+      Unit u = new Unit(this) ;
+	/* Convert the value to linear scale, and then edit */
+	if ((u.mksa&_log) != 0) u.mksa &= ~(_log|_mag);
+	if (u.offset != 0) {		// Find the corresponding SI !
+	    Udef base = uLookup(u.mksa);
+	    u.symbol = base.symb;
+	    u.offset = base.orig;
+	}
+        u.factor = 1; 
+        u.convertFrom(this);
+	if (!Double.isNaN(value)) { 
+	    edf(b, u.value);
+	    if (b.length() == 0) b.append('1');
+	}
+        u.toSI(b, 0);
+      	return(""+b);			// Buffer converted to String
+    }
+
+    /*==================================================================
+		Standard Edition
+     *==================================================================*/
+
+    /** 
+     * Standard Edition of the Unit.
+     * Both value and associated unit are given; the conventions are
+     * detailed in {@link #edit}
+     * @return 	the edited value and unit.
+     * To edit the value only, see {@link #editedValue}
+    **/
+    public String toString () {
+      StringBuffer b = new StringBuffer(120) ;
+      boolean symb_edited = false;
+	if (DEBUG>0) dump("unit.toString");
+	// For dates & pictures, edit the symbol first
+	if ((mksa&(_pic|_abs|_sex)) != 0) {
+	    symb_edited = true;
+	    b.append(symbol);
+	}
+        if (!Double.isNaN(value)) {
+	    editValue(b); 		// Value '1' not edited
+	    if (b.length() == 0) b.append((mksa&_log)!=0 ? '0' : '1');
+	}
+	if ((mksa == _) && (factor == 1));
+	else if (!symb_edited) {
+	    if (symbol != null) b.append(symbol) ;
+	    else { b.append('('); toSI(b, 0); b.append(')'); }
+	}
+	return(b.toString());		// Buffer converted to String
+    }
+
+    /** 
+     * String represntation of the value.
+     * The unit is not edited.
+     * @return 	the edited value
+     * To edit the value and the number, see {@link #toString}
+    **/
+    public String editedValue() {
+      StringBuffer b = new StringBuffer(120) ;
+        editValue(b);
+	return(b.toString());		// Buffer converted to String
+    }
+
+}
