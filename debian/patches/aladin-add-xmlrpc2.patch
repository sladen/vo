Description: Add the source of xmlrpc-2
 We still cannot manage to get aladin running with xmlrpc-3 (which is
 distributed within Debian); so we temporarily need xmlrpc-2 here.
Author: Ole Streicher <olebole@debian.org>
Last-Update: 2016-11-03
--- /dev/null
+++ b/org/apache/xmlrpc/AsyncCallback.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+
+import java.net.URL;
+
+/**
+ * A callback interface for an asynchronous XML-RPC call.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @version $Id: AsyncCallback.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public interface AsyncCallback
+{
+    /**
+     * Call went ok, handle result.
+     */
+    public void handleResult(Object result, URL url, String method);
+
+    /**
+     * Something went wrong, handle error.
+     */
+    public void handleError(Exception exception, URL url, String method);
+}
--- /dev/null
+++ b/org/apache/xmlrpc/AuthDemo.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Vector;
+
+/**
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @version $Id: AuthDemo.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class AuthDemo implements AuthenticatedXmlRpcHandler
+{
+    /**
+     *
+     */
+    public Object execute(String method, Vector v, String user, String password)
+            throws Exception
+    {
+        // our simplistic authentication guidelines never fail ;)
+        if (user == null || user.startsWith("bad"))
+        {
+            throw new XmlRpcException(5, "Sorry, you're not allowed in here!");
+        }
+
+        return ("Hello " + user);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/AuthenticatedXmlRpcHandler.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Vector;
+
+/**
+ * An XML-RPC handler that also handles HTTP authentication.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @see org.apache.xmlrpc.AuthenticationFailed
+ */
+public interface AuthenticatedXmlRpcHandler
+{
+    /**
+     * Return the result, or throw an Exception if something went wrong.
+     *
+     * @param method The name of the XML-RPC method to invoke.
+     * @param params The parameters to the XML-RPC method.
+     * @param user The user name.
+     * @param password The password of <code>user</code>.
+     * @return The response.
+     *
+     * @throws AuthenticationFailed If authentication fails, an
+     * exception of this type must be thrown.
+     * @see org.apache.xmlrpc.AuthenticationFailed
+     */
+    public Object execute(String method, Vector params, String user,
+                          String password)
+        throws Exception;
+}
--- /dev/null
+++ b/org/apache/xmlrpc/AuthenticationFailed.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+
+/**
+ * Thrown as the result of an authentication failure.
+ *
+ * @author Daniel L. Rall
+ * @see org.apache.xmlrpc.AuthenticatedXmlRpcHandler
+ * @since 1.2
+ */
+public class AuthenticationFailed extends RuntimeException
+{
+    public AuthenticationFailed()
+    {
+    }
+
+    public AuthenticationFailed(String msg)
+    {
+        super(msg);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/CommonsXmlRpcTransport.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+import org.apache.commons.httpclient.Credentials;
+import org.apache.commons.httpclient.Header;
+import org.apache.commons.httpclient.HostConfiguration;
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.URI;
+import org.apache.commons.httpclient.UsernamePasswordCredentials;
+import org.apache.commons.httpclient.methods.PostMethod;
+
+/**
+ * Implementor of the XmlRpcTransport interface using the Apache
+ * Commons HttpClient library v2.0 available at
+ * http://jakarta.apache.org/commons/httpclient/
+ *
+ * Note: <b>Currently this transport is not thread safe</b>
+ *
+ * @author <a href="mailto:rhoegg@isisnetworks.net">Ryan Hoegg</a>
+ * @version $Id: CommonsXmlRpcTransport.java 350039 2005-11-30 21:30:55 +0100 (Mi, 30 Nov 2005) jochen $
+ * @since 2.0
+ */
+public class CommonsXmlRpcTransport implements XmlRpcTransport 
+{
+    private URL           url;
+    private HttpClient    client;
+    private final Header  userAgentHeader = new Header("User-Agent", XmlRpc.version);
+    private boolean       http11          = false; // defaults to HTTP 1.0
+    private boolean       gzip            = false;
+    private boolean       rgzip           = false;
+    private Credentials   creds;
+    
+    protected PostMethod method;
+
+    /** Creates a new instance of CommonsXmlRpcTransport */
+    public CommonsXmlRpcTransport(URL url, HttpClient client) 
+    {
+        this.url = url;
+        
+        if (client == null) 
+        {
+            HttpClient newClient = new HttpClient();
+            this.client = newClient;
+        } 
+        else 
+        {
+            this.client = client;
+        }
+    }
+    
+    public CommonsXmlRpcTransport(URL url) 
+    {
+        this(url, null);
+    }
+    
+    public InputStream sendXmlRpc(byte[] request) throws IOException, XmlRpcClientException 
+    {
+        method = new PostMethod(url.toString());
+        method.setHttp11(http11);
+        method.setRequestHeader(new Header("Content-Type", "text/xml"));
+        
+        if (rgzip)
+        	method.setRequestHeader(new Header("Content-Encoding", "gzip"));
+        
+        if (gzip)
+        	method.setRequestHeader(new Header("Accept-Encoding", "gzip"));
+                
+        method.setRequestHeader(userAgentHeader);
+
+        if (rgzip)
+        {
+        	ByteArrayOutputStream lBo = new ByteArrayOutputStream();
+        	GZIPOutputStream lGzo = new GZIPOutputStream(lBo);
+        	lGzo.write(request);
+        	lGzo.finish();        	
+        	lGzo.close();        	
+        	byte[] lArray = lBo.toByteArray();
+        	method.setRequestBody(new ByteArrayInputStream(lArray));
+        	method.setRequestContentLength(-1);
+        }
+        else
+        	method.setRequestBody(new ByteArrayInputStream(request));
+        
+        URI hostURI = new URI(url.toString());
+        HostConfiguration hostConfig = new HostConfiguration();
+        hostConfig.setHost(hostURI);
+        client.executeMethod(hostConfig, method);
+
+        boolean lgzipo = false;
+        
+        Header lHeader = method.getResponseHeader( "Content-Encoding" );
+        if ( lHeader != null ) {
+            String lValue = lHeader.getValue();
+            if ( lValue != null )
+        		lgzipo = (lValue.indexOf( "gzip" ) >= 0);
+        }
+
+        if (lgzipo)
+        	return( new GZIPInputStream( method.getResponseBodyAsStream() ) );
+        else
+        	return method.getResponseBodyAsStream();
+    }
+    
+    /**
+     * Make use of HTTP 1.1 
+     * 
+     * @param http11 HTTP 1.1 will be used if http11 is true
+     */
+    public void setHttp11(boolean http11) 
+    {
+        this.http11 = http11;
+    }
+    
+    /**
+     * Transport make use of the 'Accept-Encoding: gzip', so compliant HTTP servers
+     * could return HTTP reply compressed with gzip 
+     *   
+     * @param gzip  Gzip compression will be used if gzip is true
+     */
+    public void setGzip(boolean gzip) {
+        this.gzip = gzip;
+    }
+    
+    /**
+     * Transport make use of the 'Content-Encoding: gzip' and send HTTP request
+     * compressed with gzip : works only with some compliant HTTP servers like Apache 2.x
+     * using SetInputFilter DEFLATE.
+     *   
+     * @param gzip  Compress request with gzip if gzip is true
+     */
+    public void setRGzip(boolean gzip) {
+        this.rgzip = gzip;
+    }
+    
+    /**
+     * Set the UserAgent for this client
+     * 
+     * @param userAgent
+     */
+    public void setUserAgent(String userAgent) 
+    {
+        userAgentHeader.setValue(userAgent);
+    }
+
+    /**
+     * Sets the socket timeout (<tt>SO_TIMEOUT</tt>) in milliseconds which is the 
+     * timeout for waiting for data. A timeout value of zero is interpreted as an 
+     * infinite timeout.
+     *
+     * @param newTimeoutInMilliseconds Timeout in milliseconds
+     */
+    public void setTimeout(int timeout)
+    {
+        client.setTimeout(timeout);
+    }
+    
+    /**
+     * Sets the timeout until a connection is etablished. A timeout value of 
+     * zero means the timeout is not used. The default value is zero.
+     * 
+     * @param newTimeoutInMilliseconds Timeout in milliseconds.
+     * 
+     * @see HttpConnection#setConnectionTimeout(int)
+     */
+    public void setConnectionTimeout(int ctimeout)
+    {
+        client.setConnectionTimeout(ctimeout);
+    }
+        
+    /**
+     * Sets Authentication for this client, very basic for now user/password
+     * 
+     * @param user
+     * @param password
+     */
+    public void setBasicAuthentication(String user, String password)
+    {
+        creds = new UsernamePasswordCredentials(user, password);
+        client.getState().setCredentials(null, null, creds);
+    }
+
+    /**
+     * Sets Authentication for this client.
+     *
+     * @param auth the <username>:<password> formed string used for basic \
+                authentication
+     */
+    public void setBasicAuthentication(String auth)
+    {
+        creds = new UsernamePasswordCredentials(auth);
+        client.getState().setCredentials(null, null, creds);
+    }
+
+    /**
+     * Releases connection resources.
+     *
+     * @exception XmlRpcClientException
+     */
+    public void endClientRequest()
+        throws XmlRpcClientException
+    {
+        method.releaseConnection();
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/CommonsXmlRpcTransportFactory.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.xmlrpc;
+
+import java.net.URL;
+
+import org.apache.commons.httpclient.HttpClient;
+
+
+/** A transport factory, which uses the Jakarta Commons
+ * HttpClient.
+ */
+public class CommonsXmlRpcTransportFactory implements XmlRpcTransportFactory
+{
+	// default properties for new common http-client http transports
+	private URL url;
+	private String auth;
+	private Integer timeout;
+	private Integer connectionTimeout; 
+
+	/** Creates a new instance with the given server URL.
+	 */
+	public CommonsXmlRpcTransportFactory(URL pURL)
+	{
+		url = pURL;
+	}
+
+	public XmlRpcTransport createTransport () throws XmlRpcClientException
+	{
+		HttpClient client = new HttpClient();
+
+		CommonsXmlRpcTransport transport = new CommonsXmlRpcTransport(url, client);
+
+		if (auth != null)
+		{
+			transport.setBasicAuthentication(auth);
+		}
+
+		// set timeout if set
+		if (timeout != null)
+		{
+			transport.setTimeout(timeout.intValue());
+		}
+
+		// set connection timeout if set
+		if (connectionTimeout != null)
+		{
+			transport.setConnectionTimeout(connectionTimeout.intValue());
+		}
+
+		return transport;
+	}
+
+	/**
+	 * Sets Authentication for this client. This will be sent as Basic
+	 * Authentication header to the server as described in
+	 * <a href="http://www.ietf.org/rfc/rfc2617.txt">
+	 * http://www.ietf.org/rfc/rfc2617.txt</a>.
+	 */
+	public void setBasicAuthentication(String pAuth)
+	{
+		auth = pAuth;
+	}
+	
+	/**
+	 * Sets Authentication for this client. This will be sent as Basic
+	 * Authentication header to the server as described in
+	 * <a href="http://www.ietf.org/rfc/rfc2617.txt">
+	 * http://www.ietf.org/rfc/rfc2617.txt</a>.
+	 */
+	public void setBasicAuthentication(String pUsername, String pPassword)
+	{
+		auth = pUsername + ":" + pPassword;
+	}
+
+    /**
+     * Sets the socket timeout (<tt>SO_TIMEOUT</tt>) in milliseconds which is the
+     * timeout for waiting for data. A timeout value of zero is interpreted as an
+     * infinite timeout.
+     *
+     * @param newTimeoutInMilliSeconds timeout in milliseconds (ms)
+     * @see org.apache.commons.httpclient.HttpClient#setTimeout
+     */
+    public void setTimeout(int newTimeoutInMilliSeconds)
+    {
+    	timeout = new Integer(newTimeoutInMilliSeconds);
+    }
+
+    /**
+     * Sets the timeout until a connection is etablished. A timeout value of zero \
+                means the timeout is not used. The default value is zero.
+     *
+     * @param newConnectionTimeoutInMilliSeconds timeout in milliseconds (ms)
+     * @see org.apache.commons.httpclient.HttpClient#setConnectionTimeout
+     */
+    public void setConnectionTimeout(int newConnectionTimeoutInMilliSeconds)
+    {
+    	connectionTimeout = new Integer(newConnectionTimeoutInMilliSeconds);
+    }
+
+	public void setProperty(String propertyName, Object value)
+	{
+		if (TRANSPORT_AUTH.equals(propertyName))
+		{
+			auth = (String) value;
+		}
+		else if (TRANSPORT_URL.equals(propertyName))
+		{
+			url = (URL) value;
+		}
+	}
+}
--- /dev/null
+++ b/org/apache/xmlrpc/ContextXmlRpcHandler.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+
+import java.util.Vector;
+
+/**
+ * An XML-RPC handler that also handles user authentication.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @see org.apache.xmlrpc.AuthenticationFailed
+ * @version $Id: ContextXmlRpcHandler.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public interface ContextXmlRpcHandler
+{
+    /**
+     * Return the result, or throw an Exception if something went wrong.
+     *
+     * @throws AuthenticationFailed If authentication fails, an
+     * exception of this type must be thrown.
+     * @see org.apache.xmlrpc.AuthenticationFailed
+     */
+    public Object execute(String method, Vector params, XmlRpcContext context)
+            throws Exception;
+}
--- /dev/null
+++ b/org/apache/xmlrpc/DefaultHandlerMapping.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+
+import java.util.Hashtable;
+
+/**
+ * Provide a default handler mapping, used by the XmlRpcServer. This
+ * mapping supports the special handler name "$default" that will
+ * handle otherwise unhandled requests.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @see org.apache.xmlrpc.XmlRpcServer
+ * @since 1.2
+ */
+public class DefaultHandlerMapping
+    implements XmlRpcHandlerMapping
+{
+    private Hashtable handlers;
+
+    /**
+     * Create a new mapping.
+     */
+    public DefaultHandlerMapping()
+    {
+        handlers = new Hashtable();
+    }
+
+    /**
+     * Register a handler object with this name. Methods of this
+     * objects will be callable over XML-RPC as
+     * "handlername.methodname". For more information about XML-RPC
+     * handlers see the <a href="../index.html#1a">main documentation
+     * page</a>.
+     *
+     * @param handlername The name to identify the handler by.
+     * @param handler The handler itself.
+     */
+    public void addHandler(String handlerName, Object handler)
+    {
+        if (handler instanceof XmlRpcHandler ||
+                handler instanceof AuthenticatedXmlRpcHandler ||
+                handler instanceof ContextXmlRpcHandler)
+        {
+            handlers.put(handlerName, handler);
+        }
+        else if (handler != null)
+        {
+            handlers.put(handlerName, new Invoker(handler));
+        }
+    }
+
+    /**
+     * Remove a handler object that was previously registered with
+     * this server.
+     *
+     * @param handlerName The name identifying the handler to remove.
+     */
+    public void removeHandler(String handlerName)
+    {
+        handlers.remove(handlerName);
+    }
+
+    /**
+     * Find the handler and its method name for a given method.
+     * Implements the <code>XmlRpcHandlerMapping</code> interface.
+     *
+     * @param methodName The name of the XML-RPC method to find a
+     * handler for (this is <i>not</i> the Java method name).
+     * @return A handler object and method name.
+     * @see org.apache.xmlrpc.XmlRpcHandlerMapping#getHandler(String)
+     */
+    public Object getHandler(String methodName)
+        throws Exception
+    {
+        Object handler = null;
+        String handlerName = null;
+        int dot = methodName.lastIndexOf('.');
+        if (dot > -1)
+        {
+            // The last portion of the XML-RPC method name is the Java
+            // method name.
+            handlerName = methodName.substring(0, dot);
+            handler = handlers.get(handlerName);
+        }
+
+        if (handler == null)
+        {
+            handler = handlers.get("$default");
+
+            if (handler == null)
+            {
+                if (dot > -1)
+                {
+                    throw new Exception("RPC handler object \""
+                                        + handlerName + "\" not found and no "
+                                        + "default handler registered");
+                }
+                else
+                {
+                    throw new Exception("RPC handler object not found for \""
+                                        + methodName
+                                        + "\": No default handler registered");
+                }
+            }
+        }
+
+        return handler;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/DefaultTypeDecoder.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * The default implementation of the <code>TypeDecoder</code>
+ * interface.  Provides the following mappings:
+ *
+ * <table cellpadding="3" cellspacing="2" border="1" width="100%">
+ *   <tr><th>XML-RPC data type</th>         <th>Java class</th></tr>
+ *   <tr><td>&lt;i4&gt; or &lt;int&gt;</td> <td>java.lang.Integer</td></tr>
+ *   <tr><td>&lt;double&gt;</td>            <td>java.lang.Double, java.lang.Float</td></tr>
+ * </table>
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @see org.apache.xmlrpc.TypeDecoder
+ * @since 1.2
+ */
+public class DefaultTypeDecoder
+    implements TypeDecoder
+{
+    /**
+     * Creates a new instance.
+     */
+    public DefaultTypeDecoder()
+    {
+    }
+
+    public boolean isXmlRpcI4(Object o)
+    {
+        return (o instanceof Integer);
+    }
+
+    public boolean isXmlRpcDouble(Object o)
+    {
+        return (o instanceof Float || o instanceof Double);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/DefaultTypeFactory.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+
+import java.text.ParseException;
+import java.util.TimeZone;
+
+import org.apache.commons.codec.binary.Base64;
+import org.apache.commons.codec.DecoderException;
+import org.apache.xmlrpc.util.DateTool;
+
+/**
+ * The default implementation of the <code>TypeFactory</code>
+ * interface.  Provides the following mappings:
+ *
+ * <table cellpadding="3" cellspacing="2" border="1" width="100%">
+ *   <tr><th>XML-RPC data type</th>         <th>Java class</th></tr>
+ *   <tr><td>&lt;i4&gt; or &lt;int&gt;</td> <td>java.lang.Integer</td></tr>
+ *   <tr><td>&lt;boolean&gt;</td>           <td>java.lang.Boolean</td></tr>
+ *   <tr><td>&lt;string&gt;</td>            <td>java.lang.String</td></tr>
+ *   <tr><td>&lt;double&gt;</td>            <td>java.lang.Double</td></tr>
+ *   <tr><td>&lt;dateTime.iso8601&gt;</td>  <td>java.util.Date</td></tr>
+ *   <tr><td>&lt;base64&gt;</td>            <td>byte[ ]</td></tr> 
+ * </table>
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @see org.apache.xmlrpc.TypeFactory
+ * @since 1.2
+ */
+public class DefaultTypeFactory
+    implements TypeFactory
+{
+    /**
+     * Thread-safe wrapper for the <code>DateFormat</code> object used
+     * to parse date/time values.
+     */
+    private static DateTool dateTool = new DateTool();
+    private static final Base64 base64Codec = new Base64();
+
+    /**
+     * Creates a new instance.
+     */
+    public DefaultTypeFactory()
+    {
+    }
+
+    public DefaultTypeFactory(TimeZone tz) {
+        dateTool.setTimeZone(tz);
+    }
+
+    public Object createInteger(String cdata)
+    {
+        return new Integer(cdata.trim());
+    }
+
+    public Object createBoolean(String cdata)
+    {
+        return ("1".equals(cdata.trim ())
+               ? Boolean.TRUE : Boolean.FALSE);
+    }
+
+    public Object createDouble(String cdata)
+    {
+        return new Double(cdata.trim ());
+
+    }
+
+    public Object createDate(String cdata)
+    {
+        try
+        {
+            return dateTool.parse(cdata.trim());
+        }
+        catch (ParseException p)
+        {
+            throw new RuntimeException(p.getMessage());
+        }
+    }
+
+    public Object createBase64(String cdata)
+    {
+        try
+        {
+            return base64Codec.decode((Object) cdata.getBytes());
+        }
+        catch (DecoderException e) {
+            //TODO: consider throwing an exception here?
+            return new byte[0];
+        }
+    }
+
+    public Object createString(String cdata)
+    {
+        return cdata;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/DefaultXmlRpcContext.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.xmlrpc;
+
+/**
+ * A basic context object that stores the userName, password and
+ * handler mapping.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: DefaultXmlRpcContext.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public class DefaultXmlRpcContext
+implements XmlRpcContext
+{
+    protected String userName, password;
+    protected XmlRpcHandlerMapping handlerMapping;
+
+    public DefaultXmlRpcContext(String userName, String password, XmlRpcHandlerMapping handlerMapping)
+    {
+        this.userName = userName;
+        this.password = password;
+        this.handlerMapping = handlerMapping;
+    }
+
+    public String getUserName()
+    {
+        return userName;
+    }
+
+    public String getPassword()
+    {
+        return password;
+    }
+
+    public XmlRpcHandlerMapping getHandlerMapping()
+    {
+        return handlerMapping;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/DefaultXmlRpcTransport.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.net.URLConnection;
+import org.apache.xmlrpc.util.HttpUtil;
+
+/**
+ * Interface from XML-RPC to the default HTTP transport based on the
+ * @see java.net.URLConnection class.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @author <a href="mailto:rhoegg@isisnetworks.net">Ryan Hoegg</a>
+ * @version $Id: DefaultXmlRpcTransport.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public class DefaultXmlRpcTransport implements XmlRpcTransport
+{
+    protected URL url;
+    protected String auth;
+    protected URLConnection con;
+
+    /**
+     * Create a new DefaultXmlRpcTransport with the specified URL and basic
+     * authorization string.
+     *
+     * @deprecated Use setBasicAuthentication instead of passing an encoded authentication String.
+     *
+     * @param url the url to POST XML-RPC requests to.
+     * @param auth the Base64 encoded HTTP Basic authentication value.
+     */
+    public DefaultXmlRpcTransport(URL url, String auth)
+    {
+        this.url = url;
+        this.auth = auth;
+    }
+
+    /**
+     * Create a new DefaultXmlRpcTransport with the specified URL.
+     *
+     * @param url the url to POST XML-RPC requests to.
+     */
+    public DefaultXmlRpcTransport(URL url)
+    {
+        this(url, null);
+    }
+
+    public InputStream sendXmlRpc(byte [] request)
+    throws IOException
+    {
+        con = url.openConnection();
+        con.setDoInput(true);
+        con.setDoOutput(true);
+        con.setUseCaches(false);
+        con.setAllowUserInteraction(false);
+        con.setRequestProperty("Content-Length",
+        Integer.toString(request.length));
+        con.setRequestProperty("Content-Type", "text/xml");
+        if (auth != null)
+        {
+            con.setRequestProperty("Authorization", "Basic " + auth);
+        }
+        OutputStream out = con.getOutputStream();
+        out.write(request);
+        out.flush();
+        out.close();
+        return con.getInputStream();
+    }
+
+    /**
+     * Sets Authentication for this client. This will be sent as Basic
+     * Authentication header to the server as described in
+     * <a href="http://www.ietf.org/rfc/rfc2617.txt">
+     * http://www.ietf.org/rfc/rfc2617.txt</a>.
+     */
+    public void setBasicAuthentication(String user, String password)
+    {
+        auth = HttpUtil.encodeBasicAuthentication(user, password);
+    }
+
+    public void endClientRequest()
+    throws XmlRpcClientException
+    {
+        try
+        {
+            con.getInputStream().close();
+        }
+        catch (Exception e)
+        {
+            throw new XmlRpcClientException("Exception closing URLConnection", e);
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/DefaultXmlRpcTransportFactory.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.net.URL;
+import java.util.Hashtable;
+import java.util.Properties;
+
+import org.apache.xmlrpc.util.HttpUtil;
+
+/**
+ * Default XML-RPC transport factory, produces HTTP, HTTPS with SSL or TLS based on URI protocol.
+ *
+ * @author <a href="mailto:lmeader@ghsinc.com">Larry Meader</a>
+ * @author <a href="mailto:cjackson@ghsinc.com">Chris Jackson</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: DefaultXmlRpcTransportFactory.java 332740 2005-11-12 09:03:34 +0100 (Sa, 12 Nov 2005) hgomez $
+ * @since 1.2
+ */
+public class DefaultXmlRpcTransportFactory implements XmlRpcTransportFactory 
+{
+    // Default properties for new http transports
+    protected URL url;
+    protected String auth;
+
+    protected XmlRpcTransportFactory httpsTransportFactory;
+
+    public static final String DEFAULT_HTTPS_PROVIDER = "comnetsun";
+
+    private static Hashtable transports = new Hashtable (1);
+
+    static
+    {
+        // A mapping of short identifiers to the fully qualified class names of
+        // common transport factories. If more mappings are added here,
+        // increase the size of the transports Hashtable used to store them.
+        transports.put("comnetsun", "org.apache.xmlrpc.secure.sunssl.SunSSLTransportFactory");
+    }
+
+    public void setHTTPSTransport(String transport, Properties properties)
+        throws XmlRpcClientException
+    {
+        httpsTransportFactory = createTransportFactory(transport, properties);    
+    }
+
+    public static XmlRpcTransportFactory createTransportFactory(String transport, Properties properties)
+        throws XmlRpcClientException
+    {
+        String transportFactoryClassName = null;
+        Class transportFactoryClass;
+        Constructor transportFactoryConstructor;
+        Object transportFactoryInstance;
+
+        try
+        {
+            transportFactoryClassName = (String) transports.get(transport);
+            if (transportFactoryClassName == null)
+            {
+                // Identifier lookup failed, assuming we were provided
+                // with the fully qualified class name.
+                transportFactoryClassName = transport;
+            }
+            transportFactoryClass = Class.forName(transportFactoryClassName);
+
+            transportFactoryConstructor = transportFactoryClass.getConstructor(
+                XmlRpcTransportFactory.CONSTRUCTOR_SIGNATURE);
+            transportFactoryInstance = transportFactoryConstructor.newInstance(
+                new Object [] { properties });
+            if (transportFactoryInstance instanceof XmlRpcTransportFactory)
+            {
+                return (XmlRpcTransportFactory) transportFactoryInstance;
+            }
+            else
+            {
+                throw new XmlRpcClientException("Class '" + 
+                    transportFactoryClass.getName() + "' does not implement '" +
+                    XmlRpcTransportFactory.class.getName() + "'", null);
+            }
+        }
+        catch (ClassNotFoundException cnfe)
+        {
+            throw new XmlRpcClientException("Transport Factory not found: " +
+                transportFactoryClassName, cnfe);
+        }
+        catch (NoSuchMethodException nsme)
+        {
+            throw new XmlRpcClientException("Transport Factory constructor not found: " +
+                transportFactoryClassName + 
+                XmlRpcTransportFactory.CONSTRUCTOR_SIGNATURE_STRING, nsme);
+        }
+        catch (IllegalAccessException iae)
+        {
+            throw new XmlRpcClientException("Unable to access Transport Factory constructor: " +
+                transportFactoryClassName, iae);
+        }
+        catch (InstantiationException ie)
+        {
+            throw new XmlRpcClientException("Unable to instantiate Transport Factory: " +
+                transportFactoryClassName, ie);
+        }
+        catch (InvocationTargetException ite)
+        {
+            throw new XmlRpcClientException("Error calling Transport Factory constructor: ",
+                ite.getTargetException());
+        }
+    }
+  
+    public DefaultXmlRpcTransportFactory(URL url)
+    {
+        this.url = url;
+    }
+    
+    /**
+     * Contructor taking a Base64 encoded Basic Authentication string.
+     *
+     * @deprecated use setBasicAuthentication method instead
+     */
+    public DefaultXmlRpcTransportFactory(URL url, String auth)
+    {
+        this(url);
+        this.auth = auth;
+    }
+    
+    public XmlRpcTransport createTransport() 
+    throws XmlRpcClientException
+    {
+        if ("https".equals(url.getProtocol()))
+        {
+            if (httpsTransportFactory == null)
+            {
+                Properties properties = new Properties();
+ 
+                properties.put(XmlRpcTransportFactory.TRANSPORT_URL, url);
+                properties.put(XmlRpcTransportFactory.TRANSPORT_AUTH, auth);
+ 
+                setHTTPSTransport(DEFAULT_HTTPS_PROVIDER, properties);
+            }
+  
+            return httpsTransportFactory.createTransport();
+        }
+        
+        return new DefaultXmlRpcTransport(url, auth);
+    }
+    
+    /**
+     * Sets Authentication for this client. This will be sent as Basic
+     * Authentication header to the server as described in
+     * <a href="http://www.ietf.org/rfc/rfc2617.txt">
+     * http://www.ietf.org/rfc/rfc2617.txt</a>.
+     */
+    public void setBasicAuthentication(String user, String password)
+    {
+        setProperty(TRANSPORT_AUTH, HttpUtil.encodeBasicAuthentication(user, password));
+    }
+
+    public void setProperty(String propertyName, Object value)
+    {
+        if (httpsTransportFactory != null)
+        {
+            httpsTransportFactory.setProperty(propertyName, value);
+        }
+        if (TRANSPORT_AUTH.equals(propertyName))
+        {
+            auth = (String) value;
+        }
+        else if (TRANSPORT_URL.equals(propertyName))
+        {
+            url = (URL) value;
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/Echo.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Vector;
+
+/**
+ * A simple handler which echos its input parameters.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @version $Id: Echo.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class Echo implements XmlRpcHandler
+{
+    /**
+     * Echos <code>parameters</code>.
+     *
+     * @param method Ignored.
+     * @param parameters Handler input parameters.
+     * @return The input parameters.
+     */
+    public Object execute(String method, Vector parameters)
+            throws Exception
+    {
+        return parameters;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/Invoker.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Vector;
+
+/**
+ * Introspects handlers using Java Reflection to call methods matching
+ * a XML-RPC call.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ */
+public class Invoker implements XmlRpcHandler
+{
+    private Object invokeTarget;
+    private Class targetClass;
+
+    public Invoker(Object target)
+    {
+        invokeTarget = target;
+        targetClass = (invokeTarget instanceof Class) ? (Class) invokeTarget :
+                invokeTarget.getClass();
+        if (XmlRpc.debug)
+        {
+            System.out.println("Target object is " + targetClass);
+        }
+    }
+
+    /**
+     * main method, sucht methode in object, wenn gefunden dann aufrufen.
+     */
+    public Object execute(String methodName, Vector params) throws Exception
+    {
+        // Array mit Classtype bilden, ObjectAry mit Values bilden
+        Class[] argClasses = null;
+        Object[] argValues = null;
+        if (params != null)
+        {
+            argClasses = new Class[params.size()];
+            argValues = new Object[params.size()];
+            for (int i = 0; i < params.size(); i++)
+            {
+                argValues[i] = params.elementAt(i);
+                if (argValues[i] instanceof Integer)
+                {
+                    argClasses[i] = Integer.TYPE;
+                }
+                else if (argValues[i] instanceof Double)
+                {
+                    argClasses[i] = Double.TYPE;
+                }
+                else if (argValues[i] instanceof Boolean)
+                {
+                    argClasses[i] = Boolean.TYPE;
+                }
+                else
+                {
+                    argClasses[i] = argValues[i].getClass();
+                }
+            }
+        }
+
+        // Methode da ?
+        Method method = null;
+
+        // The last element of the XML-RPC method name is the Java
+        // method name.
+        int dot = methodName.lastIndexOf('.');
+        if (dot > -1 && dot + 1 < methodName.length())
+        {
+            methodName = methodName.substring(dot + 1);
+        }
+
+        if (XmlRpc.debug)
+        {
+            System.out.println("Searching for method: " + methodName +
+                               " in class " + targetClass.getName());
+            for (int i = 0; i < argClasses.length; i++)
+            {
+                System.out.println("Parameter " + i + ": " + argValues[i]
+                        + " (" + argClasses[i] + ')');
+            }
+        }
+
+        try
+        {
+            method = targetClass.getMethod(methodName, argClasses);
+        }
+        // Wenn nicht da dann entsprechende Exception returnen
+        catch(NoSuchMethodException nsm_e)
+        {
+            throw nsm_e;
+        }
+        catch(SecurityException s_e)
+        {
+            throw s_e;
+        }
+
+        // Our policy is to make all public methods callable except
+        // the ones defined in java.lang.Object.
+        if (method.getDeclaringClass() == Object.class)
+        {
+            throw new XmlRpcException(0, "Invoker can't call methods "
+                    + "defined in java.lang.Object");
+        }
+
+        // invoke
+        Object returnValue = null;
+        try
+        {
+            returnValue = method.invoke(invokeTarget, argValues);
+        }
+        catch(IllegalAccessException iacc_e)
+        {
+            throw iacc_e;
+        }
+        catch(IllegalArgumentException iarg_e)
+        {
+            throw iarg_e;
+        }
+        catch(InvocationTargetException it_e)
+        {
+            if (XmlRpc.debug)
+            {
+                it_e.getTargetException().printStackTrace();
+            }
+            // check whether the thrown exception is XmlRpcException
+            Throwable t = it_e.getTargetException();
+            if (t instanceof XmlRpcException)
+            {
+                throw (XmlRpcException) t;
+            }
+            // It is some other exception
+            throw new Exception(t.toString());
+        }
+        if (returnValue == null && method.getReturnType() == Void.TYPE)
+        {
+            // Not supported by the spec.
+            throw new IllegalArgumentException
+                ("void return types for handler methods not supported");
+        }
+        return returnValue;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/LiteXmlRpcTransport.java
@@ -0,0 +1,331 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.ConnectException;
+import java.net.Socket;
+import java.net.URL;
+import java.util.StringTokenizer;
+
+import org.apache.xmlrpc.util.HttpUtil;
+
+/**
+ * Interface from XML-RPC to a 'lite' HTTP implementation.  This class will use
+ * the XmlRpcClientLite.auth member for the HTTP Basic authentication string.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: LiteXmlRpcTransport.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+class LiteXmlRpcTransport implements XmlRpcTransport
+{
+    String hostname;
+    String host;
+    protected String auth = null;
+    int port;
+    String uri;
+    Socket socket = null;
+    BufferedOutputStream output;
+    BufferedInputStream input;
+    boolean keepalive;
+    byte[] buffer;
+
+    /**
+     * Create a new DefaultXmlRpcTransport with the specified URL.
+     *
+     * @param url the url to POST XML-RPC requests to.
+     */
+    public LiteXmlRpcTransport(URL url)
+    {
+        hostname = url.getHost();
+        port = url.getPort();
+        if (port < 1)
+        {
+            port = 80;
+        }
+        uri = url.getFile();
+        if (uri == null || "".equals(uri))
+        {
+            uri = "/";
+        }
+        host = port == 80 ? hostname : hostname + ":" + port;        
+    }
+
+    public InputStream sendXmlRpc(byte [] request)
+    throws IOException
+    {
+        try
+        {
+            if (socket == null)
+            {
+        	initConnection();
+            }
+
+            InputStream in = null;
+
+           // send request to the server and get an input stream
+           // from which to read the response
+            try
+            {
+                in = sendRequest(request);
+            }
+            catch (IOException iox)
+            {
+                // if we get an exception while sending the request,
+                // and the connection is a keepalive connection, it may
+                // have been timed out by the server. Try again.
+                if (keepalive)
+                {
+                    closeConnection();
+                    initConnection();
+                    in = sendRequest(request);
+                }
+                else
+                {
+                    throw iox;
+                }
+            }
+
+            return in;
+        }
+        catch (IOException iox)
+        {
+            // this is a lower level problem,  client could not talk to
+            // server for some reason.
+            throw iox;
+        }
+        catch (Exception x)
+        {
+            // same as above, but exception has to be converted to
+            // IOException.
+            if (XmlRpc.debug)
+            {
+                x.printStackTrace ();
+            }
+
+            String msg = x.getMessage ();
+            if (msg == null || msg.length () == 0)
+            {
+                msg = x.toString ();
+            }
+            throw new IOException (msg);
+        }
+    }
+
+    /**
+     *
+     * @throws IOException
+     */
+    protected void initConnection() throws IOException
+    {
+        final int retries = 3;
+        final int delayMillis = 100;
+        
+        int tries = 0;
+        
+        socket = null;
+        while (socket == null) {
+            try {
+                socket = new Socket(hostname, port);
+            }
+            catch (ConnectException e) {
+                if (tries >= retries) {
+                    throw e;
+                } else {
+                    // log.debug("ConnectException: " + e.getMessage() + ", waiting " + new Integer(delayMillis).toString() + " milliseconds and retrying");
+                    try {
+                        Thread.sleep(delayMillis);
+                    }
+                    catch (InterruptedException ignore) {
+                    }
+                }
+            }
+        }
+        
+        output = new BufferedOutputStream(socket.getOutputStream());
+        input = new BufferedInputStream(socket.getInputStream());
+    }
+
+    /**
+     *
+     */
+    protected void closeConnection ()
+    {
+        try
+        {
+            socket.close();
+        }
+        catch (Exception ignore)
+        {
+        }
+        finally
+        {
+            socket = null;
+        }
+    }
+
+    /**
+     *
+     * @param request
+     * @return
+     * @throws IOException
+     */
+    public InputStream sendRequest(byte[] request) throws IOException
+    {
+        output.write(("POST " + uri + " HTTP/1.0\r\n").getBytes());
+        output.write(("User-Agent: " + XmlRpc.version + "\r\n").getBytes());
+        output.write(("Host: " + host + "\r\n").getBytes());
+        if (XmlRpc.getKeepAlive())
+        {
+            output.write("Connection: Keep-Alive\r\n".getBytes());
+        }
+        output.write("Content-Type: text/xml\r\n".getBytes());
+        if (auth != null)
+        {
+            output.write(("Authorization: Basic " + auth + "\r\n")
+                    .getBytes());
+        }
+        output.write(("Content-Length: " + request.length)
+                .getBytes());
+        output.write("\r\n\r\n".getBytes());
+        output.write(request);
+        output.flush();
+
+        // start reading  server response headers
+        String line = readLine();
+        if (XmlRpc.debug)
+        {
+            System.out.println(line);
+        }
+        int contentLength = -1;
+        try
+        {
+            StringTokenizer tokens = new StringTokenizer(line);
+            String httpversion = tokens.nextToken();
+            String statusCode = tokens.nextToken();
+            String statusMsg = tokens.nextToken("\n\r");
+            keepalive = XmlRpc.getKeepAlive()
+                    && "HTTP/1.1".equals(httpversion);
+            if (! "200".equals(statusCode))
+            {
+                throw new IOException("Unexpected Response from Server: "
+                        + statusMsg);
+            }
+        }
+        catch (IOException iox)
+        {
+            throw iox;
+        }
+        catch (Exception x)
+        {
+            // x.printStackTrace ();
+            throw new IOException("Server returned invalid Response.");
+        }
+        do
+        {
+            line = readLine ();
+            if (line != null)
+            {
+                if (XmlRpc.debug)
+                {
+                    System.out.println(line);
+                }
+                line = line.toLowerCase();
+                if (line.startsWith("content-length:"))
+                {
+                    contentLength = Integer.parseInt(
+                            line.substring(15).trim());
+                }
+                if (line.startsWith("connection:"))
+                {
+                    keepalive = XmlRpc.getKeepAlive()
+                            && line.indexOf("keep-alive") > -1;
+                }
+            }
+        }
+        while (line != null && ! line.equals(""))
+            ;
+        return new ServerInputStream(input, contentLength);
+    }
+
+    /**
+     * Sets Authentication for this client. This will be sent as Basic
+     * Authentication header to the server as described in
+     * <a href="http://www.ietf.org/rfc/rfc2617.txt">
+     * http://www.ietf.org/rfc/rfc2617.txt</a>.
+     */
+    public void setBasicAuthentication(String user, String password)
+    {
+        auth = HttpUtil.encodeBasicAuthentication(user, password);
+    }
+
+    public void endClientRequest()
+    {
+        // eepalive is always false if XmlRpc.keepalive is false
+        if (!keepalive)
+        {
+            closeConnection ();
+        }
+    }
+
+    /**
+     *
+     * @return
+     * @throws IOException
+     */
+    private String readLine() throws IOException
+    {
+        if (buffer == null)
+        {
+            buffer = new byte[2048];
+        }
+        int next;
+        int count = 0;
+        while (true)
+        {
+            next = input.read();
+            if (next < 0 || next == '\n')
+            {
+                break;
+            }
+            if (next != '\r')
+            {
+                buffer[count++] = (byte) next;
+            }
+            if (count >= buffer.length)
+            {
+                throw new IOException ("HTTP Header too long");
+            }
+        }
+        return new String(buffer, 0, count);
+    }
+
+    /**
+     *
+     * @throws Throwable
+     */
+    protected void finalize() throws Throwable
+    {
+        closeConnection ();
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/MultiCall.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Hashtable;
+import java.util.Vector;
+
+/**
+ * The <code>system.multicall</code> handler performs several RPC
+ * calls at a time.
+ *
+ * @author <a href="mailto:adam@megacz.com">Adam Megacz</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @author Daniel L. Rall
+ * @version $Id: MultiCall.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public class MultiCall
+implements ContextXmlRpcHandler
+{
+    public Object execute(String method, Vector params, XmlRpcContext context)
+            throws Exception
+    {
+        if ("multicall".equals(method))
+        {
+            return multicall(params, context);
+        }
+
+        throw new NoSuchMethodException("No method '" + method + "' in " + this.getClass().getName());
+    }
+
+    public Vector multicall(Vector requests, XmlRpcContext context)
+    {
+        // The array of calls is passed as a single parameter of type array.
+        requests=(Vector)requests.elementAt(0);
+        Vector response = new Vector();
+        XmlRpcServerRequest request;
+        for (int i = 0; i < requests.size(); i++)
+        {
+            try
+            {
+                Hashtable call = (Hashtable) requests.elementAt(i);
+                request = new XmlRpcRequest((String) call.get("methodName"),
+                                            (Vector) call.get("params"));
+                Object handler = context.getHandlerMapping().getHandler(request.getMethodName());
+                Vector v = new Vector();
+                v.addElement(XmlRpcWorker.invokeHandler(handler, request, context));
+                response.addElement(v);
+            }
+            catch (Exception x)
+            {
+                String message = x.toString();
+                int code = (x instanceof XmlRpcException ?
+                            ((XmlRpcException) x).code : 0);
+                Hashtable h = new Hashtable();
+                h.put("faultString", message);
+                h.put("faultCode", new Integer(code));
+                response.addElement(h);
+            }
+        }
+        return response;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/ParseFailed.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * Thrown as the result of an parse failure.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @see org.apache.xmlrpc.XmlRpcRequestProcessor
+ * @since 1.2
+ */
+public class ParseFailed extends RuntimeException
+{
+    protected Exception cause;
+
+    public ParseFailed(String message)
+    {
+        super(message);
+        this.cause = null;
+    }
+
+    public ParseFailed(Exception cause)
+    {
+        super(cause.getMessage());
+        this.cause = cause;
+    }
+
+    public Throwable getCause()
+    {
+        return cause;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/ServerInputStream.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.BufferedInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+
+/**
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @version $Id: ServerInputStream.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+class ServerInputStream extends InputStream
+{
+    // bytes remaining to be read from the input stream. This is
+    // initialized from CONTENT_LENGTH (or getContentLength()).
+    // This is used in order to correctly return a -1 when all the
+    // data POSTed was read. If this is left to -1, content length is
+    // assumed as unknown and the standard InputStream methods will be used
+    private long available = -1;
+    private long markedAvailable;
+
+    private BufferedInputStream in;
+
+    /**
+     *
+     * @param in
+     * @param available
+     */
+    public ServerInputStream(BufferedInputStream in, int available)
+    {
+        this.in = in;
+        this.available = available;
+    }
+
+    /**
+     *
+     * @return
+     * @throws IOException
+     */
+    public int read() throws IOException
+    {
+        if (available > 0)
+        {
+            available--;
+            return in.read();
+        }
+        else if (available == -1)
+        {
+            return in.read ();
+        }
+        return -1;
+    }
+
+    /**
+     *
+     * @param b
+     * @return
+     * @throws IOException
+     */
+    public int read(byte b[]) throws IOException
+    {
+        return read(b, 0, b.length);
+    }
+
+    /**
+     *
+     * @param b
+     * @param off
+     * @param len
+     * @return
+     * @throws IOException
+     */
+    public int read(byte b[], int off, int len) throws IOException
+    {
+        if (available > 0)
+        {
+            if (len > available)
+            {
+                // shrink len
+                len = (int) available;
+            }
+            int read = in.read(b, off, len);
+            if (read != -1)
+            {
+                available -= read;
+            }
+            else
+            {
+                available = -1;
+            }
+            return read;
+        }
+        else if (available == -1)
+        {
+            return in.read(b, off, len);
+        }
+        return -1;
+    }
+
+    /**
+     *
+     * @param n
+     * @return
+     * @throws IOException
+     */
+    public long skip(long n) throws IOException
+    {
+        long skip = in.skip(n);
+        if (available > 0)
+        {
+            available -= skip;
+        }
+        return skip;
+    }
+
+    /**
+     *
+     * @param readlimit
+     */
+    public void mark(int readlimit)
+    {
+        in.mark(readlimit);
+        markedAvailable = available;
+    }
+
+    /**
+     *
+     * @throws IOException
+     */
+    public void reset() throws IOException
+    {
+        in.reset();
+        available = markedAvailable;
+    }
+
+    /**
+     *
+     * @return
+     */
+    public boolean markSupported()
+    {
+        return true;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/SystemHandler.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Vector;
+
+/**
+ * Wraps calls to the XML-RPC standard system.* methods (such as
+ * <code>system.multicall</code>).
+ *
+ * @author <a href="mailto:adam@megacz.com">Adam Megacz</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @author Daniel L. Rall
+ * @since 1.2
+ */
+public class SystemHandler
+implements ContextXmlRpcHandler
+{
+    private DefaultHandlerMapping systemMapping = null;
+
+    /**
+     * Creates a new instance. This instance contains no system calls. Use the
+     * addDefaultSystemHandlers() method to add the 'default' set of handlers,
+     * or add handlers manually.
+     */
+    public SystemHandler()
+    {
+        this.systemMapping = new DefaultHandlerMapping();
+    }
+
+   /**
+     * Creates a new instance that delegates calls via the
+     * specified {@link org.apache.xmlrpc.XmlRpcHandlerMapping}. This
+     * method will add the system.multicall handler when a non-null
+     * handlerMapping is specified. The value itself is ignored.
+     *
+     * @deprecated use new SystemHandler() and addDefaultSystemHandlers() instead.
+     */
+    public SystemHandler(XmlRpcHandlerMapping handlerMapping)
+    {
+        this();
+        if (handlerMapping != null)
+        {
+          addDefaultSystemHandlers();
+        }
+    }
+
+    /**
+     * Creates a new instance that delegates its multicalls via
+     * the mapping used by the specified {@link org.apache.xmlrpc.XmlRpcServer}.
+     * This method will add the default handlers when the specfied server's
+     * getHandlerMapping() returns a non-null handler mapping.
+     *
+     * @param server The server to retrieve the XmlRpcHandlerMapping from.
+     *
+     * @deprecated use new SystemHandler() and addDefaultSystemHandlers() instead.
+     */
+    protected SystemHandler(XmlRpcServer server)
+    {
+        this(server.getHandlerMapping());
+    }
+
+    /**
+     * Add the default system handlers. The default system handlers are:
+     * <dl>
+     *  <dt>system.multicall</dt>
+     *  <dd>Make multiple XML-RPC calls in one request and receive multiple
+     *  responses.</dd>
+     * </dl>
+     */
+    public void addDefaultSystemHandlers()
+    {
+        addSystemHandler("multicall", new MultiCall());
+    }
+
+    /**
+     * @see org.apache.xmlrpc.DefaultHandlerMapping#addHandler(String, Object)
+     */
+    public void addSystemHandler(String handlerName, ContextXmlRpcHandler handler)
+    {
+        systemMapping.addHandler(handlerName, handler);
+    }
+
+    /**
+     * @see org.apache.xmlrpc.DefaultHandlerMapping#removeHandler(String)
+     */
+    public void removeSystemHandler(String handlerName)
+    {
+        systemMapping.removeHandler(handlerName);
+    }
+
+    /**
+     * Execute a &lt;ignored&gt;.&lt;name&gt; call by calling the handler for
+     * &lt;name&gt; in the the system handler mapping.
+     */
+    public Object execute(String method, Vector params, XmlRpcContext context)
+            throws Exception
+    {
+        Object handler = null;
+        String systemMethod = null;
+        int dot = method.lastIndexOf('.');
+        if (dot > -1)
+        {
+            // The last portion of the XML-RPC method name is the systen
+	    // method name. 
+	    systemMethod = method.substring(dot + 1);
+
+            // Add the "." in at the end, the systemMapping will strip it off
+            handler = systemMapping.getHandler(systemMethod + ".");
+            if (handler != null)
+            {
+                return ((ContextXmlRpcHandler) handler).execute(systemMethod, params, context);
+            }
+        }
+
+        throw new NoSuchMethodException("No method '" + method + "' registered.");
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/TypeDecoder.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * Allows developers to customize the types translated to the XML-RPC
+ * &lt;i4&gt; and &lt;double&gt .
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @see org.apache.xmlrpc.DefaultTypeDecoder
+ * @since 1.2
+ */
+public interface TypeDecoder
+{
+    /**
+     * Test if a local object translates to an &lt;i4&gt; tag.
+     */
+    public boolean isXmlRpcI4(Object o);
+
+    /**
+     * Test if a local object translates to a &lt;double&gt; tag.
+     */
+    public boolean isXmlRpcDouble(Object o);
+}
--- /dev/null
+++ b/org/apache/xmlrpc/TypeFactory.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * Allows server developers to customize the type of Java objects
+ * created for a corresponding XML-RPC type.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @see org.apache.xmlrpc.DefaultTypeFactory
+ * @since 1.2
+ */
+public interface TypeFactory
+{
+    /**
+     * Create a local object for an &lt;int&gt; or &lt;i4&gt; tag.
+     */
+    public Object createInteger(String s);
+
+    /**
+     * Create a local object for a &lt;boolean&gt; tag.
+     */
+    public Object createBoolean(String s);
+
+    /**
+     * Create a local object for a &lt;double&gt; tag.
+     */
+    public Object createDouble(String s);
+
+    /**
+     * Create a local object for a &lt;dateTime.iso8601&gt; tag.
+     */
+    public Object createDate(String s);
+
+    /**
+     * Create a local object for a &lt;base64&gt; tag.
+     */
+    public Object createBase64(String s);
+
+    /**
+     * Create a local object for a &lt;string&gt; tag.
+     */
+    public Object createString(String s);
+}
--- /dev/null
+++ b/org/apache/xmlrpc/WebServer.java
@@ -0,0 +1,954 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.io.UnsupportedEncodingException;
+import java.net.BindException;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.EmptyStackException;
+import java.util.Stack;
+import java.util.StringTokenizer;
+import java.util.Vector;
+import org.apache.commons.codec.binary.Base64;
+
+/**
+ * A minimal web server that exclusively handles XML-RPC requests.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
+ * @author Daniel L. Rall
+ */
+public class WebServer implements Runnable
+{
+    protected XmlRpcServer xmlrpc;
+
+    protected ServerSocket serverSocket;
+    protected Thread listener;
+    protected Vector accept, deny;
+    protected Stack threadpool;
+    protected ThreadGroup runners;
+
+    // Inputs to setupServerSocket()
+    private InetAddress address;
+    private int port;
+
+    private boolean paranoid;
+
+    protected static final byte[] ctype =
+        toHTTPBytes("Content-Type: text/xml\r\n");
+    protected static final byte[] clength =
+        toHTTPBytes("Content-Length: ");
+    protected static final byte[] newline = toHTTPBytes("\r\n");
+    protected static final byte[] doubleNewline = toHTTPBytes("\r\n\r\n");
+    protected static final byte[] conkeep =
+        toHTTPBytes("Connection: Keep-Alive\r\n");
+    protected static final byte[] conclose =
+        toHTTPBytes("Connection: close\r\n");
+    protected static final byte[] ok = toHTTPBytes(" 200 OK\r\n");
+    protected static final byte[] server =
+        toHTTPBytes("Server: Apache XML-RPC 1.0\r\n");
+    protected static final byte[] wwwAuthenticate =
+        toHTTPBytes("WWW-Authenticate: Basic realm=XML-RPC\r\n");
+
+    private static final String HTTP_11 = "HTTP/1.1";
+    private static final String STAR = "*";
+
+    /**
+     * This <em>can</em> be called from command line, but you'll have to edit
+     * and recompile to change the server port or handler objects. By default,
+     * it sets up the following responders:
+     * <ul>
+     *   <li> A java.lang.String object </li>
+     *   <li> The java.lang.Math class (making its static methods callable via
+     *        XML-RPC) </li>
+     *   <li> An Echo handler that returns the argument array </li>
+     * </ul>
+     *
+     * @see #addDefaultHandlers()
+     */
+    public static void main(String[] argv)
+    {
+        int p = determinePort(argv, 8080);
+        // XmlRpc.setDebug (true);
+        XmlRpc.setKeepAlive(true);
+        WebServer webserver = new WebServer(p);
+
+        try
+        {
+            webserver.addDefaultHandlers();
+            webserver.start();
+        }
+        catch (Exception e)
+        {
+            System.err.println("Error running web server");
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+
+    /**
+     * Examines command line arguments from <code>argv</code>.  If a
+     * port may have been provided, parses that port (exiting with
+     * error status if the port cannot be parsed).  If no port is
+     * specified, defaults to <code>defaultPort</code>.
+     *
+     * @param defaultPort The port to use if none was specified.
+     */
+    protected static int determinePort(String[] argv, int defaultPort)
+    {
+        int port = defaultPort;
+        if (argv.length > 0)
+        {
+            try
+            {
+                port = Integer.parseInt(argv[0]);
+            }
+            catch (NumberFormatException nfx)
+            {
+                System.err.println("Error parsing port number: " + argv[0]);
+                System.err.println("Usage: java " + WebServer.class.getName()
+                                   + " [port]");
+                System.exit(1);
+            }
+        }
+        return port;
+    }
+
+    /**
+     * Creates a web server at the specified port number.
+     */
+    public WebServer(int port)
+    {
+        this(port, null);
+    }
+
+    /**
+     * Creates a web server at the specified port number and IP address.
+     */
+    public WebServer(int port, InetAddress addr)
+    {
+        this(port, addr, new XmlRpcServer());
+    }
+
+    /**
+     * Creates a web server at the specified port number and IP
+     * address.
+     */
+    public WebServer(int port, InetAddress addr, XmlRpcServer xmlrpc)
+    {
+        this.address = addr;
+        this.port = port;
+        this.xmlrpc = xmlrpc;
+        accept = new Vector();
+        deny = new Vector();
+        threadpool = new Stack();
+        runners = new ThreadGroup("XML-RPC Runner");
+    }
+
+    /**
+     * Returns the US-ASCII encoded byte representation of text for
+     * HTTP use (as per section 2.2 of RFC 2068).
+     */
+    protected static final byte[] toHTTPBytes(String text)
+    {
+        try
+        {
+            return text.getBytes("US-ASCII");
+        }
+        catch (UnsupportedEncodingException e)
+        {
+            throw new Error(e.getMessage() +
+                            ": HTTP requires US-ASCII encoding");
+        }
+    }
+
+    /**
+     * Factory method to manufacture the server socket.  Useful as a
+     * hook method for subclasses to override when they desire
+     * different flavor of socket (i.e. a <code>SSLServerSocket</code>).
+     *
+     * @param port
+     * @param backlog
+     * @param addr If <code>null</code>, binds to
+     * <code>INADDR_ANY</code>, meaning that all network interfaces on
+     * a multi-homed host will be listening.
+     * @exception Exception Error creating listener socket.
+     */
+    protected ServerSocket createServerSocket(int port, int backlog,
+            InetAddress addr)
+            throws Exception
+    {
+        return new ServerSocket(port, backlog, addr);
+    }
+
+    /**
+     * Initializes this server's listener socket with the specified
+     * attributes, assuring that a socket timeout has been set.  The
+     * {@link #createServerSocket(int, int, InetAddress)} method can
+     * be overridden to change the flavor of socket used.
+     *
+     * @see #createServerSocket(int, int, InetAddress)
+     */
+    private synchronized void setupServerSocket(int backlog)
+            throws Exception
+    {
+        // Since we can't reliably set SO_REUSEADDR until JDK 1.4 is
+        // the standard, try to (re-)open the server socket several
+        // times.  Some OSes (Linux and Solaris, for example), hold on
+        // to listener sockets for a brief period of time for security
+        // reasons before relinquishing their hold.
+        int attempt = 1;
+        while (serverSocket == null)
+        {
+            try
+            {
+                serverSocket = createServerSocket(port, backlog, address);
+            }
+            catch (BindException e)
+            {
+                if (attempt == 10)
+                {
+                    throw e;
+                }
+
+                attempt++;
+                Thread.sleep(1000);
+            }
+        }
+
+        if (XmlRpc.debug)
+        {
+            StringBuffer msg = new StringBuffer();
+            msg.append("Opened XML-RPC server socket for ");
+            msg.append(address != null ? address.getHostName() : "localhost");
+            msg.append(':').append(port);
+            if (attempt > 1)
+            {
+                msg.append(" after ").append(attempt).append(" tries");
+            }
+            System.out.println(msg.toString());
+        }
+
+        // A socket timeout must be set.
+        if (serverSocket.getSoTimeout() <= 0)
+        {
+            serverSocket.setSoTimeout(4096);
+        }
+    }
+
+    /**
+     * Spawns a new thread which binds this server to the port it's
+     * configured to accept connections on.
+     *
+     * @see #run()
+     */
+    public void start()
+    {
+        try
+        {
+            setupServerSocket(50);
+        }
+        catch (Exception e)
+        {
+            listener = null;
+            e.printStackTrace();
+            throw new RuntimeException(e.getMessage());
+        }
+
+        // The listener reference is released upon shutdown().
+        if (listener == null)
+        {
+            listener = new Thread(this, "XML-RPC Weblistener");
+            // Not marked as daemon thread since run directly via main().
+            listener.start();
+        }
+    }
+
+    /**
+     * Register a handler object with this name. Methods of this objects will be
+     * callable over XML-RPC as "name.method".
+     */
+    public void addHandler(String name, Object target)
+    {
+        xmlrpc.addHandler(name, target);
+    }
+
+    /**
+     * Adds the bundled handlers to the server.  Called by {@link
+     * #main(String[])}.
+     */
+    protected void addDefaultHandlers()
+        throws Exception
+    {
+        // webserver.setParanoid (true);
+        // webserver.acceptClient ("192.168.*.*");
+        addHandler("string", "Welcome to XML-RPC!");
+        addHandler("math", Math.class);
+        addHandler("auth", new AuthDemo());
+        addHandler("$default", new Echo());
+        // XmlRpcClients can be used as Proxies in XmlRpcServers which is a
+        // cool feature for applets.
+        String url = "http://www.mailtothefuture.com:80/RPC2";
+        addHandler("mttf", new XmlRpcClient(url));
+        SystemHandler system = new SystemHandler();
+        system.addDefaultSystemHandlers();
+        addHandler("system", system);
+    }
+
+    /**
+     * Remove a handler object that was previously registered with this server.
+     */
+    public void removeHandler(String name)
+    {
+        xmlrpc.removeHandler(name);
+    }
+
+    /**
+     * Switch client filtering on/off.
+     * @see #acceptClient(java.lang.String)
+     * @see #denyClient(java.lang.String)
+     */
+    public void setParanoid(boolean p)
+    {
+        paranoid = p;
+    }
+
+    /**
+     * Add an IP address to the list of accepted clients. The parameter can
+     * contain '*' as wildcard character, e.g. "192.168.*.*". You must call
+     * setParanoid(true) in order for this to have any effect.
+     *
+     * @see #denyClient(java.lang.String)
+     * @see #setParanoid(boolean)
+     */
+    public void acceptClient(String address) throws IllegalArgumentException
+    {
+        try
+        {
+            AddressMatcher m = new AddressMatcher(address);
+            accept.addElement(m);
+        }
+        catch (Exception x)
+        {
+            throw new IllegalArgumentException("\"" + address
+                    + "\" does not represent a valid IP address");
+        }
+    }
+
+    /**
+     * Add an IP address to the list of denied clients. The parameter can
+     * contain '*' as wildcard character, e.g. "192.168.*.*". You must call
+     * setParanoid(true) in order for this to have any effect.
+     *
+     * @see #acceptClient(java.lang.String)
+     * @see #setParanoid(boolean)
+     */
+    public void denyClient(String address) throws IllegalArgumentException
+    {
+        try
+        {
+            AddressMatcher m = new AddressMatcher(address);
+            deny.addElement(m);
+        }
+        catch (Exception x)
+        {
+            throw new IllegalArgumentException("\"" + address
+                    + "\" does not represent a valid IP address");
+        }
+    }
+
+    /**
+     * Checks incoming connections to see if they should be allowed.
+     * If not in paranoid mode, always returns true.
+     *
+     * @param s The socket to inspect.
+     * @return Whether the connection should be allowed.
+     */
+    protected boolean allowConnection(Socket s)
+    {
+        if (!paranoid)
+        {
+            return true;
+        }
+
+        int l = deny.size();
+        byte address[] = s.getInetAddress().getAddress();
+        for (int i = 0; i < l; i++)
+        {
+            AddressMatcher match = (AddressMatcher)deny.elementAt(i);
+            if (match.matches(address))
+            {
+                return false;
+            }
+        }
+        l = accept.size();
+        for (int i = 0; i < l; i++)
+        {
+            AddressMatcher match = (AddressMatcher)accept.elementAt(i);
+            if (match.matches(address))
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * DEPRECATED: Do not use this method, it will be removed soon.
+     * Use {@link #allowConnection(Socket)} instead.
+     *
+     * @deprecated Use allowConnection(Socket) instead.
+     * @see #allowConnection(Socket)
+     */
+    protected boolean checkSocket(Socket s)
+    {
+        return allowConnection(s);
+    }
+
+    /**
+     * Listens for client requests until stopped.  Call {@link
+     * #start()} to invoke this method, and {@link #shutdown()} to
+     * break out of it.
+     *
+     * @throws RuntimeException Generally caused by either an
+     * <code>UnknownHostException</code> or <code>BindException</code>
+     * with the vanilla web server.
+     *
+     * @see #start()
+     * @see #shutdown()
+     */
+    public void run()
+    {
+        try
+        {
+            while (listener != null)
+            {
+                Socket socket = null;
+                Runner runner = null;
+                
+                try
+                {
+                    socket = serverSocket.accept();
+                    try
+                    {
+                        socket.setTcpNoDelay(true);
+                    }
+                    catch (SocketException socketOptEx)
+                    {
+                        System.err.println(socketOptEx);
+                    }
+
+                    if (allowConnection(socket))
+                    {
+                        runner = getRunner();
+                        runner.handle(socket);
+                    }
+                    else
+                    {
+                        socket.close();
+                    }
+                }
+                catch (InterruptedIOException checkState)
+                {
+                    // Timeout while waiting for a client (from
+                    // SO_TIMEOUT)...try again if still listening.
+                }
+                catch (Exception ex)
+                {
+                    System.err.println("Exception in XML-RPC listener loop ("
+                            + ex + ").");
+                    if (XmlRpc.debug)
+                    {
+                        ex.printStackTrace();
+                    }
+                }
+                catch (Error err)
+                {
+                    System.err.println("Error in XML-RPC listener loop ("
+                            + err + ").");
+                    err.printStackTrace();
+                }
+                finally
+                {
+                    if (runner == null && socket != null)
+                    {
+	                    try
+	                    {
+	                        socket.close();
+	                    }
+	                    catch (Throwable e)
+	                    {
+	                    }
+                    }
+               }
+            }
+        }
+        catch (Exception exception)
+        {
+            System.err.println("Error accepting XML-RPC connections ("
+                    + exception + ").");
+            if (XmlRpc.debug)
+            {
+                exception.printStackTrace();
+            }
+        }
+        finally
+        {
+            if (serverSocket != null)
+            {
+                try
+                {
+                    serverSocket.close();
+                    if (XmlRpc.debug)
+                    {
+                        System.out.print("Closed XML-RPC server socket");
+                    }
+                    serverSocket = null;
+                }
+                catch (IOException e)
+                {
+                    e.printStackTrace();
+                }
+            }
+
+            // Shutdown our Runner-based threads
+            if (runners != null)
+            {
+                ThreadGroup g = runners;
+                runners = null;
+                try
+                {
+                    g.interrupt();
+                }
+                catch (Exception e)
+                {
+                    System.err.println(e);
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    /**
+     * Stop listening on the server port.  Shutting down our {@link
+     * #listener} effectively breaks it out of its {@link #run()}
+     * loop.
+     *
+     * @see #run()
+     */
+    public synchronized void shutdown()
+    {
+        // Stop accepting client connections
+        if (listener != null)
+        {
+            Thread l = listener;
+            listener = null;
+            l.interrupt();
+        }
+    }
+
+    /**
+     *
+     * @return
+     */
+    protected Runner getRunner()
+    {
+        try
+        {
+            return (Runner)threadpool.pop();
+        }
+        catch (EmptyStackException empty)
+        {
+            int maxRequests = XmlRpc.getMaxThreads();
+            if (runners.activeCount() > XmlRpc.getMaxThreads())
+            {
+                throw new RuntimeException("System overload: Maximum number " +
+                                           "of concurrent requests (" +
+                                           maxRequests + ") exceeded");
+            }
+            return new Runner();
+        }
+    }
+
+    /**
+     * Put <code>runner</code> back into {@link #threadpool}.
+     *
+     * @param runner The instance to reclaim.
+     */
+    void repoolRunner(Runner runner)
+    {
+        threadpool.push(runner);
+    }
+
+    /**
+     * Responsible for handling client connections.
+     */
+    class Runner implements Runnable
+    {
+        Thread thread;
+        Connection con;
+        int count;
+
+        /**
+         * Handles the client connection on <code>socket</code>.
+         *
+         * @param socket The source to read the client's request from.
+         */
+        public synchronized void handle(Socket socket) throws IOException
+        {
+            con = new Connection(socket);
+            count = 0;
+            if (thread == null || !thread.isAlive())
+            {
+                thread = new Thread(runners, this);
+                thread.start();
+            }
+            else
+            {
+                // Wake the thread waiting in our run() method.
+                this.notify();
+            }
+        }
+
+        /**
+         * Delegates to <code>con.run()</code>.
+         */
+        public void run()
+        {
+            while (con != null && Thread.currentThread() == thread)
+            {
+                con.run();
+                count++;
+                con = null;
+
+                if (count > 200 || threadpool.size() > 20)
+                {
+                    // We're old, or the number of threads in the pool
+                    // is large.
+                    return;
+                }
+                synchronized(this)
+                {
+                    repoolRunner(this);
+                    try
+                    {
+                        this.wait();
+                    }
+                    catch (InterruptedException ir)
+                    {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     *
+     */
+    class Connection implements Runnable
+    {
+        private Socket socket;
+        private BufferedInputStream input;
+        private BufferedOutputStream output;
+        private String user, password;
+        byte[] buffer;
+
+        /**
+         *
+         * @param socket
+         * @throws IOException
+         */
+        public Connection (Socket socket) throws IOException
+        {
+            // set read timeout to 30 seconds
+            socket.setSoTimeout (30000);
+
+            this.socket = socket;
+            input = new BufferedInputStream(socket.getInputStream());
+            output = new BufferedOutputStream(socket.getOutputStream());
+        }
+
+        /**
+         *
+         */
+        public void run()
+        {
+            try
+            {
+                boolean keepAlive = false;
+
+                do
+                {
+                    // reset user authentication
+                    user = null;
+                    password = null;
+                    String line = readLine();
+                    // Netscape sends an extra \n\r after bodypart, swallow it
+                    if (line != null && line.length() == 0)
+                    {
+                        line = readLine();
+                    }
+                    if (XmlRpc.debug)
+                    {
+                        System.out.println(line);
+                    }
+                    int contentLength = -1;
+
+                    // tokenize first line of HTTP request
+                    StringTokenizer tokens = new StringTokenizer(line);
+                    String method = tokens.nextToken();
+                    String uri = tokens.nextToken();
+                    String httpVersion = tokens.nextToken();
+                    keepAlive = XmlRpc.getKeepAlive()
+                            && HTTP_11.equals(httpVersion);
+                    do
+                    {
+                        line = readLine();
+                        if (line != null)
+                        {
+                            if (XmlRpc.debug)
+                            {
+                                System.out.println(line);
+                            }
+                            String lineLower = line.toLowerCase();
+                            if (lineLower.startsWith("content-length:"))
+                            {
+                                contentLength = Integer.parseInt(
+                                        line.substring(15).trim());
+                            }
+                            if (lineLower.startsWith("connection:"))
+                            {
+                                keepAlive = XmlRpc.getKeepAlive() &&
+                                        lineLower.indexOf("keep-alive") > -1;
+                            }
+                            if (lineLower.startsWith("authorization: basic "))
+                            {
+                                parseAuth (line);
+                            }
+                        }
+                    }
+                    while (line != null && line.length() != 0);
+
+                    if ("POST".equalsIgnoreCase(method))
+                    {
+                        ServerInputStream sin = new ServerInputStream(input,
+                                contentLength);
+                        try
+                        {
+                            byte[] result = xmlrpc.execute(sin, user, password);
+                            writeResponse(result, httpVersion, keepAlive);
+                        }
+                        catch (AuthenticationFailed unauthorized)
+                        {
+                            keepAlive = false;
+                            writeUnauthorized(httpVersion, method);
+                        }
+                    }
+                    else
+                    {
+                        keepAlive = false;
+                        writeBadRequest(httpVersion, method);
+                    }
+                    output.flush();
+                }
+                while (keepAlive);
+            }
+            catch (Exception exception)
+            {
+                if (XmlRpc.debug)
+                {
+                    exception.printStackTrace();
+                }
+                else
+                {
+                    System.err.println(exception);
+                }
+            }
+            finally
+            {
+                try
+                {
+                    if (socket != null)
+                    {
+                        socket.close();
+                    }
+                }
+                catch (IOException ignore)
+                {
+                }
+            }
+        }
+
+        /**
+         *
+         * @return
+         * @throws IOException
+         */
+        private String readLine() throws IOException
+        {
+            if (buffer == null)
+            {
+                buffer = new byte[2048];
+            }
+            int next;
+            int count = 0;
+            for (;;)
+            {
+                next = input.read();
+                if (next < 0 || next == '\n')
+                {
+                    break;
+                }
+                if (next != '\r')
+                {
+                    buffer[count++] = (byte) next;
+                }
+                if (count >= buffer.length)
+                {
+                    throw new IOException("HTTP Header too long");
+                }
+            }
+            return new String(buffer, 0, count);
+        }
+
+        /**
+         *
+         * @param line
+         */
+        private synchronized void parseAuth(String line)
+        {
+            try
+            {
+            	Base64 base64Codec = new Base64();
+                byte[] c = base64Codec.decode(toHTTPBytes(line.substring(21)));
+                String str = new String(c);
+                int col = str.indexOf(':');
+                user = str.substring(0, col);
+                password = str.substring(col + 1);
+            }
+            catch (Throwable ignore)
+            {
+            }
+        }
+
+        private void writeResponse(byte[] payload, String httpVersion,
+                                   boolean keepAlive)
+            throws IOException
+        {
+            output.write(toHTTPBytes(httpVersion));
+            output.write(ok);
+            output.write(server);
+            output.write(keepAlive ? conkeep : conclose);
+            output.write(ctype);
+            output.write(clength);
+            output.write(toHTTPBytes(Integer.toString(payload.length)));
+            output.write(doubleNewline);
+            output.write(payload);
+        }
+
+        private void writeBadRequest(String httpVersion, String httpMethod)
+            throws IOException
+        {
+            output.write(toHTTPBytes(httpVersion));
+            output.write(toHTTPBytes(" 400 Bad Request"));
+            output.write(newline);
+            output.write(server);
+            output.write(newline);
+            output.write(toHTTPBytes("Method " + httpMethod +
+                                     " not implemented (try POST)"));
+        }
+
+        private void writeUnauthorized(String httpVersion, String httpMethod)
+            throws IOException
+        {
+            output.write(toHTTPBytes(httpVersion));
+            output.write(toHTTPBytes(" 401 Unauthorized"));
+            output.write(newline);
+            output.write(server);
+            output.write(wwwAuthenticate);
+            output.write(newline);
+            output.write(toHTTPBytes("Method " + httpMethod + " requires a " +
+                                     "valid user name and password"));
+        }
+    }
+
+    /**
+     *
+     */
+    class AddressMatcher
+    {
+        int pattern[];
+
+        /**
+         *
+         * @param address
+         * @throws Exception
+         */
+        public AddressMatcher(String address) throws Exception
+        {
+            pattern = new int[4];
+            StringTokenizer st = new StringTokenizer(address, ".");
+            if (st.countTokens() != 4)
+            {
+                throw new Exception("\"" + address
+                        + "\" does not represent a valid IP address");
+            }
+            for (int i = 0; i < 4; i++)
+            {
+                String next = st.nextToken();
+                if (STAR.equals(next))
+                {
+                    pattern[i] = 256;
+                }
+                else
+                {
+                    pattern[i] = (byte) Integer.parseInt(next);
+                }
+            }
+        }
+
+        /**
+         *
+         * @param address
+         * @return
+         */
+        public boolean matches (byte address[])
+        {
+            for (int i = 0; i < 4; i++)
+            {
+                if (pattern[i] > 255)// wildcard
+                {
+                    continue;
+                }
+                if (pattern[i] != address[i])
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpc.java
@@ -0,0 +1,789 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import org.xml.sax.*;
+import uk.co.wilson.xml.MinML;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.Hashtable;
+import java.util.Stack;
+import java.util.TimeZone;
+import java.util.Vector;
+
+/**
+ * This abstract base class provides basic capabilities for XML-RPC,
+ * like parsing of parameters or encoding Java objects into XML-RPC
+ * format.  Any XML parser with a <a
+ * href="http://www.megginson.com/SAX/">SAX</a> interface can be used.
+ *
+ * <p>XmlRpcServer and XmlRpcClient are the classes that actually
+ * implement an XML-RPC server and client.
+ *
+ * @see org.apache.xmlrpc.XmlRpcServer
+ * @see org.apache.xmlrpc.XmlRpcClient
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpc.java 350048 2005-11-30 21:49:32 +0100 (Mi, 30 Nov 2005) jochen $
+ */
+public abstract class XmlRpc extends HandlerBase
+{
+    /**
+     * The version string used in HTTP communication.
+     */
+    // FIXME: Use Ant <filter> to pre-process version number into a
+    // class-loaded .properties file at build time.  Use here when
+    // available, and otherwise provide no version string.
+    public static final String version = "Apache XML-RPC 2.0";
+
+    /**
+     * The default parser to use (MinML).
+     */
+    private static final String DEFAULT_PARSER = MinML.class.getName();
+
+    /**
+     * The maximum number of threads which can be used concurrently.
+     */
+    private static int maxThreads = 100;
+
+    String methodName;
+
+    /**
+     * The class name of SAX parser to use.
+     */
+    private static Class parserClass;
+    private static Hashtable saxDrivers = new Hashtable (8);
+
+    static
+    {
+        // A mapping of short identifiers to the fully qualified class
+        // names of common SAX parsers.  If more mappings are added
+        // here, increase the size of the saxDrivers Map used to store
+        // them.
+        saxDrivers.put("xerces", "org.apache.xerces.parsers.SAXParser");
+        saxDrivers.put("xp", "com.jclark.xml.sax.Driver");
+        saxDrivers.put("ibm1", "com.ibm.xml.parser.SAXDriver");
+        saxDrivers.put("ibm2", "com.ibm.xml.parsers.SAXParser");
+        saxDrivers.put("aelfred", "com.microstar.xml.SAXDriver");
+        saxDrivers.put("oracle1", "oracle.xml.parser.XMLParser");
+        saxDrivers.put("oracle2", "oracle.xml.parser.v2.SAXParser");
+        saxDrivers.put("openxml", "org.openxml.parser.XMLSAXParser");
+    }
+
+    // the stack we're parsing our values into.
+    Stack values;
+    Value currentValue;
+
+    /**
+     * Used to collect character data (<code>CDATA</code>) of
+     * parameter values.
+     */
+    StringBuffer cdata;
+    boolean readCdata;
+
+    // XML RPC parameter types used for dataMode
+    static final int STRING = 0;
+    static final int INTEGER = 1;
+    static final int BOOLEAN = 2;
+    static final int DOUBLE = 3;
+    static final int DATE = 4;
+    static final int BASE64 = 5;
+    static final int STRUCT = 6;
+    static final int ARRAY = 7;
+
+    // Error level + message
+    int errorLevel;
+    String errorMsg;
+
+    static final int NONE = 0;
+    static final int RECOVERABLE = 1;
+    static final int FATAL = 2;
+
+    /**
+     * Wheter to use HTTP Keep-Alive headers.
+     */
+    static boolean keepalive = false;
+
+    /**
+     * Whether to log debugging output.
+     */
+    public static boolean debug = false;
+
+    /**
+     * The list of valid XML elements used for RPC.
+     */
+    final static String types[] =
+    {
+        "String",
+        "Integer",
+        "Boolean",
+        "Double",
+        "Date",
+        "Base64",
+        "Struct",
+        "Array"
+    };
+
+    /**
+     * Java's name for the encoding we're using.  Defaults to
+     * <code>UTF8</code> (of which <code>ISO8859_1</code> is a
+     * subset).
+     */
+    static String encoding = XmlWriter.UTF8;
+
+    /**
+     * Java's name for the input encoding we're using.  Defaults to
+     * <code>null</code>, signifying the platform default. This may
+     * need to be overridden on platforms where the default encoding
+     * is not compatible with ASCII (eg. EBCDIC) but the network is
+     * still ASCII-like.
+     */
+    static String defaultInputEncoding = null;
+ 
+    private TypeFactory typeFactory;
+	private String inputEncoding;
+
+    /**
+     * Creates a new instance with the {@link
+     * org.apache.xmlrpc.TypeFactory} set to an instance of the class
+     * named by the <code>org.apache.xmlrpc.TypeFactory</code> System
+     * property.  If property not set or class is unavailable, uses
+     * the default of {@link org.apache.xmlrpc.TypeFactory}.
+     */
+    protected XmlRpc()
+    {
+        String typeFactoryName = null;
+        try
+        {
+            typeFactoryName = System.getProperty(TypeFactory.class.getName());
+        }
+        catch (SecurityException e)
+        {
+            // An unsigned applet may not access system properties.
+            // No-op means we use the default TypeFactory instead.
+            if (debug)
+            {
+                System.out.println("Unable to determine the value of the " +
+                                   "system property '" +
+                                   TypeFactory.class.getName() + "': " +
+                                   e.getMessage());
+            }
+        }
+        this.typeFactory = createTypeFactory(typeFactoryName);
+		this.inputEncoding = defaultInputEncoding;
+    }
+
+    /**
+     * Creates a new instance with the specified {@link
+     * org.apache.xmlrpc.TypeFactory}.
+     *
+     * @param typeFactoryName The fully qualified class name of the
+     * {@link org.apache.xmlrpc.TypeFactory} implementation to use.
+     */
+    protected XmlRpc(String typeFactoryName)
+    {
+        this.typeFactory = createTypeFactory(typeFactoryName);
+    }
+
+    /**
+     * Creates a new instance of the specified {@link
+     * org.apache.xmlrpc.TypeFactory}.
+     *
+     * @param className The fully qualified class name of the
+     * implementation to use.
+     * @return The new type mapping.
+     */
+    private TypeFactory createTypeFactory(String className)
+    {
+        Class c = null;
+        if (className != null && className.length() > 0)
+        {
+            try
+            {
+                c = Class.forName(className);
+            }
+            catch (ClassNotFoundException e)
+            {
+                System.err.println("Error loading TypeFactory '" +
+                                   "' " + c.getName() +
+                                   "': Using the default instead: " +
+                                   e.getMessage());
+            }
+        }
+
+        // If we're using the default, provide it immediately.
+        if (c == null || DefaultTypeFactory.class.equals(c))
+        {
+            return new DefaultTypeFactory(tz);
+        }
+
+        try
+        {
+            return (TypeFactory) c.newInstance();
+        }
+        catch (Exception e)
+        {
+            System.err.println("Unable to create configured TypeFactory '" +
+                               c.getName() + "': " + e.getMessage() +
+                               ": Falling back to default");
+            if (debug)
+            {
+                e.printStackTrace();
+            }
+            return new DefaultTypeFactory(tz);
+        }
+    }
+
+    TimeZone tz;
+    
+    void setServerTimeZone(TimeZone z) {
+        tz = z;
+        }
+    TimeZone getServerTimeZone() {
+        return tz;
+    }
+
+    /**
+     * Set the SAX Parser to be used. The argument can either be the
+     * full class name or a user friendly shortcut if the parser is
+     * known to this class. The parsers that can currently be set by
+     * shortcut are listed in the main documentation page. If you are
+     * using another parser please send me the name of the SAX driver
+     * and I'll include it in a future release.  If setDriver() is
+     * never called then the System property "sax.driver" is
+     * consulted. If that is not defined the driver defaults to
+     * OpenXML.
+     */
+    public static void setDriver(String driver) throws ClassNotFoundException
+    {
+        String parserClassName = null;
+        try
+        {
+            parserClassName = (String) saxDrivers.get(driver);
+            if (parserClassName == null)
+            {
+                // Identifier lookup failed, assuming we were provided
+                // with the fully qualified class name.
+                parserClassName = driver;
+            }
+            parserClass = Class.forName(parserClassName);
+        }
+        catch (ClassNotFoundException x)
+        {
+            throw new ClassNotFoundException ("SAX driver not found: "
+                    + parserClassName);
+        }
+    }
+
+    /**
+     * Set the SAX Parser to be used by directly passing the Class object.
+     */
+    public static void setDriver(Class driver)
+    {
+        parserClass = driver;
+    }
+
+    /**
+     * Set the encoding of the XML.
+     *
+     * @param enc The Java name of the encoding.
+     */
+    public static void setEncoding(String enc)
+    {
+        encoding = enc;
+    }
+
+    /**
+     * Return the encoding, transforming to the canonical name if
+     * possible.
+     *
+     * @see org.apache.xmlrpc.XmlWriter#canonicalizeEncoding(String)
+     */
+    public String getEncoding()
+    {
+        return XmlWriter.canonicalizeEncoding(encoding);
+    }
+
+    /** Set the default input encoding of the XML.
+     * This is used only if set.
+     *
+     * @param enc The Java name of the encoding.
+     * @see #setInputEncoding(String)
+     */
+    public static void setDefaultInputEncoding(String enc)
+    {
+        defaultInputEncoding = enc;
+    }
+
+    /**
+     * Return the default input encoding. This may be null.
+     * This is always a Java encoding name, it is not transformed.
+     *
+     * @return the Java encoding name to use, if set, otherwise null.
+     * @see #getInputEncoding()
+     */
+    public static String getDefaultInputEncoding()
+    {
+        return defaultInputEncoding;
+    }
+
+    /**
+     * Set the input encoding for this XmlRpc instance.  This can be
+     * used when the XMLRPC response does not contain the proper
+     * encoding information in the XML declaration.
+     *
+     * @param enc The Java name of the encoding.
+     */
+    public void setInputEncoding(String enc)
+    {
+        inputEncoding = enc;
+    }
+
+    /**
+     * Get the input encoding for this XmlRpc instance.  This is a Java
+     * encoding name.
+     *
+     * @return The Java encoding name to use.  <code>null</code> if not set.
+     */
+    public String getInputEncoding()
+    {
+        return inputEncoding;
+    }
+
+    /**
+     * Gets the maximum number of threads used at any given moment.
+     */
+    public static int getMaxThreads()
+    {
+        return maxThreads;
+    }
+
+    /**
+     * Sets the maximum number of threads used at any given moment.
+     */
+    public static void setMaxThreads(int maxThreads)
+    {
+        XmlRpc.maxThreads = maxThreads;
+    }
+
+    /**
+     * Switch debugging output on/off.
+     */
+    public static void setDebug(boolean val)
+    {
+        debug = val;
+    }
+
+    /**
+     * Switch HTTP keepalive on/off.
+     */
+    public static void setKeepAlive(boolean val)
+    {
+        keepalive = val;
+    }
+
+    /**
+     * get current HTTP keepalive mode.
+     */
+    public static boolean getKeepAlive()
+    {
+        return keepalive;
+    }
+
+    /**
+     * Parse the input stream. For each root level object, method
+     * <code>objectParsed</code> is called.
+     */
+    synchronized void parse(InputStream is) throws Exception
+    {
+        // reset values (XmlRpc objects are reusable)
+        errorLevel = NONE;
+        errorMsg = null;
+        values = new Stack();
+        if (cdata == null)
+        {
+            cdata = new StringBuffer(128);
+        }
+        else
+        {
+            cdata.setLength(0);
+        }
+        readCdata = false;
+        currentValue = null;
+
+        long now = System.currentTimeMillis();
+        if (parserClass == null)
+        {
+            // try to get the name of the SAX driver from the System properties
+            String driver;
+            try
+            {
+                driver = System.getProperty("sax.driver", DEFAULT_PARSER);
+            }
+            catch (SecurityException e)
+            {
+                // An unsigned applet may not access system properties.
+                driver = DEFAULT_PARSER;
+            }
+            setDriver(driver);
+        }
+
+        Parser parser = null;
+        try
+        {
+            parser = (Parser) parserClass.newInstance();
+        }
+        catch (NoSuchMethodError nsm)
+        {
+            // This is thrown if no constructor exists for the parser class
+            // and is transformed into a regular exception.
+            throw new Exception("Can't create Parser: " + parserClass);
+        }
+
+        parser.setDocumentHandler(this);
+        parser.setErrorHandler(this);
+
+        if (debug)
+        {
+            System.out.println("Beginning parsing XML input stream");
+        }
+        try
+        {
+            if(inputEncoding == null)
+            {         
+              parser.parse(new InputSource(is));
+            }
+            else
+            {
+              parser.parse( new InputSource( new InputStreamReader(is, inputEncoding)));
+            }
+        }
+        finally
+        {
+            // Clear any huge buffers.
+            if (cdata.length() > 128 * 4)
+            {
+                // Exceeded original capacity by greater than 4x; release
+                // buffer to prevent leakage.
+                cdata = null;
+            }
+        }
+        if (debug)
+        {
+            System.out.println ("Spent " + (System.currentTimeMillis() - now)
+                    + " millis parsing");
+        }
+    }
+
+    /**
+     * This method is called when a root level object has been parsed.
+     * Sub-classes implement this callback to receive the fully parsed
+     * object.
+     */
+    protected abstract void objectParsed(Object what);
+
+
+    ////////////////////////////////////////////////////////////////
+    // methods called by XML parser
+
+    /**
+     * Method called by SAX driver.
+     */
+    public void characters(char ch[], int start, int length)
+            throws SAXException
+    {
+        if (readCdata)
+        {
+            cdata.append(ch, start, length);
+        }
+    }
+
+    /**
+     * Method called by SAX driver.
+     */
+    public void endElement(String name) throws SAXException
+    {
+
+        if (debug)
+        {
+            System.out.println("endElement: " + name);
+        }
+
+        // finalize character data, if appropriate
+        if (currentValue != null && readCdata)
+        {
+            currentValue.characterData(cdata.toString());
+            cdata.setLength(0);
+            readCdata = false;
+        }
+
+        if ("value".equals(name))
+        {
+            // Only handle top level objects or objects contained in
+            // arrays here.  For objects contained in structs, wait
+            // for </member> (see code below).
+            int depth = values.size();
+            if (depth < 2 || values.elementAt(depth - 2).hashCode() != STRUCT)
+            {
+                Value v = currentValue;
+                values.pop();
+                if (depth < 2)
+                {
+                    // This is a top-level object
+                    objectParsed(v.value);
+                    currentValue = null;
+                }
+                else
+                {
+                    // Add object to sub-array; if current container
+                    // is a struct, add later (at </member>).
+                    currentValue = (Value) values.peek();
+                    currentValue.endElement(v);
+                }
+            }
+        }
+
+        // Handle objects contained in structs.
+        if ("member".equals(name))
+        {
+            Value v = currentValue;
+            values.pop();
+            currentValue = (Value) values.peek();
+            currentValue.endElement(v);
+        }
+
+        else if ("methodName".equals(name))
+        {
+            methodName = cdata.toString();
+            cdata.setLength(0);
+            readCdata = false;
+        }
+    }
+
+    /**
+     * Method called by SAX driver.
+     */
+    public void startElement(String name, AttributeList atts)
+            throws SAXException
+    {
+        if (debug)
+        {
+            System.out.println("startElement: " + name);
+        }
+
+        if ("value".equals(name))
+        {
+            Value v = new Value();
+            values.push(v);
+            currentValue = v;
+            // cdata object is reused
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("methodName".equals(name))
+        {
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("name".equals(name))
+        {
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("string".equals(name))
+        {
+            // currentValue.setType (STRING);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("i4".equals(name) || "int".equals(name))
+        {
+            currentValue.setType(INTEGER);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("boolean".equals(name))
+        {
+            currentValue.setType(BOOLEAN);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("double".equals(name))
+        {
+            currentValue.setType(DOUBLE);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("dateTime.iso8601".equals(name))
+        {
+            currentValue.setType(DATE);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("base64".equals(name))
+        {
+            currentValue.setType(BASE64);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("struct".equals(name))
+        {
+            currentValue.setType(STRUCT);
+        }
+        else if ("array".equals(name))
+        {
+            currentValue.setType(ARRAY);
+        }
+    }
+
+    /**
+     *
+     * @param e
+     * @throws SAXException
+     */
+    public void error(SAXParseException e) throws SAXException
+    {
+        System.err.println("Error parsing XML: " + e);
+        errorLevel = RECOVERABLE;
+        errorMsg = e.toString();
+    }
+
+    /**
+     *
+     * @param e
+     * @throws SAXException
+     */
+    public void fatalError(SAXParseException e) throws SAXException
+    {
+        System.err.println("Fatal error parsing XML: " + e);
+        errorLevel = FATAL;
+        errorMsg = e.toString();
+    }
+
+    /**
+     * This represents a XML-RPC value parsed from the request.
+     */
+    class Value
+    {
+        int type;
+        Object value;
+        // the name to use for the next member of struct values
+        String nextMemberName;
+
+        Hashtable struct;
+        Vector array;
+
+        /**
+         * Constructor.
+         */
+        public Value()
+        {
+            this.type = STRING;
+        }
+
+        /**
+         * Notification that a new child element has been parsed.
+         */
+        public void endElement(Value child)
+        {
+            switch (type)
+            {
+                case ARRAY:
+                    array.addElement(child.value);
+                    break;
+                case STRUCT:
+                    struct.put(nextMemberName, child.value);
+            }
+        }
+
+        /**
+         * Set the type of this value. If it's a container, create the
+         * corresponding java container.
+         */
+        public void setType(int type)
+        {
+            //System.out.println ("setting type to "+types[type]);
+            this.type = type;
+            switch (type)
+            {
+                case ARRAY:
+                    value = array = new Vector();
+                    break;
+                case STRUCT:
+                    value = struct = new Hashtable();
+                    break;
+            }
+        }
+
+        /**
+         * Set the character data for the element and interpret it
+         * according to the element type.
+         */
+        public void characterData(String cdata)
+        {
+            switch (type)
+            {
+                case INTEGER:
+                    value = typeFactory.createInteger(cdata);
+                    break;
+                case BOOLEAN:
+                    value = typeFactory.createBoolean(cdata);
+                    break;
+                case DOUBLE:
+                    value = typeFactory.createDouble(cdata);
+                    break;
+                case DATE:
+                    value = typeFactory.createDate(cdata);
+                    break;
+                case BASE64:
+                    value = typeFactory.createBase64(cdata);
+                    break;
+                case STRING:
+                    value = typeFactory.createString(cdata);
+                    break;
+                case STRUCT:
+                    // this is the name to use for the next member of this struct
+                    nextMemberName = cdata;
+                    break;
+            }
+        }
+
+        /**
+         * This is a performance hack to get the type of a value
+         * without casting the Object.  It breaks the contract of
+         * method hashCode, but it doesn't matter since Value objects
+         * are never used as keys in Hashtables.
+         */
+        public int hashCode()
+        {
+            return type;
+        }
+
+        /**
+         *
+         * @return
+         */
+        public String toString()
+        {
+            return (types[type] + " element " + value);
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcClient.java
@@ -0,0 +1,501 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.EmptyStackException;
+import java.util.Stack;
+import java.util.Vector;
+import java.util.TimeZone;
+
+/**
+ * A multithreaded, reusable XML-RPC client object. Use this if you
+ * need a full-grown HTTP client (e.g. for Proxy and Basic Auth
+ * support). If you don't need that, <code>XmlRpcClientLite</code> may
+ * work better for you.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @author <a href="mailto:rhoegg@isisnetworks.net">Ryan Hoegg</a>
+ * @version $Id: XmlRpcClient.java 350048 2005-11-30 21:49:32 +0100 (Mi, 30 Nov 2005) jochen $
+ */
+public class XmlRpcClient implements XmlRpcHandler
+{
+    protected URL url;
+    
+    // stored user and password for deprecated setBasicAuthentication method
+    private String storedUser;
+    private String storedPassword;
+
+    // pool of worker instances
+    protected Stack pool = new Stack();
+    protected int workers = 0;
+    protected int asyncWorkers = 0;
+    protected XmlRpcTransportFactory transportFactory;
+
+    // a queue of calls to be handled asynchronously
+    private CallData first, last;
+
+    /**
+     * The maximum number of threads which can be used concurrently, by defaut use the one defined
+     * in XmlRpc
+     */
+    private int maxThreads = -1;
+
+    
+    /**
+     * Construct a XML-RPC client with this URL and a specified transport
+     * factory.
+     */
+    public XmlRpcClient(URL url, XmlRpcTransportFactory transportFactory)
+    {
+       this.url = url;
+       this.transportFactory = transportFactory;
+    }
+
+    /**
+     * Construct a XML-RPC client with this URL.
+     */
+    public XmlRpcClient(URL url)
+    {
+        this.url = url;
+        if (XmlRpc.debug)
+        {
+            System.out.println("Created client to url space " + url);
+        }
+    }
+
+    /**
+     * Construct a XML-RPC client for the URL represented by this String.
+     */
+    public XmlRpcClient(String url) throws MalformedURLException
+    {
+        this(new URL(url));
+    }
+
+    /**
+     * Construct a XML-RPC client for the specified hostname and port.
+     */
+    public XmlRpcClient(String hostname, int port) throws MalformedURLException
+    {
+        this(new URL("http://" + hostname + ':' + port + "/RPC2"));
+    }
+
+    /**
+     * Set the MaxThreads for this Client
+     */
+    public void setMaxThreads(int maxThreads) 
+    {
+    	this.maxThreads = maxThreads;
+    }
+    
+    /**
+     * Get the MaxThreads for this Client
+     */
+    public int getMaxThreads() 
+    {
+    	if (maxThreads == -1)
+    		return (XmlRpc.getMaxThreads());
+    	
+    	return (maxThreads);
+    }
+    
+    /**
+     * Return the URL for this XML-RPC client.
+     */
+    public URL getURL()
+    {
+        return url;
+    }
+
+    /**
+     * Sets Authentication for this client. This will be sent as Basic
+     * Authentication header to the server as described in
+     * <a href="http://www.ietf.org/rfc/rfc2617.txt">
+     * http://www.ietf.org/rfc/rfc2617.txt</a>.
+     *
+     * This method has been deprecated.  Furthermore, it has no
+     * effect on the overloads for execute and executeAsync that
+     * use an XmlRpcClientRequest or an XmlRpcTransport.
+     *
+     * @deprecated Authentication is now handled by each XmlRpcTransport
+     *
+     * @see DefaultXmlRpcTransport
+     * @see LiteXmlRpcTransport
+     * @see CommonsXmlRpcTransport
+     */
+    public void setBasicAuthentication(String user, String password)
+    {
+        /*
+         * Store for use in execute and executeAsync
+         *
+         * Will be unnecessary once this method is removed.
+         */
+        storedUser = user;
+        storedPassword = password;
+    }
+
+    /**
+     * Generate an XML-RPC request and send it to the server. Parse the result
+     * and return the corresponding Java object.
+     *
+     * @exception XmlRpcException: If the remote host returned a fault message.
+     * @exception IOException: If the call could not be made because of lower
+     *          level problems.
+     */
+    public Object execute(String method, Vector params)
+            throws XmlRpcException, IOException
+    {
+        /* Setting user and password on transport if setBasicAuthentication was 
+         * used and there is no XmlRpcTransportFactory.  As setBasicAuthentication 
+         * is deprecated, this should be removed in a future version.
+         */
+        if ((storedUser != null) && (storedPassword != null) && (transportFactory == null))
+        {
+            DefaultXmlRpcTransport transport = createDefaultTransport();
+            transport.setBasicAuthentication(storedUser, storedPassword);
+            return execute(new XmlRpcRequest(method, params), transport);
+        }
+        else
+        {
+            return execute(new XmlRpcRequest(method, params));
+        }
+    }
+
+    public Object execute(XmlRpcClientRequest request)
+            throws XmlRpcException, IOException
+    {
+        return execute(request, createTransport());
+    }
+
+    public Object execute(XmlRpcClientRequest request, XmlRpcTransport transport)
+            throws XmlRpcException, IOException
+    {
+        XmlRpcClientWorker worker = getWorker(false);
+        try
+        {
+            Object retval = worker.execute(request, transport);
+            return retval;
+        }
+        finally
+        {
+            releaseWorker(worker, false);
+        }
+    }
+    /**
+     * Generate an XML-RPC request and send it to the server in a new thread.
+     * This method returns immediately.
+     * If the callback parameter is not null, it will be called later to handle
+     * the result or error when the call is finished.
+     */
+    public void executeAsync(String method, Vector params,
+            AsyncCallback callback)
+    {
+        XmlRpcRequest request = new XmlRpcRequest(method, params);
+        if ((storedUser != null) && (storedPassword != null) && (transportFactory == null))
+        {
+            DefaultXmlRpcTransport transport = createDefaultTransport();
+            transport.setBasicAuthentication(storedUser, storedPassword);
+            executeAsync(request, callback, transport);
+        }
+        else
+        {
+            executeAsync(request, callback);
+        }
+    }
+
+    public void executeAsync(XmlRpcClientRequest request,
+            AsyncCallback callback)
+    {
+        executeAsync(request, callback, null);
+    }
+
+    public void executeAsync(XmlRpcClientRequest request,
+            AsyncCallback callback, XmlRpcTransport transport)
+    {
+        CallData call = new CallData(request, callback, transport);
+
+        // if at least 4 threads are running, don't create any new ones,
+        // just enqueue the request.
+        if (asyncWorkers >= 4)
+        {
+            enqueue(call);
+            return;
+        }
+        XmlRpcClientWorker worker = null;
+        try
+        {
+            new XmlRpcClientAsyncThread(getWorker(true), call).start();
+        }
+        catch(IOException iox)
+        {
+            // make a queued worker that doesn't run immediately
+            enqueue(call);
+        }
+    }
+
+    class XmlRpcClientAsyncThread extends Thread
+    {
+        protected XmlRpcClientWorker worker;
+        protected CallData call;
+
+        protected XmlRpcClientAsyncThread(XmlRpcClientWorker worker, CallData initialCall)
+        {
+           this.worker = worker;
+           this.call = initialCall;
+        }
+
+        public void run()
+        {
+            try
+            {
+                if (call == null)
+                    call = dequeue();
+                
+                while (call != null)
+                {
+                    executeAsync(call.request, call.callback, call.transport);
+                    call = dequeue();
+                }
+            }
+            finally
+            {
+                releaseWorker(worker, true);
+            }
+        }
+
+        /**
+         * Execute an XML-RPC call and handle asyncronous callback.
+         */
+        void executeAsync(XmlRpcClientRequest request, AsyncCallback callback, XmlRpcTransport transport)
+        {
+            Object res = null;
+            try
+            {
+                if (transport == null)
+                {
+                    transport = createTransport();
+                }
+                res = worker.execute(request, transport);
+                // notify callback object
+                if (callback != null)
+                {
+                    callback.handleResult(res, url, request.getMethodName());
+                }
+            }
+            catch(Exception x)
+            {
+                if (callback != null)
+                {
+                    try
+                    {
+                        callback.handleError(x, url, request.getMethodName());
+                    }
+                    catch(Exception ignore)
+                    {
+                    }
+                }
+            }
+        }
+    }
+    /**
+     *
+     * @param async
+     * @return
+     * @throws IOException
+     */
+    synchronized XmlRpcClientWorker getWorker(boolean async) throws IOException
+    {
+        try
+        {
+            XmlRpcClientWorker w = (XmlRpcClientWorker) pool.pop();
+            if (async)
+            {
+                asyncWorkers += 1;
+            }
+            else
+            {
+                workers += 1;
+            }
+            return w;
+        }
+        catch(EmptyStackException x)
+        {
+            if (workers < getMaxThreads())
+            {
+                if (async)
+                {
+                    asyncWorkers += 1;
+                }
+                else
+                {
+                    workers += 1;
+                }
+                return new XmlRpcClientWorker(getTimeZone());
+            }
+            throw new IOException("XML-RPC System overload");
+        }
+    }
+
+    TimeZone tz;
+    public void setTimeZone(TimeZone z) {
+        tz = z;
+    }
+
+    public TimeZone getTimeZone() {
+        return tz;
+    }
+
+    /**
+     * Release possibly big per-call object references to allow them to be
+     * garbage collected
+     */
+    synchronized void releaseWorker(XmlRpcClientWorker w, boolean async)
+    {
+        if (pool.size() < 20)
+        {
+            pool.push(w);
+        }
+        if (async)
+        {
+            asyncWorkers -= 1;
+        }
+        else
+        {
+            workers -= 1;
+        }
+    }
+
+    /**
+     *
+     * @param method
+     * @param params
+     * @param callback
+     */
+    synchronized void enqueue(CallData call)
+    {
+        if (last == null)
+        {
+            first = last = call;
+        }
+        else
+        {
+            last.next = call;
+            last = call;
+        }
+    }
+
+    /**
+     *
+     * @return
+     */
+    synchronized CallData dequeue()
+    {
+        if (first == null)
+        {
+            return null;
+        }
+        CallData call = first;
+        if (first == last)
+        {
+            first = last = null;
+        }
+        else
+        {
+            first = first.next;
+        }
+        return call;
+    }
+
+    class CallData
+    {
+        XmlRpcClientRequest request;
+        XmlRpcTransport transport;
+        AsyncCallback callback;
+        CallData next;
+
+        /**
+         * Make a call to be queued and then executed by the next free async
+         * thread
+         */
+        public CallData(XmlRpcClientRequest request, AsyncCallback callback, XmlRpcTransport transport)
+        {
+            this.request = request;
+            this.callback = callback;
+            this.transport = transport;
+            this.next = null;
+        }
+    }
+
+    protected XmlRpcTransport createTransport() throws XmlRpcClientException
+    {
+        if (transportFactory == null)
+        {
+          return createDefaultTransport();
+        }
+        return transportFactory.createTransport();
+    }
+    
+    private DefaultXmlRpcTransport createDefaultTransport() {
+        return new DefaultXmlRpcTransport(url);
+    }
+
+    /**
+     * Just for testing.
+     */
+    public static void main(String args[]) throws Exception
+    {
+        // XmlRpc.setDebug(true);
+        // XmlRpc.setKeepAlive(true);
+        try
+        {
+            String url = args[0];
+            String method = args[1];
+            Vector v = new Vector();
+            for (int i = 2; i < args.length; i++)
+            {
+                try
+                {
+                    v.addElement(new Integer(Integer.parseInt(args[i])));
+                }
+                catch(NumberFormatException nfx)
+                {
+                    v.addElement(args[i]);
+                }
+            }
+            XmlRpcClient client = new XmlRpcClient(url);
+            try
+            {
+                System.out.println(client.execute(method, v));
+            }
+            catch(Exception ex)
+            {
+                System.err.println("Error: " + ex.getMessage());
+            }
+        }
+        catch(Exception x)
+        {
+            System.err.println(x);
+            System.err.println("Usage: java org.apache.xmlrpc.XmlRpcClient "
+                    + "<url> <method> <arg> ....");
+            System.err.println("Arguments are sent as integers or strings.");
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcClientException.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * This is thrown by many of the client classes if an error occured processing
+ * and XML-RPC request or response due to client side processing. This exception
+ * will wrap a cause exception in the JDK 1.4 style.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcClientException.java 233944 2005-05-02 04:22:21Z dlr $
+ * @since 1.2
+ */
+public class XmlRpcClientException extends XmlRpcException
+{
+    /**
+     * Create an XmlRpcClientException with the given message and
+     * underlying cause exception.
+     *
+     * @param message the message for this exception.
+     * @param cause the cause of the exception.
+     */
+    public XmlRpcClientException(String message, Throwable cause)
+    {
+        super(0, message, cause);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcClientLite.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Vector;
+
+/**
+ * A multithreaded, reusable XML-RPC client object. This version uses a homegrown
+ * HTTP client which can be quite a bit faster than java.net.URLConnection, especially
+ * when used with XmlRpc.setKeepAlive(true).
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcClientLite.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class XmlRpcClientLite extends XmlRpcClient
+{
+    /**
+     * Construct a XML-RPC client with this URL.
+     */
+    public XmlRpcClientLite (URL url)
+    {
+        super (url);
+    }
+
+    /**
+     * Construct a XML-RPC client for the URL represented by this String.
+     */
+    public XmlRpcClientLite (String url) throws MalformedURLException
+    {
+        super (url);
+    }
+
+    /**
+     * Construct a XML-RPC client for the specified hostname and port.
+     */
+    public XmlRpcClientLite (String hostname, int port)
+            throws MalformedURLException
+    {
+        super (hostname, port);
+    }
+
+    protected XmlRpcTransport createTransport()
+    {
+        return new LiteXmlRpcTransport(url);
+    }
+
+    /**
+     * Just for testing.
+     */
+    public static void main(String args[]) throws Exception
+    {
+        // XmlRpc.setDebug (true);
+        try
+        {
+            String url = args[0];
+            String method = args[1];
+            XmlRpcClientLite client = new XmlRpcClientLite (url);
+            Vector v = new Vector ();
+            for (int i = 2; i < args.length; i++)
+            {
+                try
+                {
+                    v.addElement(new Integer(Integer.parseInt(args[i])));
+                }
+                catch (NumberFormatException nfx)
+                {
+                    v.addElement(args[i]);
+                }
+            }
+            // XmlRpc.setEncoding ("UTF-8");
+            try
+            {
+                System.out.println(client.execute(method, v));
+            }
+            catch (Exception ex)
+            {
+                System.err.println("Error: " + ex.getMessage());
+            }
+        }
+        catch (Exception x)
+        {
+            System.err.println(x);
+            System.err.println("Usage: java org.apache.xmlrpc.XmlRpcClient "
+                    + "<url> <method> <arg> ....");
+            System.err.println("Arguments are sent as integers or strings.");
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcClientRequest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * Interface to an XML-RPC request made by a client.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcClientRequest.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public interface XmlRpcClientRequest
+{
+    public String getMethodName();
+    public int getParameterCount();
+    public Object getParameter(int index);
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcClientRequestProcessor.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.TimeZone;
+
+/**
+ * Process an XML-RPC client request into a byte array or directly onto
+ * an OutputStream.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcClientRequestProcessor.java 350048 2005-11-30 21:49:32 +0100 (Mi, 30 Nov 2005) jochen $
+ * @since 1.2
+ */
+public class XmlRpcClientRequestProcessor
+{
+    TimeZone tz;
+    /**
+     * Creates a new instance.
+     */
+    public XmlRpcClientRequestProcessor(TimeZone tz)
+    {
+        this.tz = tz;
+    }
+	
+    /**
+     * Encode a request from the XmlClientRpcRequest implementation to an
+     * output stream in the specified character encoding.
+     *
+     * @param request the request to encode.
+     * @param encoding the Java name for the encoding to use.
+     */
+    public void encodeRequest(XmlRpcClientRequest request, String encoding,
+                              OutputStream out)
+        throws XmlRpcClientException, IOException
+    {
+        XmlWriter writer;
+
+        writer = new XmlWriter(out, encoding);
+        writer.dateTool.setTimeZone(tz);
+        writer.startElement("methodCall");
+        writer.startElement("methodName");
+        writer.write(request.getMethodName());
+        writer.endElement("methodName");
+        writer.startElement("params");
+
+        int l = request.getParameterCount();
+        for (int i = 0; i < l; i++)
+        {
+            writer.startElement("param");
+            try
+            {
+                writer.writeObject(request.getParameter(i));
+            }
+            catch (XmlRpcException e)
+            {
+                throw new XmlRpcClientException("Failure writing request", e);
+            }
+            writer.endElement("param");
+        }
+        writer.endElement("params");
+        writer.endElement("methodCall");
+        writer.flush();
+    }
+
+    /**
+     * Encode a request from the XmlRpcClientRequest implementation to a
+     * byte array representing the XML-RPC call, in the specified character
+     * encoding.
+     *
+     * @param request the request to encode.
+     * @param encoding the Java name for the encoding to use.
+     * @return byte [] the encoded request.
+     */
+    public byte [] encodeRequestBytes(XmlRpcClientRequest request, String encoding)
+    throws XmlRpcClientException
+    {
+        ByteArrayOutputStream buffer;
+
+        try
+        {
+            buffer = new ByteArrayOutputStream();
+            encodeRequest(request, encoding, buffer);
+            return buffer.toByteArray();
+        }
+        catch (IOException ioe)
+        {
+            throw new XmlRpcClientException("Error occured encoding XML-RPC request", ioe);
+        }
+    }
+
+    /**
+     * Called by the worker management framework to see if this object can be
+     * re-used. Must attempt to clean up any state, and return true if it can
+     * be re-used.
+     *
+     * @return boolean true if this objcet has been cleaned up and may be re-used.
+     */
+    protected boolean canReUse()
+    {
+        return true;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcClientResponseProcessor.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import org.xml.sax.AttributeList;
+import org.xml.sax.SAXException;
+
+import java.io.InputStream;
+import java.util.Hashtable;
+import java.util.TimeZone;
+
+/**
+ * Process an XML-RPC server response from a byte array or an
+ * InputStream into an Object. Optionally throw the result object
+ * if it is an exception.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcClientResponseProcessor.java 350048 2005-11-30 21:49:32 +0100 (Mi, 30 Nov 2005) jochen $
+ * @since 2.0
+ */
+public class XmlRpcClientResponseProcessor extends XmlRpc
+{
+    /** The result of the XML-RPC operation. Possibly an XmlRpcException */
+    protected Object result;
+
+    /** Set to true if a fault occured on the server. */
+    protected boolean fault;
+
+    /**
+     * Creates a new instance.
+     */
+    public XmlRpcClientResponseProcessor(TimeZone tz)
+    {
+        setServerTimeZone(tz);
+    }
+
+    /**
+     * Decode an XML-RPC response from the specified InputStream.
+     *
+     * @param is The stream from which to read the response.
+     * @return The response, which will be a XmlRpcException if an
+     * error occured.
+     * @exception XmlRpcClientException
+     */
+    public Object decodeResponse(InputStream is)
+        throws XmlRpcClientException
+    {
+        result = null;
+        fault = false;
+        try
+        {
+            parse(is);
+            if (fault)
+            {
+                return decodeException(result);
+            }
+            else
+            {
+                return result;
+            }
+        }
+        catch (Exception x)
+        {
+            throw new XmlRpcClientException("Error decoding XML-RPC response", x);
+        }
+    }
+
+    /**
+     * Decode an exception from the result returned from the remote server.
+     * This method both returns and throws an XmlRpcException. If it returns an
+     * XmlRpcException then that is the exception thrown on the remote side. If
+     * it throws an exception then an exception occured locally when decoding
+     * the response
+     *
+     * @param result The response from the remote XML-RPC server.
+     * @return A XmlRpcException describing the error which occurred.
+     * @exception XmlRpcClientException if the result could not be processed.
+     * @return XmlRpcException the processed response from the server.
+     */
+    protected XmlRpcException decodeException(Object result)
+        throws XmlRpcClientException
+    {
+        Hashtable exceptionData;
+        
+        try
+        {
+            exceptionData = (Hashtable) result; 
+            return new XmlRpcException(
+                Integer.parseInt(exceptionData.get("faultCode").toString()),
+                (String) exceptionData.get("faultString")
+            );
+        }
+        catch (Exception x)
+        {
+            throw new XmlRpcClientException("Error decoding XML-RPC exception response", x);
+        }
+    }
+
+    protected void objectParsed(Object what)
+    {
+        result = what;
+    }
+
+    /**
+     * Overrides method in XmlRpc to handle fault repsonses.
+     */
+    public void startElement(String name, AttributeList atts)
+            throws SAXException
+    {
+        if ("fault".equals(name))
+        {
+            fault = true;
+        }
+        else
+        {
+            super.startElement(name, atts);
+        }
+    }
+
+    /**
+     * Called by the worker management framework to see if this worker can be
+     * re-used. Must attempt to clean up any state, and return true if it can
+     * be re-used.
+     *
+     * @return boolean true if this worker has been cleaned up and may be re-used.
+     */
+    protected boolean canReUse()
+    {
+        result = null;
+        fault = false;
+        return true;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcClientWorker.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.InputStream;
+import java.io.IOException;
+import java.util.TimeZone;
+
+/**
+ * Tie together the XmlRequestProcessor and XmlResponseProcessor to handle
+ * a request serially in a single thread.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @since 2.0
+ */
+public class XmlRpcClientWorker
+{
+    protected XmlRpcClientRequestProcessor requestProcessor;
+    protected XmlRpcClientResponseProcessor responseProcessor;
+
+    /**
+     * Used as an internal marker value in {@link
+     * #execute(XmlRpcClientRequest, XmlRpcTransport)}.
+     */
+    private static final Object PROCESSING_ERROR_FLAG = new Object();
+
+    public XmlRpcClientWorker(TimeZone tz)
+    {
+        this(new XmlRpcClientRequestProcessor(tz),
+             new XmlRpcClientResponseProcessor(tz)
+        );
+    }
+
+    public XmlRpcClientWorker(XmlRpcClientRequestProcessor requestProcessor,
+                              XmlRpcClientResponseProcessor responseProcessor)
+    {
+        this.requestProcessor = requestProcessor;
+        this.responseProcessor = responseProcessor;
+    }
+
+    public Object execute(XmlRpcClientRequest xmlRpcRequest,
+                          XmlRpcTransport transport)
+        throws XmlRpcException, XmlRpcClientException, IOException
+    {
+        long now = 0;
+
+        if (XmlRpc.debug)
+        {
+            now = System.currentTimeMillis();
+        }
+
+        boolean endClientRequestDone = false;
+        try
+        {
+            byte[] request = requestProcessor.encodeRequestBytes
+                (xmlRpcRequest, responseProcessor.getEncoding());
+            InputStream is  = transport.sendXmlRpc(request);
+            Object response = responseProcessor.decodeResponse(is);
+            endClientRequestDone = true;
+            transport.endClientRequest();
+            if (response != null  &&  response instanceof XmlRpcException) {
+            	throw (XmlRpcException) response;
+            }
+            return response;
+        }
+        catch (IOException ioe)
+        {
+            throw ioe;
+        }
+        catch (XmlRpcClientException xrce)
+        {
+            throw xrce;
+        }
+        catch (RuntimeException x)
+        {
+            if (XmlRpc.debug)
+            {
+                x.printStackTrace();
+            }
+            throw new XmlRpcClientException
+                ("Unexpected exception in client processing", x);
+        }
+        finally
+        {
+            if (XmlRpc.debug)
+            {
+                System.out.println("Spent " + (System.currentTimeMillis() - now)
+                                   + " millis in request/process/response");
+            }
+
+            if (!endClientRequestDone)
+            {
+            	try
+            	{
+            		transport.endClientRequest();
+            	}
+            	catch (Throwable ignore)
+            	{
+            	}
+            }
+        }
+    }
+
+    /**
+     * Called by the worker management framework to see if this worker can be
+     * re-used. Must attempt to clean up any state, and return true if it can
+     * be re-used.
+     *
+     * @return Whether this worker has been cleaned up and may be re-used.
+     */
+    // ### isReusable() would be a better name for this set of methods
+    protected boolean canReUse()
+    {
+        return responseProcessor.canReUse() && requestProcessor.canReUse();
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcContext.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * The minimal context that an XML-RPC request will occur in.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcContext.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public interface XmlRpcContext
+{
+    /**
+     * Get the username specified in the outer request.
+     *
+     * @returns the username (may be null).
+     */
+    public String getUserName();
+
+    /**
+     * Get the password specified in the outer request.
+     *
+     * @returns the password (may be null).
+     */
+    public String getPassword();
+
+    /**
+     * Get the XML-RPC handler mapping for the server handling the request.
+     *
+     * @returns the handler mapping (may be null).
+     */
+    public XmlRpcHandlerMapping getHandlerMapping();
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcException.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * This is thrown by the XmlRpcClient if the remote server reported an error.
+ * If something went wrong at a lower level (e.g. no http connection) an
+ * IOException will be thrown instead.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @version $Id: XmlRpcException.java 233944 2005-05-02 04:22:21Z dlr $
+ */
+public class XmlRpcException extends Exception
+{
+    /**
+     * The fault code of the exception. For servers based on this library, this
+     * will always be 0. (If there are predefined error codes, they should be in
+     * the XML-RPC spec.)
+     */
+    public final int code;
+
+    /**
+     * The underlying cause of this exception.
+     */
+    private Throwable cause;
+
+    /**
+     * @see #XmlRpcException(int, String, Throwable)
+     */
+    public XmlRpcException(int code, String message)
+    {
+        this(code, message, null);
+    }
+
+    /**
+     * Creates an instance with the specified message and root cause
+     * exception.
+     *
+     * @param int The fault code for this problem.
+     * @param message The message describing this exception.
+     * @param cause The root cause of this exception.
+     */
+    public XmlRpcException(int code, String message, Throwable cause)
+    {
+        super(message);
+        this.code = code;
+        this.cause = cause;
+    }
+
+    /**
+     * Returns the cause of this throwable or null if the cause is nonexistent
+     * or unknown. (The cause is the throwable that caused this throwable to
+     * get thrown.)
+     * 
+     * This implementation returns the cause that was supplied via the constructor,
+     * according to the rules specified for a "legacy chained throwable" that
+     * predates the addition of chained exceptions to Throwable.
+     *
+     * See the <a
+     * href="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Throwable.html">JDK
+     * 1.4 Throwable documentation</a> for more information.
+     */
+    public Throwable getCause()
+    {
+        return cause;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcHandler.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Vector;
+
+/**
+ * The XML-RPC server uses this interface to call a method of an RPC handler.
+ * This should be implemented by any class that wants to directly take control
+ * when it is called over RPC. Classes not implementing this interface will be
+ * wrapped into an Invoker object that tries to find the matching method
+ * for an XML-RPC request.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @version $Id: XmlRpcHandler.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public interface XmlRpcHandler
+{
+    /**
+     * Return the result, or throw an Exception if something went wrong.
+     */
+    public Object execute (String method, Vector params)
+            throws Exception;
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcHandlerMapping.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+/**
+ * Maps from a handler name to a handler object.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @since 1.2
+ */
+public interface XmlRpcHandlerMapping
+{
+  /**
+   * Return the handler for the specified handler name.
+   *
+   * @param handlerName The name of the handler to retrieve.
+   * @return Object The desired handler.
+   * @throws Exception If a handler can not be found.
+   */
+  public Object getHandler(String handlerName)
+      throws Exception;
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcProxyServlet.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A <code>HttpServlet</code> that acts as a XML-RPC proxy.
+ *
+ * The URL of the server to connect to is taken from the servlet
+ * initialization parameter <code>url</code>.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @version $Id: XmlRpcProxyServlet.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class XmlRpcProxyServlet extends HttpServlet
+{
+    private XmlRpcServer xmlrpc;
+
+    /**
+     *
+     * @param config
+     * @throws ServletException
+     */
+    public void init(ServletConfig config) throws ServletException
+    {
+        if ("true".equalsIgnoreCase(config.getInitParameter("debug")))
+        {
+            XmlRpc.setDebug(true);
+        }
+        String url = config.getInitParameter("url");
+        xmlrpc = new XmlRpcServer();
+        try
+        {
+            xmlrpc.addHandler("$default", new XmlRpcClientLite(url));
+        }
+        catch (Exception x)
+        {
+            throw new ServletException("Invalid URL: " + url + " ("
+                    + x.toString () + ")");
+        }
+    }
+
+    /**
+     *
+     * @param req
+     * @param res
+     * @throws ServletException
+     * @throws IOException
+     */
+    public void doPost(HttpServletRequest req, HttpServletResponse res)
+            throws ServletException, IOException
+    {
+        byte[] result = xmlrpc.execute(req.getInputStream ());
+        res.setContentType("text/xml");
+        res.setContentLength(result.length);
+        OutputStream output = res.getOutputStream();
+        output.write(result);
+        output.flush();
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcRequest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Vector;
+
+/**
+ * Default implementation of an XML-RPC request for both client and server.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcRequest.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public class XmlRpcRequest
+implements XmlRpcServerRequest, XmlRpcClientRequest
+{
+    protected final String methodName;
+    protected final Vector parameters;
+
+    public XmlRpcRequest(String methodName, Vector parameters)
+    {
+        this.parameters = parameters;
+        this.methodName = methodName;
+    }
+
+    public int getParameterCount()
+    {
+        return parameters.size();
+    }
+    
+    public Vector getParameters()
+    {
+        return parameters;
+    }
+
+    public Object getParameter(int index)
+    {
+        return parameters.elementAt(index);
+    }
+
+    public String getMethodName()
+    {
+        return methodName;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcRequestProcessor.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.InputStream;
+import java.util.Vector;
+
+/**
+ * Process an InputStream and produce an XmlRpcServerRequest.  This class
+ * is NOT thread safe.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ * @since 1.2
+ */
+public class XmlRpcRequestProcessor extends XmlRpc
+{
+    private Vector requestParams;
+
+    /**
+     * Creates a new instance.
+     */
+    public XmlRpcRequestProcessor()
+    {
+        requestParams = new Vector();
+    }
+
+    /**
+     * Decode a request from an InputStream to the internal XmlRpcRequest
+     * implementation. This method must read data from the specified stream and
+     * return an XmlRpcRequest object, or throw an exception.
+     *
+     * @param is the stream to read the request from.
+     * @returns XMLRpcRequest the request.
+     * @throws ParseFailed if unable to parse the request.
+     */
+    public XmlRpcServerRequest decodeRequest(InputStream is)
+    {
+        long now = 0;
+
+        if (XmlRpc.debug)
+        {
+            now = System.currentTimeMillis();
+        }
+        try
+        {
+            try
+            {
+                parse(is);
+            }
+            catch (Exception e)
+            {
+                throw new ParseFailed(e);
+            }
+            if (XmlRpc.debug)
+            {
+                System.out.println("XML-RPC method name: " + methodName);
+                System.out.println("Request parameters: " + requestParams);
+            }
+            // check for errors from the XML parser
+            if (errorLevel > NONE)
+            {
+                throw new ParseFailed(errorMsg);
+            }
+
+            return new XmlRpcRequest(methodName, (Vector) requestParams.clone());
+        }
+        finally
+        {
+            requestParams.removeAllElements();
+            if (XmlRpc.debug)
+            {
+                System.out.println("Spent " + (System.currentTimeMillis() - now)
+                        + " millis decoding request");
+            }
+        }
+    }
+
+    /**
+     * Called when an object to be added to the argument list has been
+     * parsed.
+     *
+     * @param what The parameter parsed from the request.
+     */
+    protected void objectParsed(Object what)
+    {
+        requestParams.addElement(what);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcResponseProcessor.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.ByteArrayOutputStream;
+import java.io.UnsupportedEncodingException;
+import java.io.IOException;
+import java.util.Hashtable;
+
+/**
+ * Process an Object and produce byte array that represents the specified
+ * encoding of the output as an XML-RPC response. This is NOT thread safe.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ * @since 1.2
+ */
+public class XmlRpcResponseProcessor
+{
+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    /**
+     * Creates a new instance.
+     */
+    public XmlRpcResponseProcessor()
+    {
+    }
+
+    /**
+     * Process a successful response, and return output in the
+     * specified encoding.
+     *
+     * @param responseParam The response to process.
+     * @param encoding The output encoding.
+     * @return byte[] The XML-RPC response.
+     */
+    public byte[] encodeResponse(Object responseParam, String encoding)
+        throws IOException, UnsupportedEncodingException, XmlRpcException
+    {
+        long now = 0;
+        if (XmlRpc.debug)
+        {
+            now = System.currentTimeMillis();
+        }
+
+        try
+        {
+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+            XmlWriter writer = new XmlWriter(buffer, encoding);
+            writeResponse(responseParam, writer);
+            writer.flush();
+            return buffer.toByteArray();
+        }
+        finally
+        {
+            if (XmlRpc.debug)
+            {
+                System.out.println("Spent " + (System.currentTimeMillis() - now)
+                        + " millis encoding response");
+            }
+        }
+    }
+
+    /**
+     * Process an exception, and return output in the specified
+     * encoding.
+     *
+     * @param e The exception to process;
+     * @param encoding The output encoding.
+     * @param code The XML-RPC faultCode.
+     * @return byte[] The XML-RPC response.
+     */
+    public byte[] encodeException(Exception x, String encoding, int code)
+    {
+        if (XmlRpc.debug)
+        {
+            x.printStackTrace();
+        }
+        // Ensure that if there is anything in the buffer, it
+        // is cleared before continuing with the writing of exceptions.
+        // It is possible that something is in the buffer
+        // if there were an exception during the writeResponse()
+        // call above.
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+
+        XmlWriter writer = null;
+        try
+        {
+            writer = new XmlWriter(buffer, encoding);
+        }
+        catch (UnsupportedEncodingException encx)
+        {
+            System.err.println("XmlRpcServer attempted to use "
+                    + "unsupported encoding: " + encx);
+            // NOTE: If we weren't already using the default
+            // encoding, we could try it here.
+        }
+        catch (IOException iox)
+        {
+            System.err.println("XmlRpcServer experienced I/O error "
+                    + "writing error response: " + iox);
+        }
+
+        String message = x.toString();
+        // Retrieve XmlRpcException error code(if possible).
+        try
+        {
+            writeError(code, message, writer);
+            writer.flush();
+        }
+        catch (Exception e)
+        {
+            // Unlikely to occur, as we just sent a struct
+            // with an int and a string.
+            System.err.println("Unable to send error response to "
+                    + "client: " + e);
+        }
+
+        return (writer != null ? buffer.toByteArray() : EMPTY_BYTE_ARRAY);
+    }
+
+     /**
+     * Process an exception, and return output in the specified
+     * encoding.
+     *
+     * @param e The exception to process;
+     * @param encoding The output encoding.
+     * @return byte[] The XML-RPC response.
+     */
+    public byte[] encodeException(Exception x, String encoding)
+    {
+        return encodeException(x, encoding, (x instanceof XmlRpcException) ? ((XmlRpcException) x).code : 0);
+    }
+     /**
+      * Writes an XML-RPC response to the XML writer.
+      */
+    void writeResponse(Object param, XmlWriter writer)
+        throws XmlRpcException, IOException
+    {
+        writer.startElement("methodResponse");
+        // if (param == null) param = ""; // workaround for Frontier bug
+        writer.startElement("params");
+        writer.startElement("param");
+        writer.writeObject(param);
+        writer.endElement("param");
+        writer.endElement("params");
+        writer.endElement("methodResponse");
+    }
+
+    /**
+     * Writes an XML-RPC error response to the XML writer.
+     */
+    void writeError(int code, String message, XmlWriter writer)
+        throws XmlRpcException, IOException
+    {
+        // System.err.println("error: "+message);
+        Hashtable h = new Hashtable();
+        h.put("faultCode", new Integer(code));
+        h.put("faultString", message);
+        writer.startElement("methodResponse");
+        writer.startElement("fault");
+        writer.writeObject(h);
+        writer.endElement("fault");
+        writer.endElement("methodResponse");
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcServer.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.InputStream;
+import java.util.EmptyStackException;
+import java.util.Stack;
+
+/**
+ * A multithreaded, reusable XML-RPC server object. The name may be misleading
+ * because this does not open any server sockets. Instead it is fed by passing
+ * an XML-RPC input stream to the execute method. If you want to open a
+ * HTTP listener, use the WebServer class instead.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ */
+public class XmlRpcServer
+{
+    private Stack pool;
+    private int nbrWorkers;
+
+    /**
+     * The maximum number of threads which can be used concurrently, by defaut use the one defined
+     * in XmlRpc
+     */
+    private int maxThreads = -1;
+
+    /**
+     * We want the <code>$default</code> handler to always be
+     * available.
+     */
+    private DefaultHandlerMapping handlerMapping;
+
+    /**
+     * Construct a new XML-RPC server. You have to register handlers
+     * to make it do something useful.
+     */
+    public XmlRpcServer()
+    {
+        pool = new Stack();
+        nbrWorkers = 0;
+        handlerMapping = new DefaultHandlerMapping();
+    }
+
+    /**
+     * @see org.apache.xmlrpc.DefaultHandlerMapping#addHandler(String, Object)
+     */
+    public void addHandler(String handlerName, Object handler)
+    {
+        handlerMapping.addHandler(handlerName, handler);
+    }
+
+    /**
+     * @see org.apache.xmlrpc.DefaultHandlerMapping#removeHandler(String)
+     */
+    public void removeHandler(String handlerName)
+    {
+        handlerMapping.removeHandler(handlerName);
+    }
+
+    /**
+     * Return the current XmlRpcHandlerMapping.
+     */
+    public XmlRpcHandlerMapping getHandlerMapping()
+    {
+        return handlerMapping;
+    }
+
+    /**
+     * Set the MaxThreads for this Client
+     */
+    public void setMaxThreads(int maxThreads) 
+    {
+    	this.maxThreads = maxThreads;
+    }
+    
+    /**
+     * Get the MaxThreads for this Server
+     */
+    public int getMaxThreads() 
+    {
+    	if (maxThreads == -1)
+    		return (XmlRpc.getMaxThreads());
+    	
+    	return (maxThreads);
+    }
+    
+    /**
+     * Parse the request and execute the handler method, if one is
+     * found. Returns the result as XML.  The calling Java code
+     * doesn't need to know whether the call was successful or not
+     * since this is all packed into the response. No context information
+     * is passed.
+     */
+    public byte[] execute(InputStream is)
+    {
+        return execute(is, new DefaultXmlRpcContext(null, null, getHandlerMapping()));
+    }
+
+    /**
+     * Parse the request and execute the handler method, if one is
+     * found. If the invoked handler is AuthenticatedXmlRpcHandler,
+     * use the credentials to authenticate the user. No context information
+     * is passed.
+     */
+    public byte[] execute(InputStream is, String user, String password)
+    {
+        return execute(is, new DefaultXmlRpcContext(user, password, getHandlerMapping()));
+    }
+    
+    /**
+     * Parse the request and execute the handler method, if one is
+     * found. If the invoked handler is AuthenticatedXmlRpcHandler,
+     * use the credentials to authenticate the user. Context information
+     * is passed to the worker, and may be passed to the request handler.
+     */
+    public byte[] execute(InputStream is, XmlRpcContext context)
+    {
+        XmlRpcWorker worker = getWorker();
+        try
+        {
+            return worker.execute(is, context);
+        }
+        finally
+        {
+            pool.push(worker);
+        }
+    }
+
+    /**
+     * Hands out pooled workers.
+     *
+     * @return A worker (never <code>null</code>).
+     * @throws RuntimeException If the server exceeds its maximum
+     * number of allowed requests.
+     */
+    protected XmlRpcWorker getWorker()
+    {
+        try
+        {
+            return (XmlRpcWorker) pool.pop();
+        }
+        catch(EmptyStackException x)
+        {
+            int maxThreads = getMaxThreads();
+            if (nbrWorkers < maxThreads)
+            {
+                nbrWorkers += 1;
+                if (nbrWorkers >= maxThreads * .95)
+                {
+                    System.out.println("95% of XML-RPC server threads in use");
+                }
+                return createWorker();
+            }
+            throw new RuntimeException("System overload: Maximum number of " +
+                                       "concurrent requests (" + maxThreads +
+                                       ") exceeded");
+        }
+    }
+
+    protected XmlRpcWorker createWorker()
+    {
+        return new XmlRpcWorker(handlerMapping);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcServerRequest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Vector;
+
+/**
+ * Interface to an XML-RPC request made to the server.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcServerRequest.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public interface XmlRpcServerRequest
+{
+    public Vector getParameters();
+    public Object getParameter(int index);
+    public String getMethodName();
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcTransport.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.InputStream;
+import java.io.IOException;
+
+/**
+ * Interface from XML-RPC to an underlying transport, most likely base on HTTP.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcTransport.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public interface XmlRpcTransport
+{
+  /**
+   * Send an XML-RPC message. This method is called to send a message to the
+   * other party.
+   *
+   * @param request the request in network encoding.
+   *
+   * @throws IOException if an IOException occurs in the IO level of the transport.
+   * @throws XmlRpcClientException if an exception occurs in the transport.
+   */
+  public InputStream sendXmlRpc(byte [] request)
+  throws IOException, XmlRpcClientException;
+
+  /**
+   * End an XML-RPC request. This method is called by the XmlRpcClient when then
+   * request has been sent and the response (or an exception) recieved.
+   *
+   * @throws XmlRpcClientException if an exception occurs in the transport.
+   */
+  public void endClientRequest()
+  throws XmlRpcClientException;
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcTransportFactory.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.util.Properties;
+
+/**
+ * Interface from XML-RPC to an underlying transport, most likely base on HTTP.
+ *
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: XmlRpcTransportFactory.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ *
+ * Constructors for SSL implementations of XmlRpcTransportFactory should have a constructor
+ * with a signature defined by CONSTRUCTOR_SIGNATURE:
+ * <code>
+ * ClassName(Properties properties)
+ * </code>
+ *
+ * and use the default properties defined in this interface.
+ */
+public interface XmlRpcTransportFactory
+{
+    public static final String TRANSPORT_URL  = "url"; // Name of property containing URL
+    public static final String TRANSPORT_AUTH = "auth"; // Name of property containing Basic Authentication information
+
+    public static final Class [] CONSTRUCTOR_SIGNATURE = new Class [] { Properties.class };
+    public static final String CONSTRUCTOR_SIGNATURE_STRING = "(java.util.Properties properties)";
+
+    /**
+     * Create a new XML-RPC transport.
+     *
+     * @return XmlRpcTransport an instance created according to the rules
+     * specified to the constructor.
+     */
+    public XmlRpcTransport createTransport()
+    throws XmlRpcClientException;
+
+    /**
+     * Set a property for all newly created transports.
+     *
+     * @param propertyName the property to set.
+     * @param value the value to set it to.
+     */
+    public void setProperty(String propertyName, Object value);
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlRpcWorker.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.InputStream;
+
+/**
+ * Tie together the XmlRequestProcessor and XmlResponseProcessor to handle
+ * a request serially in a single thread.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @see org.apache.xmlrpc.XmlRpcServer
+ * @since 1.2
+ */
+public class XmlRpcWorker
+{
+    protected XmlRpcRequestProcessor requestProcessor;
+    protected XmlRpcResponseProcessor responseProcessor;
+    protected XmlRpcHandlerMapping handlerMapping;
+
+    /**
+     * Create a new instance that will use the specified mapping.
+     */
+    public XmlRpcWorker(XmlRpcHandlerMapping handlerMapping)
+    {
+      requestProcessor = new XmlRpcRequestProcessor();
+      responseProcessor = new XmlRpcResponseProcessor();
+      this.handlerMapping = handlerMapping;
+    }
+
+    /**
+     * Pass the specified request to the handler. The handler should be an
+     * instance of {@link org.apache.xmlrpc.XmlRpcHandler} or
+     * {@link org.apache.xmlrpc.AuthenticatedXmlRpcHandler}.
+     *
+     * @param handler the handler to call.
+     * @param request the request information to use.
+     * @param context the context information to use.
+     * @return Object the result of calling the handler.
+     * @throws ClassCastException if the handler is not of an appropriate type.
+     * @throws NullPointerException if the handler is null.
+     * @throws Exception if the handler throws an exception.
+     */
+    protected static Object invokeHandler(Object handler, XmlRpcServerRequest request, XmlRpcContext context)
+        throws Exception
+    {
+        long now = 0;
+
+        try
+        {
+            if (XmlRpc.debug)
+            {
+                now = System.currentTimeMillis();
+            }
+            if (handler == null)
+            {
+              throw new NullPointerException
+                  ("Null handler passed to XmlRpcWorker.invokeHandler");
+            }
+            else if (handler instanceof ContextXmlRpcHandler)
+            {
+                return ((ContextXmlRpcHandler) handler).execute
+                    (request.getMethodName(), request.getParameters(), context);
+            }
+            else if (handler instanceof XmlRpcHandler)
+            {
+                return ((XmlRpcHandler) handler).execute
+                    (request.getMethodName(), request.getParameters());
+            }
+            else if (handler instanceof AuthenticatedXmlRpcHandler)
+            {
+                return ((AuthenticatedXmlRpcHandler) handler)
+                    .execute(request.getMethodName(), request.getParameters(),
+                             context.getUserName(), context.getPassword());
+            }
+            else
+            {
+               throw new ClassCastException("Handler class " +
+                                            handler.getClass().getName() +
+                                            " is not a valid XML-RPC handler");
+            }
+        }
+        finally
+        {
+            if (XmlRpc.debug)
+            {
+                 System.out.println("Spent " + (System.currentTimeMillis() - now)
+                         + " millis processing request");
+            }
+        }
+    }
+
+    /**
+     * Decode, process and encode the response or exception for an XML-RPC
+     * request. This method executes the handler method with the default context.
+     */
+    public byte[] execute(InputStream is, String user, String password)
+    {
+        return execute(is, defaultContext(user, password));
+    }
+
+    /**
+     * Decode, process and encode the response or exception for an XML-RPC
+     * request. This method executes will pass the specified context to the
+     * handler if the handler supports context.
+     *
+     * @param is the InputStream to read the request from.
+     * @param context the context for the request (may be null).
+     * @return byte[] the response.
+     * @throws org.apache.xmlrpc.ParseFailed if the request could not be parsed.
+     * @throws org.apache.xmlrpc.AuthenticationFailed if the handler for the
+     * specific method required authentication and insufficient credentials were
+     * supplied.
+     */
+    public byte[] execute(InputStream is, XmlRpcContext context)
+    {
+        long now = 0;
+
+        if (XmlRpc.debug)
+        {
+            now = System.currentTimeMillis();
+        }
+
+        try
+        {
+            XmlRpcServerRequest request = requestProcessor.decodeRequest(is);
+            Object handler = handlerMapping.getHandler(request.
+                                                       getMethodName());
+            Object response = invokeHandler(handler, request, context);
+            return responseProcessor.encodeResponse
+                (response, requestProcessor.getEncoding());
+        }
+        catch (AuthenticationFailed alertCallerAuth)
+        {
+            throw alertCallerAuth;
+        }
+        catch (ParseFailed alertCallerParse)
+        {
+            throw alertCallerParse;
+        }
+        catch (Exception x)
+        {
+            if (XmlRpc.debug)
+            {
+                x.printStackTrace();
+            }
+            return responseProcessor.encodeException
+                (x, requestProcessor.getEncoding());
+        }
+        finally
+        {
+            if (XmlRpc.debug)
+            {
+                System.out.println("Spent " + (System.currentTimeMillis() - now)
+                                   + " millis in request/process/response");
+            }
+        }
+    }
+
+    /**
+     * Factory method to return a default context object for the execute() method.
+     * This method can be overridden to return a custom sub-class of XmlRpcContext.
+     *
+     * @param user the username of the user making the request.
+     * @param password the password of the user making the request.
+     * @return XmlRpcContext the context for the reqeust.
+     */
+    protected XmlRpcContext defaultContext(String user, String password)
+    {
+        return new DefaultXmlRpcContext(user, password, handlerMapping);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/XmlWriter.java
@@ -0,0 +1,476 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Properties;
+import java.util.Vector;
+
+import org.apache.xmlrpc.util.DateTool;
+import org.apache.commons.codec.binary.Base64;
+import org.apache.commons.codec.EncoderException;
+
+/**
+ * A XML writer intended for single-thread usage.  If you feed it a
+ * <code>ByteArrayInputStream</code>, it may be necessary to call
+ * <code>writer.flush()</code> before calling
+ * <code>buffer.toByteArray()</code> to get the data written to
+ * your byte buffer.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ * @see <a href="http://www.xml.com/axml/testaxml.htm">Tim Bray's
+ * Annotated XML Spec</a>
+ */
+class XmlWriter extends OutputStreamWriter
+{
+    // Various XML pieces.
+    protected static final String PROLOG_START = "<?xml version=\"1.0";
+    protected static final String PROLOG_END = "\"?>";
+    protected static final String CLOSING_TAG_START = "</";
+    protected static final String SINGLE_TAG_END = "/>";
+    protected static final String LESS_THAN_ENTITY = "&lt;";
+    protected static final String GREATER_THAN_ENTITY = "&gt;";
+    protected static final String AMPERSAND_ENTITY = "&amp;";
+
+    private static final char[] PROLOG =
+        new char[PROLOG_START.length() + PROLOG_END.length()];
+    static
+    {
+        int len = PROLOG_START.length();
+        PROLOG_START.getChars(0, len, PROLOG, 0);
+        PROLOG_END.getChars(0, PROLOG_END.length(), PROLOG, len);
+    }
+
+    /**
+     * Java's name for the ISO-8859-1 encoding.
+     */
+    static final String ISO8859_1 = "ISO8859_1";
+
+    /**
+     * Java's name for the UTF-8 encoding.
+     */
+    static final String UTF8 = "UTF8";
+
+    /**
+     * Java's name for the UTF-16 encoding.
+     */
+    static final String UTF16 = "UTF-16";
+    
+    protected static final Base64 base64Codec = new Base64();
+
+    /**
+     * Class to delegate type decoding to.
+     */
+    protected static TypeDecoder typeDecoder;
+
+    /**
+     * Mapping between Java encoding names and "real" names used in
+     * XML prolog.
+     *
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/guide/intl/encoding.doc.html">Java character set names</a>
+     */
+    private static Properties encodings = new Properties();
+
+    static
+    {
+        encodings.put(UTF8, "UTF-8");
+        encodings.put(ISO8859_1, "ISO-8859-1");
+        typeDecoder = new DefaultTypeDecoder();
+    }
+
+    /**
+     * Thread-safe wrapper for the <code>DateFormat</code> object used
+     * to parse date/time values.
+     */
+    DateTool dateTool = new DateTool();
+
+    /**
+     * Whether the XML prolog has been written.
+     */
+    boolean hasWrittenProlog = false;
+
+    /**
+     * Creates a new instance.
+     *
+     * @param out The stream to write output to.
+     * @param enc The encoding to using for outputing XML.  Only UTF-8
+     * and UTF-16 are supported.  If another encoding is specified,
+     * UTF-8 will be used instead for widest XML parser
+     * interoperability.
+     * @exception UnsupportedEncodingException Since unsupported
+     * encodings are internally converted to UTF-8, this should only
+     * be seen as the result of an internal error.
+     */
+    public XmlWriter(OutputStream out, String enc)
+        throws UnsupportedEncodingException
+    {
+        // Super-class wants the Java form of the encoding.
+        super(out, forceUnicode(enc));
+    }
+
+    /**
+     * @param encoding A caller-specified encoding.
+     * @return An Unicode encoding.
+     */
+    private static String forceUnicode(String encoding)
+    {
+        if (encoding == null || !encoding.toUpperCase().startsWith("UTF"))
+        {
+            encoding = UTF8;
+        }
+        return encoding;
+    }
+
+    /**
+     * Tranforms a Java encoding to the canonical XML form (if a
+     * mapping is available).
+     *
+     * @param javaEncoding The name of the encoding as known by Java.
+     * @return The XML encoding (if a mapping is available);
+     * otherwise, the encoding as provided.
+     *
+     * @deprecated This method will not be visible in 2.0.
+     */
+    protected static String canonicalizeEncoding(String javaEncoding)
+    {
+        return encodings.getProperty(javaEncoding, javaEncoding);
+    }
+
+    /**
+     * A mostly pass-through implementation wrapping
+     * <code>OutputStreamWriter.write()</code> which assures that the
+     * XML prolog is written before any other data.
+     *
+     * @see java.io.OutputStreamWriter.write(char[], int, int)
+     */
+    public void write(char[] cbuf, int off, int len)
+        throws IOException
+    {
+        if (!hasWrittenProlog)
+        {
+            super.write(PROLOG, 0, PROLOG.length);
+            hasWrittenProlog = true;
+        }
+        super.write(cbuf, off, len);
+    }
+
+    /**
+     * A mostly pass-through implementation wrapping
+     * <code>OutputStreamWriter.write()</code> which assures that the
+     * XML prolog is written before any other data.
+     *
+     * @see java.io.OutputStreamWriter.write(char)
+     */
+    public void write(char c)
+        throws IOException
+    {
+        if (!hasWrittenProlog)
+        {
+            super.write(PROLOG, 0, PROLOG.length);
+            hasWrittenProlog = true;
+        }
+        super.write(c);
+    }
+
+    /**
+     * A mostly pass-through implementation wrapping
+     * <code>OutputStreamWriter.write()</code> which assures that the
+     * XML prolog is written before any other data.
+     *
+     * @see java.io.OutputStreamWriter.write(String, int, int)
+     */
+    public void write(String str, int off, int len)
+        throws IOException
+    {
+        if (!hasWrittenProlog)
+        {
+            super.write(PROLOG, 0, PROLOG.length);
+            hasWrittenProlog = true;
+        }
+        super.write(str, off, len);
+    }
+
+    /**
+     * Writes the XML representation of a supported Java object type.
+     *
+     * @param obj The <code>Object</code> to write.
+     * @exception XmlRpcException Unsupported character data found.
+     * @exception IOException Problem writing data.
+     * @throws IllegalArgumentException If a <code>null</code>
+     * parameter is passed to this method (not supported by the <a
+     * href="http://xml-rpc.com/spec">XML-RPC specification</a>).
+     */
+    public void writeObject(Object obj)
+        throws XmlRpcException, IOException
+    {
+        startElement("value");
+        if (obj == null)
+        {
+            throw new XmlRpcException
+                (0, "null values not supported by XML-RPC");
+        }
+        else if (obj instanceof String)
+        {
+            chardata(obj.toString());
+        }
+        else if (typeDecoder.isXmlRpcI4(obj))
+        {
+            startElement("int");
+            write(obj.toString());
+            endElement("int");
+        }
+        else if (obj instanceof Boolean)
+        {
+            startElement("boolean");
+            write(((Boolean) obj).booleanValue() ? "1" : "0");
+            endElement("boolean");
+        }
+        else if (typeDecoder.isXmlRpcDouble(obj))
+        {
+            startElement("double");
+            write(obj.toString());
+            endElement("double");
+        }
+        else if (obj instanceof Date)
+        {
+            startElement("dateTime.iso8601");
+            Date d = (Date) obj;
+            write(dateTool.format(d));
+            endElement("dateTime.iso8601");
+        }
+        else if (obj instanceof byte[])
+        {
+            startElement("base64");
+            try
+            {
+                this.write((byte[]) base64Codec.encode(obj));
+            }
+            catch (EncoderException e)
+            {
+                throw new XmlRpcException
+                    (0, "Unable to Base 64 encode byte array", e);
+            }
+            endElement("base64");
+        }
+        else if (obj instanceof Object[])
+        {
+            startElement("array");
+            startElement("data");
+            Object[] array = (Object []) obj;
+            for (int i = 0; i < array.length; i++)
+            {
+                writeObject(array[i]);
+            }
+            endElement("data");
+            endElement("array");
+        }
+        else if (obj instanceof Vector)
+        {
+            startElement("array");
+            startElement("data");
+            Vector array = (Vector) obj;
+            int size = array.size();
+            for (int i = 0; i < size; i++)
+            {
+                writeObject(array.elementAt(i));
+            }
+            endElement("data");
+            endElement("array");
+        }
+        else if (obj instanceof Hashtable)
+        {
+            startElement("struct");
+            Hashtable struct = (Hashtable) obj;
+            for (Enumeration e = struct.keys(); e.hasMoreElements(); )
+            {
+                String key = (String) e.nextElement();
+                Object value = struct.get(key);
+                startElement("member");
+                startElement("name");
+                chardata(key);
+                endElement("name");
+                writeObject(value);
+                endElement("member");
+            }
+            endElement("struct");
+        }
+        else
+        {
+            throw new XmlRpcException(0, "Unsupported Java type: "
+                                       + obj.getClass(), null);
+        }
+        endElement("value");
+    }
+
+    /**
+     * This is used to write out the Base64 output...
+     */
+    protected void write(byte[] byteData) throws IOException
+    {
+        for (int i = 0; i < byteData.length; i++)
+        {
+            write(byteData[i]);
+        }
+    }
+
+    /**
+     * Writes characters like '\r' (0xd) as "&amp;#13;".
+     */
+    private void writeCharacterReference(char c)
+        throws IOException
+    {
+        write("&#");
+        write(String.valueOf((int) c));
+        write(';');
+    }
+
+    /**
+     *
+     * @param elem
+     * @throws IOException
+     */
+    protected void startElement(String elem) throws IOException
+    {
+        write('<');
+        write(elem);
+        write('>');
+    }
+
+    /**
+     *
+     * @param elem
+     * @throws IOException
+     */
+    protected void endElement(String elem) throws IOException
+    {
+        write(CLOSING_TAG_START);
+        write(elem);
+        write('>');
+    }
+
+    /**
+     *
+     * @param elem
+     * @throws IOException
+     */
+    protected void emptyElement(String elem) throws IOException
+    {
+        write('<');
+        write(elem);
+        write(SINGLE_TAG_END);
+    }
+
+    /**
+     * Writes text as <code>PCDATA</code>.
+     *
+     * @param text The data to write.
+     * @exception XmlRpcException Unsupported character data found.
+     * @exception IOException Problem writing data.
+     */
+    protected void chardata(String text)
+        throws XmlRpcException, IOException
+    {
+        int l = text.length ();
+        // ### TODO: Use a buffer rather than going character by
+        // ### character to scale better for large text sizes.
+        //char[] buf = new char[32];
+        for (int i = 0; i < l; i++)
+        {
+            char c = text.charAt (i);
+            switch (c)
+            {
+            case '\t':
+            case '\n':
+                write(c);
+                break;
+            case '\r':
+                // Avoid normalization of CR to LF.
+                writeCharacterReference(c);
+                break;
+            case '<':
+                write(LESS_THAN_ENTITY);
+                break;
+            case '>':
+                write(GREATER_THAN_ENTITY);
+                break;
+            case '&':
+                write(AMPERSAND_ENTITY);
+                break;
+            default:
+                // Though the XML spec requires XML parsers to support
+                // Unicode, not all such code points are valid in XML
+                // documents.  Additionally, previous to 2003-06-30
+                // the XML-RPC spec only allowed ASCII data (in
+                // <string> elements).  For interoperability with
+                // clients rigidly conforming to the pre-2003 version
+                // of the XML-RPC spec, we entity encode characters
+                // outside of the valid range for ASCII, too.
+                if (c > 0x7f || !isValidXMLChar(c))
+                {
+                    // Replace the code point with a character reference.
+                    writeCharacterReference(c);
+                }
+                else
+                {
+                    write(c);
+                }
+            }
+        }
+    }
+
+    /**
+     * Section 2.2 of the XML spec describes which Unicode code points
+     * are valid in XML:
+     *
+     * <blockquote><code>#x9 | #xA | #xD | [#x20-#xD7FF] |
+     * [#xE000-#xFFFD] | [#x10000-#x10FFFF]</code></blockquote>
+     *
+     * Code points outside this set must be entity encoded to be
+     * represented in XML.
+     *
+     * @param c The character to inspect.
+     * @return Whether the specified character is valid in XML.
+     */
+    private static final boolean isValidXMLChar(char c)
+    {
+        switch (c)
+        {
+        case 0x9:
+        case 0xa:  // line feed, '\n'
+        case 0xd:  // carriage return, '\r'
+            return true;
+
+        default:
+            return ( (0x20 <= c && c <= 0xd7ff) ||
+                     (0xe000 <= c && c <= 0xfffd) ||
+                     (0x10000 <= c && c <= 0x10ffff) );
+        }
+    }
+
+    protected static void setTypeDecoder(TypeDecoder newTypeDecoder)
+    {
+        typeDecoder = newTypeDecoder;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/applet/JSXmlRpcApplet.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.applet;
+
+import java.util.Date;
+import java.util.Hashtable;
+import java.util.Vector;
+
+
+/**
+ * An applet that can be accessed via LiveConnect from JavaScript. It provides
+ * methods for adding arguments and triggering method execution for XML-RPC
+ * requests. This works on recent Netscape 4.x browsers as well as Internet
+ * Explorer 4.0 on Windows 95/NT, but not on IE/Mac. <p>
+ *
+ * Results from XML-RPC calls are exposed to JavaScript as the are, i.e.
+ * &lt;structs>s are <a href=http://java.sun.com/products/jdk/1.1/docs/api/java.util.Hashtable.html>Hashtables</a>
+ * and &lt;array>s are <a href=http://java.sun.com/products/jdk/1.1/docs/api/java.util.Vector.html>Vectors</a>
+ * and can be accessed thru their public methods. It seems like Date objects are
+ * not converted properly between JavaScript and Java, so the dateArg methods
+ * take long values instead of Date objects as parameters (date.getTime()).
+ *
+ * @version $Id: JSXmlRpcApplet.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class JSXmlRpcApplet extends XmlRpcApplet
+{
+    public Object loaded = null;
+
+    private String errorMessage;
+    private Vector arguments;
+
+    /**
+     *
+     */
+    public void init()
+    {
+        initClient();
+        arguments = new Vector();
+        loaded = Boolean.TRUE;
+        System.out.println("JSXmlRpcApplet initialized");
+    }
+
+    // add ints (primitve != object) to structs, vectors
+    public void addIntArg(int value)
+    {
+        arguments.addElement(new Integer(value));
+    }
+
+    public void addIntArgToStruct(Hashtable struct, String key, int value)
+    {
+        struct.put(key, new Integer(value));
+    }
+
+    public void addIntArgToArray(Vector ary, int value)
+    {
+        ary.addElement(new Integer(value));
+    }
+
+    // add floats/doubles to structs, vectors
+    public void addDoubleArg(float value)
+    {
+        arguments.addElement(new Double(value));
+    }
+
+    public void addDoubleArgToStruct(Hashtable struct, String key, float value)
+    {
+        struct.put(key, new Double(value));
+    }
+
+    public void addDoubleArgToArray(Vector ary, float value)
+    {
+        ary.addElement(new Double(value));
+    }
+
+    public void addDoubleArg(double value)
+    {
+        arguments.addElement(new Double(value));
+    }
+
+    public void addDoubleArgToStruct(Hashtable struct, String key, double value)
+    {
+        struct.put(key, new Double(value));
+    }
+
+    public void addDoubleArgToArray(Vector ary, double value)
+    {
+        ary.addElement(new Double(value));
+    }
+
+    // add bools to structs, vectors
+    public void addBooleanArg(boolean value)
+    {
+        arguments.addElement(new Boolean(value));
+    }
+
+    public void addBooleanArgToStruct(Hashtable struct, String key,
+            boolean value)
+    {
+        struct.put(key, new Boolean(value));
+    }
+
+    public void addBooleanArgToArray(Vector ary, boolean value)
+    {
+        ary.addElement(new Boolean(value));
+    }
+
+    // add Dates to structs, vectors Date argument in SystemTimeMillis (seems to be the way)
+    public void addDateArg(long dateNo)
+    {
+        arguments.addElement(new Date(dateNo));
+    }
+
+    public void addDateArgToStruct(Hashtable struct, String key, long dateNo)
+    {
+        struct.put(key, new Date(dateNo));
+    }
+
+    public void addDateArgToArray(Vector ary, long dateNo)
+    {
+        ary.addElement(new Date(dateNo));
+    }
+
+    // add String arguments
+    public void addStringArg(String str)
+    {
+        arguments.addElement(str);
+    }
+
+    public void addStringArgToStruct(Hashtable struct, String key, String str)
+    {
+        struct.put(key, str);
+    }
+
+    public void addStringArgToArray(Vector ary, String str)
+    {
+        ary.addElement (str);
+    }
+
+    // add Array arguments
+    public Vector addArrayArg()
+    {
+        Vector v = new Vector();
+        arguments.addElement(v);
+        return v;
+    }
+
+    public Vector addArrayArgToStruct(Hashtable struct, String key)
+    {
+        Vector v = new Vector();
+        struct.put(key, v);
+        return v;
+    }
+
+    public Vector addArrayArgToArray(Vector ary)
+    {
+        Vector v = new Vector();
+        ary.addElement(v);
+        return v;
+    }
+
+    // add Struct arguments
+    public Hashtable addStructArg()
+    {
+        Hashtable ht = new Hashtable();
+        arguments.addElement(ht);
+        return ht;
+    }
+
+    public Hashtable addStructArgToStruct(Hashtable struct, String key)
+    {
+        Hashtable ht = new Hashtable();
+        struct.put(key, ht);
+        return ht;
+    }
+
+    public Hashtable addStructArgToArray(Vector ary)
+    {
+        Hashtable ht = new Hashtable();
+        ary.addElement(ht);
+        return ht;
+    }
+
+    // get the errorMessage, null if none
+    public String getErrorMessage()
+    {
+        return errorMessage;
+    }
+
+    public void reset()
+    {
+        arguments = new Vector();
+    }
+
+    public Object execute(String methodName)
+    {
+        // XmlRpcSupport.setDebug (true);
+        errorMessage = null;
+        showStatus("Connecting to Server...");
+        Object returnValue = null;
+        try
+        {
+            returnValue = execute(methodName, arguments);
+        }
+        catch (Exception e)
+        {
+            errorMessage = e.getMessage();
+            if (errorMessage == null || errorMessage == "")
+            {
+                errorMessage = e.toString();
+            }
+        }
+        // reset argument array for reuse
+        arguments = new Vector();
+
+        showStatus("");
+        return returnValue;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/applet/SimpleXmlRpcClient.java
@@ -0,0 +1,793 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.applet;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Stack;
+import java.util.Vector;
+import org.apache.commons.codec.binary.Base64;
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.EncoderException;
+import org.xml.sax.AttributeList;
+import org.xml.sax.HandlerBase;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+import uk.co.wilson.xml.MinML;
+
+/**
+ * A simple XML-RPC client.
+ *
+ * FIXME: This code is VERY out of date with the rest of the package.
+ *
+ * @version $Id: SimpleXmlRpcClient.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class SimpleXmlRpcClient
+{
+    URL url;
+
+    /**
+     * Construct a XML-RPC client with this URL.
+     */
+    public SimpleXmlRpcClient(URL url)
+    {
+        this.url = url;
+    }
+
+    /**
+     * Construct a XML-RPC client for the URL represented by this String.
+     */
+    public SimpleXmlRpcClient(String url) throws MalformedURLException
+    {
+        this.url = new URL(url);
+    }
+
+    /**
+     * Construct a XML-RPC client for the specified hostname and port.
+     */
+    public SimpleXmlRpcClient(String hostname, int port)
+            throws MalformedURLException
+    {
+        this.url = new URL("http://" + hostname + ":" + port + "/RPC2");
+    }
+    
+    /**
+     *
+     * @param method
+     * @param params
+     * @return
+     * @throws XmlRpcException
+     * @throws IOException
+     */
+    public Object execute(String method, Vector params)
+            throws XmlRpcException, IOException
+    {
+        return new XmlRpcSupport (url).execute (method, params);
+    }
+}
+
+/**
+ * FIXME: Leverage the XmlRpc class.
+ */
+class XmlRpcSupport extends HandlerBase
+{
+
+    URL url;
+    String methodName;
+    boolean fault = false;
+    Object result = null;
+    
+    Base64 base64 = new Base64();
+
+    // the stack we're parsing our values into.
+    Stack values;
+    Value currentValue;
+
+    boolean readCdata;
+
+    // formats for parsing and generating dateTime values
+    static final DateFormat format = new SimpleDateFormat("yyyyMMdd'T'HH:mm:ss");
+
+    // used to collect character data of parameter values
+    StringBuffer cdata = new StringBuffer ();
+
+    // XML RPC parameter types used for dataMode
+    static final int STRING = 0;
+    static final int INTEGER = 1;
+    static final int BOOLEAN = 2;
+    static final int DOUBLE = 3;
+    static final int DATE = 4;
+    static final int BASE64 = 5;
+    static final int STRUCT = 6;
+    static final int ARRAY = 7;
+
+    // for debugging output
+    public static boolean debug = false;
+    final static String types[] = {"String", "Integer", "Boolean", "Double",
+            "Date", "Base64", "Struct", "Array"};
+
+
+    /**
+     *
+     * @param url
+     */
+    public XmlRpcSupport(URL url)
+    {
+        this.url = url;
+    }
+
+    /**
+     * Switch debugging output on/off.
+     */
+    public static void setDebug(boolean val)
+    {
+        debug = val;
+    }
+
+    /**
+     * Parse the input stream. For each root level object, method
+     * <code>objectParsed</code> is called.
+     */
+    synchronized void parse(InputStream is) throws Exception
+    {
+        values = new Stack();
+        long now = System.currentTimeMillis();
+        MinML parser = new MinML();
+        parser.setDocumentHandler(this);
+        parser.setErrorHandler(this);
+
+        parser.parse(new InputSource(is));
+
+        if (debug)
+        {
+            System.out.println("Spent " + (System.currentTimeMillis() - now)
+                    + " parsing");
+        }
+    }
+
+    /**
+     * Writes the XML representation of a supported Java object to the XML writer.
+     */
+    void writeObject (Object what, XmlWriter writer) throws IOException
+    {
+        writer.startElement("value");
+        if (what instanceof String)
+        {
+            writer.write(what.toString());
+        }
+        else if (what instanceof Integer)
+        {
+            writer.startElement("int");
+            writer.write (what.toString());
+            writer.endElement("int");
+        }
+        else if (what instanceof Boolean)
+        {
+            writer.startElement("boolean");
+            writer.write(((Boolean) what).booleanValue() ? "1" : "0");
+            writer.endElement("boolean");
+        }
+        else if (what instanceof Double)
+        {
+            writer.startElement("double");
+            writer.write (what.toString());
+            writer.endElement("double");
+        }
+        else if (what instanceof Date)
+        {
+            writer.startElement("dateTime.iso8601");
+            Date d = (Date) what;
+            writer.write(format.format(d));
+            writer.endElement("dateTime.iso8601");
+        }
+        else if (what instanceof byte[])
+        {
+            writer.startElement("base64");
+            try
+            {
+                writer.write((byte[]) base64.encode(what));
+            }
+            catch (EncoderException e)
+            {
+                throw new RuntimeException("Possibly incompatible version " +
+                                           "of '" + Base64.class.getName() +
+                                           "' used: " + e);
+            }
+            writer.endElement("base64");
+        }
+        else if (what instanceof Vector)
+        {
+            writer.startElement("array");
+            writer.startElement("data");
+            Vector v = (Vector) what;
+            int l2 = v.size();
+            for (int i2 = 0; i2 < l2; i2++)
+            {
+                writeObject(v.elementAt(i2), writer);
+            }
+            writer.endElement("data");
+            writer.endElement("array");
+        }
+        else if (what instanceof Hashtable)
+        {
+            writer.startElement("struct");
+            Hashtable h = (Hashtable) what;
+            for (Enumeration e = h.keys (); e.hasMoreElements (); )
+            {
+                String nextkey = (String) e.nextElement ();
+                Object nextval = h.get(nextkey);
+                writer.startElement("member");
+                writer.startElement("name");
+                writer.write(nextkey);
+                writer.endElement("name");
+                writeObject(nextval, writer);
+                writer.endElement("member");
+            }
+            writer.endElement("struct");
+        }
+        else
+        {
+            String unsupportedType = what == null ? "null"
+                    : what.getClass().toString();
+            throw new IOException("unsupported Java type: " + unsupportedType);
+        }
+        writer.endElement("value");
+    }
+
+    /**
+     * Generate an XML-RPC request and send it to the server. Parse the result
+     * and return the corresponding Java object.
+     *
+     * @exception XmlRpcException If the remote host returned a fault message.
+     * @exception IOException If the call could not be made for lower level
+     *          problems.
+     */
+    public Object execute(String method, Vector arguments)
+            throws XmlRpcException, IOException
+    {
+        fault = false;
+        long now = System.currentTimeMillis();
+        try
+        {
+            StringBuffer strbuf = new StringBuffer();
+            XmlWriter writer = new XmlWriter(strbuf);
+            writeRequest(writer, method, arguments);
+            byte[] request = strbuf.toString().getBytes();
+            URLConnection con = url.openConnection();
+            con.setDoOutput(true);
+            con.setDoInput(true);
+            con.setUseCaches(false);
+            con.setAllowUserInteraction(false);
+            con.setRequestProperty("Content-Length",
+                    Integer.toString(request.length));
+            con.setRequestProperty("Content-Type", "text/xml");
+            // con.connect ();
+            OutputStream out = con.getOutputStream();
+            out.write(request);
+            out.flush();
+            InputStream in = con.getInputStream();
+            parse(in);
+            System.out.println("result = " + result);
+        }
+        catch (Exception x)
+        {
+            x.printStackTrace();
+            throw new IOException(x.getMessage());
+        }
+        if (fault)
+        {
+            // generate an XmlRpcException
+            XmlRpcException exception = null;
+            try
+            {
+                Hashtable f = (Hashtable) result;
+                String faultString = (String) f.get("faultString");
+                int faultCode = Integer.parseInt(f.get("faultCode").toString());
+                exception = new XmlRpcException(faultCode, faultString.trim());
+            }
+            catch (Exception x)
+            {
+                throw new XmlRpcException(0, "Invalid fault response");
+            }
+            throw exception;
+        }
+        System.out.println("Spent " + (System.currentTimeMillis() - now)
+                + " in request");
+        return result;
+    }
+
+    /**
+     * Called when the return value has been parsed.
+     */
+    void objectParsed(Object what)
+    {
+        result = what;
+    }
+
+    /**
+     * Generate an XML-RPC request from a method name and a parameter vector.
+     */
+    void writeRequest (XmlWriter writer, String method, Vector params)
+            throws IOException
+    {
+        writer.startElement("methodCall");
+        writer.startElement("methodName");
+        writer.write(method);
+        writer.endElement("methodName");
+        writer.startElement("params");
+        int l = params.size();
+        for (int i = 0; i < l; i++)
+        {
+            writer.startElement("param");
+            writeObject(params.elementAt (i), writer);
+            writer.endElement("param");
+        }
+        writer.endElement("params");
+        writer.endElement("methodCall");
+    }
+
+    ////////////////////////////////////////////////////////////////
+    // methods called by XML parser
+
+    /**
+     * Method called by SAX driver.
+     */
+    public void characters(char ch[], int start, int length)
+            throws SAXException
+    {
+        if (! readCdata)
+        {
+            return;
+        }
+        cdata.append (ch, start, length);
+    }
+
+    /**
+     * Method called by SAX driver.
+     */
+    public void endElement(String name) throws SAXException
+    {
+        if (debug)
+        {
+            System.err.println("endElement: " + name);
+        }
+
+        // finalize character data, if appropriate
+        if (currentValue != null && readCdata)
+        {
+            currentValue.characterData(cdata.toString());
+            cdata.setLength(0);
+            readCdata = false;
+        }
+
+        if ("value".equals(name))
+        {
+            int depth = values.size();
+            // Only handle top level objects or objects contained in arrays here.
+            // For objects contained in structs, wait for </member> (see code below).
+            if (depth < 2 || values.elementAt (depth - 2).hashCode () != STRUCT)
+            {
+                Value v = currentValue;
+                values.pop();
+                if (depth < 2)
+                {
+                    // This is a top-level object
+                    objectParsed(v.value);
+                    currentValue = null;
+                }
+                else
+                {
+                    // add object to sub-array; if current container is a struct, add later (at </member>)
+                    currentValue = (Value) values.peek();
+                    currentValue.endElement(v);
+                }
+            }
+        }
+
+        // Handle objects contained in structs.
+        if ("member".equals(name))
+        {
+            Value v = currentValue;
+            values.pop();
+            currentValue = (Value) values.peek();
+            currentValue.endElement(v);
+        }
+
+        else if ("methodName".equals(name))
+        {
+            methodName = cdata.toString();
+            cdata.setLength(0);
+            readCdata = false;
+        }
+    }
+
+    /**
+     * Method called by SAX driver.
+     */
+    public void startElement (String name, AttributeList atts)
+            throws SAXException
+    {
+        if (debug)
+        {
+            System.err.println("startElement: " + name);
+        }
+
+        if ("value".equals(name))
+        {
+            // System.err.println ("starting value");
+            Value v = new Value();
+            values.push(v);
+            currentValue = v;
+            // cdata object is reused
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("methodName".equals(name))
+        {
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("name".equals(name))
+        {
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("string".equals(name))
+        {
+            // currentValue.setType (STRING);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("i4".equals(name) || "int".equals(name))
+        {
+            currentValue.setType(INTEGER);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("boolean".equals(name))
+        {
+            currentValue.setType(BOOLEAN);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("double".equals(name))
+        {
+            currentValue.setType(DOUBLE);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("dateTime.iso8601".equals(name))
+        {
+            currentValue.setType(DATE);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("base64".equals(name))
+        {
+            currentValue.setType(BASE64);
+            cdata.setLength(0);
+            readCdata = true;
+        }
+        else if ("struct".equals(name))
+        {
+            currentValue.setType(STRUCT);
+        }
+        else if ("array".equals(name))
+        {
+            currentValue.setType(ARRAY);
+        }
+    }
+
+    /**
+     *
+     * @param e
+     * @throws SAXException
+     */
+    public void error(SAXParseException e) throws SAXException
+    {
+        System.err.println("Error parsing XML: " + e);
+        // errorLevel = RECOVERABLE;
+        // errorMsg = e.toString ();
+    }
+
+    /**
+     *
+     * @param e
+     * @throws SAXException
+     */
+    public void fatalError(SAXParseException e) throws SAXException
+    {
+        System.err.println("Fatal error parsing XML: " + e);
+        // errorLevel = FATAL;
+        // errorMsg = e.toString ();
+    }
+
+    /**
+     * This represents an XML-RPC Value while the request is being parsed.
+     */
+    class Value
+    {
+        int type;
+        Object value;
+        // the name to use for the next member of struct values
+        String nextMemberName;
+
+        Hashtable struct;
+        Vector array;
+
+        /**
+         * Constructor.
+         */
+        public Value()
+        {
+            this.type = STRING;
+        }
+
+        /**
+         * Notification that a new child element has been parsed.
+         */
+        public void endElement(Value child)
+        {
+            if (type == ARRAY)
+            {
+                array.addElement(child.value);
+            }
+            else if (type == STRUCT)
+            {
+                struct.put(nextMemberName, child.value);
+            }
+        }
+
+        /**
+         * Set the type of this value. If it's a container, create the
+         * corresponding java container.
+         */
+        public void setType(int type)
+        {
+            // System.err.println ("setting type to "+types[type]);
+            this.type = type;
+            if (type == ARRAY)
+            {
+                value = array = new Vector();
+            }
+            if (type == STRUCT)
+            {
+                value = struct = new Hashtable();
+            }
+        }
+
+        /**
+         * Set the character data for the element and interpret it according to
+         * the element type
+         */
+        public void characterData (String cdata)
+        {
+            switch (type)
+            {
+                case INTEGER:
+                    value = new Integer(cdata.trim());
+                    break;
+                case BOOLEAN:
+                    value = new Boolean("1".equals(cdata.trim()));
+                    break;
+                case DOUBLE:
+                    value = new Double(cdata.trim());
+                    break;
+                case DATE:
+                    try
+                    {
+                        value = format.parse(cdata.trim());
+                    }
+                    catch (ParseException p)
+                    {
+                        // System.err.println ("Exception while parsing date: "+p);
+                        throw new RuntimeException(p.getMessage());
+                    }
+                    break;
+                case BASE64:
+                    try
+                    {
+                        value = base64.decode((Object) cdata.getBytes());
+                    }
+                    catch (DecoderException e) {
+                        /* FIXME: We should Probably throw an
+                         * Exception here.  Punting because this class
+                         * is slated for complete overhaul using the
+                         * core library.
+                         */ 
+                        value = cdata;
+                    }
+                    break;
+                case STRING:
+                    value = cdata;
+                    break;
+                case STRUCT:
+                    // this is the name to use for the next member of this struct
+                    nextMemberName = cdata;
+                    break;
+            }
+        }
+
+        /**
+         * This is a performance hack to get the type of a value without casting
+         * the Object. It breaks the contract of method hashCode, but it doesn't
+         * matter since Value objects are never used as keys in Hashtables.
+         */
+        public int hashCode ()
+        {
+            return type;
+        }
+
+        /**
+         *
+         * @return
+         */
+        public String toString ()
+        {
+            return (types[type] + " element " + value);
+        }
+    }
+
+    /**
+     * A quick and dirty XML writer.
+     * TODO: Replace with core package's XmlWriter class.
+     *
+     * @see <a
+     * href="http://nagoya.apache.org/bugzilla/show_bug.cgi?id=28982">Bugzilla
+     * bug 28982</a>
+     */
+    class XmlWriter
+    {
+        StringBuffer buf;
+        String enc;
+
+        /**
+         *
+         * @param buf
+         */
+        public XmlWriter(StringBuffer buf)
+        {
+            this.buf = buf;
+            buf.append("<?xml version=\"1.0\"?>");
+        }
+
+        /**
+         *
+         * @param elem
+         */
+        public void startElement(String elem)
+        {
+            buf.append("<");
+            buf.append(elem);
+            buf.append(">");
+        }
+
+        /**
+         *
+         * @param elem
+         */
+        public void endElement(String elem)
+        {
+            buf.append("</");
+            buf.append(elem);
+            buf.append(">");
+        }
+
+        /**
+         *
+         * @param elem
+         */
+        public void emptyElement(String elem)
+        {
+            buf.append("<");
+            buf.append(elem);
+            buf.append("/>");
+        }
+
+        /**
+         *
+         * @param text
+         */
+        public void chardata(String text)
+        {
+            int l = text.length();
+            for (int i = 0; i < l; i++)
+            {
+                char c = text.charAt(i);
+                switch (c)
+                {
+                    case '<' :
+                        buf.append("&lt;");
+                        break;
+                    case '>' :
+                        buf.append("&gt;");
+                        break;
+                    case '&' :
+                        buf.append("&amp;");
+                        break;
+                    default :
+                        buf.append(c);
+                }
+            }
+        }
+
+        /**
+         *
+         * @param text
+         */
+        public void write(byte[] text)
+        {
+            // ### This may cause encoding complications for
+            // ### multi-byte characters.  This should be properly
+            // ### fixed by implementing Bugzilla issue 28982.
+            for (int i = 0; i < text.length; i++)
+            {
+                buf.append((char) text[i]);
+            }
+        }
+
+        /**
+         *
+         * @param text
+         */
+        public void write(char[] text)
+        {
+            buf.append(text);
+        }
+
+        /**
+         *
+         * @param text
+         */
+        public void write(String text)
+        {
+            buf.append(text);
+        }
+
+        /**
+         *
+         * @return
+         */
+        public String toString()
+        {
+            return buf.toString();
+        }
+
+        /**
+         *
+         * @return
+         * @throws UnsupportedEncodingException
+         */
+        public byte[] getBytes() throws UnsupportedEncodingException
+        {
+            return buf.toString().getBytes();
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/applet/XmlRpcApplet.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.applet;
+
+import java.applet.Applet;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Vector;
+
+
+/**
+ * An applet that provides basic XML-RPC client functionality.
+ *
+ * @version $Id: XmlRpcApplet.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class XmlRpcApplet extends Applet {
+
+    SimpleXmlRpcClient client;
+
+
+    /**
+     * Initialize the XML-RPC client, trying to get the port number from the
+     * applet parameter tags. The default for port is 80. The client connects to
+     * the server this applet came from.
+     */
+    public void initClient()
+    {
+        int port = 80;
+        String p = getParameter("PORT");
+        if (p != null)
+        {
+            try
+            {
+                port = Integer.parseInt(p);
+            }
+            catch (NumberFormatException nfx)
+            {
+                System.out.println("Error parsing port: " + nfx);
+            }
+        }
+        initClient(port);
+    }
+
+    /**
+     * Initialize the XML-RPC client with the specified port and the server this
+     * applet came from.
+     */
+    public void initClient(int port)
+    {
+        String uri = getParameter("URI");
+        if (uri == null)
+        {
+            uri = "/RPC2";
+        }
+        else if (!uri.startsWith("/"))
+        {
+            uri = "/" + uri;
+        }
+        initClient(port, uri);
+    }
+
+    /**
+     * Initialize the XML-RPC client with the specified port and request path
+     * and the server this applet came from.
+     */
+    public void initClient(int port, String uri)
+    {
+        String host = getCodeBase().getHost();
+        try
+        {
+            URL url = new URL("http://" + host + ":" + port + uri);
+            System.out.println("XML-RPC URL: " + url);
+            client = new SimpleXmlRpcClient(url);
+        }
+        catch (MalformedURLException unlikely)
+        {
+            System.out.println("Error constructing XML-RPC client for "
+                    + host + ":" + port + ": " + unlikely);
+        }
+    }
+
+    /**
+     * Calls the XML-RPC server with the specified methodname and argument list.
+     */
+    public Object execute(String methodName, Vector arguments)
+            throws XmlRpcException, IOException
+    {
+        if (client == null)
+        {
+            initClient ();
+        }
+        Object returnValue = null;
+        return returnValue = client.execute(methodName, arguments);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/applet/XmlRpcException.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.applet;
+
+/**
+ * This is thrown by the XmlRpcClient if the remote server reported an error.
+ * If something went wrong at a lower level (e.g. no http connection) an
+ * IOException will be thrown instead.
+ *
+ * @version $Id: XmlRpcException.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class XmlRpcException extends Exception
+{
+    /**
+     * The fault code of the exception. For servers based on this library, this
+     * will always be 0. (If there are predefined error codes, they should be in
+     * the XML-RPC spec.)
+     */
+    public final int code;
+
+    /**
+     *
+     * @param code
+     * @param message
+     */
+    public XmlRpcException (int code, String message)
+    {
+        super (message);
+        this.code = code;
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/secure/SecureWebServer.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.secure;
+
+
+import java.io.FileInputStream;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import java.security.KeyStore;
+
+import javax.net.ssl.SSLServerSocket;
+import javax.net.ssl.SSLServerSocketFactory;
+
+import org.apache.xmlrpc.WebServer;
+import org.apache.xmlrpc.XmlRpc;
+import org.apache.xmlrpc.XmlRpcServer;
+
+import com.sun.net.ssl.KeyManagerFactory;
+import com.sun.net.ssl.SSLContext;
+
+/**
+ * A minimal web server that exclusively handles XML-RPC requests
+ * over a secure channel.
+ *
+ * Standard security properties must be set before the SecureWebserver
+ * can be used. The SecurityTool takes care of retrieving these
+ * values, but the parent application must set the necessary
+ * values before anything will work.
+ *
+ * @author <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
+ * @version $Id: SecureWebServer.java 233919 2005-04-22 10:26:17Z hgomez $
+ */
+public class SecureWebServer 
+    extends WebServer
+    implements SecurityConstants
+{
+    /**
+     * Creates a secure web server configured to run on the specified
+     * port number.
+     *
+     * @param int port number of secure web server.
+     * @see #SecureWebServer(int, InetAddress)
+     */
+    public SecureWebServer(int port)
+    {
+        this(port, null);
+    }
+
+    /**
+     * Creates a secure web server configured to run on the specified
+     * port number and IP address.
+     *
+     * @param int port number of the secure web server
+     * @param addr The IP address to bind to.
+     * @see org.apache.xmlrpc.WebServer#WebServer(int, InetAddress)
+     */
+    public SecureWebServer(int port, InetAddress addr)
+    {
+        super(port, addr);
+    }
+
+
+    /**
+     * Creates a secure web server at the specified port number and IP
+     * address.
+     */
+    public SecureWebServer(int port, InetAddress addr, XmlRpcServer xmlrpc)
+    {
+        super(port, addr, xmlrpc);
+    }
+
+    /**
+     * @see org.apache.xmlrpc.WebServer#createServerSocket(int port, int backlog, InetAddress add)
+     */
+    protected ServerSocket createServerSocket(int port, int backlog, InetAddress add)
+        throws Exception
+    {
+        SecurityTool.setup();
+    
+        SSLContext context = SSLContext.getInstance(SecurityTool.getSecurityProtocol());
+          
+        KeyManagerFactory keyManagerFactory = 
+            KeyManagerFactory.getInstance(SecurityTool.getKeyManagerType());
+            
+        KeyStore keyStore = KeyStore.getInstance(SecurityTool.getKeyStoreType());
+            
+        keyStore.load(new FileInputStream(SecurityTool.getKeyStore()), 
+            SecurityTool.getKeyStorePassword().toCharArray());
+            
+        keyManagerFactory.init(keyStore, SecurityTool.getKeyStorePassword().toCharArray());
+            
+        context.init(keyManagerFactory.getKeyManagers(), null, null);
+        SSLServerSocketFactory sslSrvFact = context.getServerSocketFactory();
+        return (SSLServerSocket) sslSrvFact.createServerSocket(port);
+    }
+
+    /**
+     * This <em>can</em> be called from command line, but you'll have to 
+     * edit and recompile to change the server port or handler objects. 
+     *
+     * @see org.apache.xmlrpc.WebServer#addDefaultHandlers()
+     */
+    public static void main(String[] argv)
+    {
+        int p = determinePort(argv, 10000);
+        XmlRpc.setKeepAlive (true);
+        SecureWebServer webserver = new SecureWebServer (p);
+
+        try
+        {
+            webserver.addDefaultHandlers();
+            webserver.start();
+        }
+        catch (Exception e)
+        {
+            System.err.println("Error running secure web server");
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/secure/SecureXmlRpcClient.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.secure;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Vector;
+
+import org.apache.xmlrpc.XmlRpcClient;
+
+/**
+ * A multithreaded, reusable XML-RPC client object. Use this if you need a full-grown
+ * HTTP client (e.g. for Proxy and Cookies support). If you don't need that, <code>XmlRpcClientLite</code>
+ * may work better for you.
+ */
+public class SecureXmlRpcClient 
+    extends XmlRpcClient
+{
+    /** 
+     * Construct a XML-RPC client with this URL.
+     */
+    public SecureXmlRpcClient (URL url) {
+        super(url);
+    }
+
+    /** 
+     * Construct a XML-RPC client for the URL represented by this String.
+     */
+    public SecureXmlRpcClient (String url) throws MalformedURLException {
+        super(url);
+    }
+   
+    /** 
+     * Construct a XML-RPC client for the specified hostname and port.
+     */
+    public SecureXmlRpcClient (String hostname, int port) throws MalformedURLException 
+    {
+        super("https://" + hostname + ':' + port + "/RPC2");
+    }
+    
+    /**
+     * This allows us to setup
+     */
+     public void setup() throws Exception
+     {
+         SecurityTool.setup();    
+     }
+
+    /** 
+     * Just for testing.
+     */
+    public static void main (String args[]) throws Exception
+    {
+        // XmlRpc.setDebug (true);
+        try {
+            String url = args[0];
+            String method = args[1];
+            Vector v = new Vector ();
+            for (int i=2; i<args.length; i++) try {
+                v.addElement (new Integer (Integer.parseInt (args[i])));
+            } catch (NumberFormatException nfx) {
+                v.addElement (args[i]);
+            }
+            SecureXmlRpcClient client = new SecureXmlRpcClient (url);
+            try {
+                System.err.println (client.execute (method, v));
+            } catch (Exception ex) {
+                System.err.println ("Error: "+ex.getMessage());
+            }
+        } catch (Exception x) {
+            System.err.println (x);
+            System.err.println ("Usage: java " +
+                                SecureXmlRpcClient.class.getName() +
+                                " <url> <method> [args]");
+            System.err.println ("Arguments are sent as integers or strings.");
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/secure/SecurityConstants.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.secure;
+
+
+public interface SecurityConstants
+{
+    /**
+     * Default security provider class. If you are using
+     * something like Cryptix then you would override
+     * default with setSecurityProviderClass().
+     */
+    public final static String DEFAULT_SECURITY_PROVIDER_CLASS = 
+        "com.sun.net.ssl.internal.ssl.Provider";
+
+    public final static String SECURITY_PROVIDER_CLASS =
+        "security.provider";
+
+    /**
+     * Default security protocol. You probably don't need to
+     * override this default.
+     */
+    public final static String DEFAULT_SECURITY_PROTOCOL = "TLS";
+    
+    public final static String SECURITY_PROTOCOL = "security.protocol";
+
+    /**
+     * Default key store location. This is just for testing, you
+     * will want to override this default in a production environment.
+     */
+    public final static String DEFAULT_KEY_STORE = "testkeys";
+    
+    public final static String KEY_STORE = "javax.net.ssl.keyStore";
+
+    /**
+     * Default key store format. You probably don't need to
+     * override this default.
+     */
+    public final static String DEFAULT_KEY_STORE_TYPE = "JKS";
+
+    public final static String KEY_STORE_TYPE = "javax.net.ssl.keyStoreType";
+
+    /**
+     * Default key store password. This default is only
+     * used for testing because the sample key store provided
+     * with the Sun JSSE uses this password. Do <strong>not</strong>
+     * use this password in a production server.
+     */
+    public final static String DEFAULT_KEY_STORE_PASSWORD = "password";
+    
+    public final static String KEY_STORE_PASSWORD = "javax.net.ssl.keyStorePassword";
+
+    /**
+     * Default key store format. You probably don't need to
+     * override this default.
+     */
+    public final static String DEFAULT_TRUST_STORE_TYPE = "JKS";
+
+    public final static String TRUST_STORE_TYPE =
+        "javax.net.ssl.trustStoreType";
+
+    /**
+     * Default key store location. This is just for testing, you
+     * will want to override this default in a production environment.
+     */
+    public final static String DEFAULT_TRUST_STORE = "truststore";
+    
+    public final static String TRUST_STORE = "javax.net.ssl.trustStore";
+
+    /**
+     * Default key store password. This default is only
+     * used for testing because the sample key store provided
+     * with the Sun JSSE uses this password. Do <strong>not</strong>
+     * use this password in a production server.
+     */
+    public final static String DEFAULT_TRUST_STORE_PASSWORD = "password";
+    
+    public final static String TRUST_STORE_PASSWORD =
+        "javax.net.ssl.trustStorePassword";
+
+    /**
+     * Default key manager type. You probably don't need to
+     * override this default.
+     */
+    public final static String DEFAULT_KEY_MANAGER_TYPE = "SunX509";
+
+    public final static String KEY_MANAGER_TYPE = 
+        "sun.ssl.keymanager.type";
+
+    public final static String TRUST_MANAGER_TYPE =
+        "sun.ssl.trustmanager.type";
+
+    /**
+     * Default protocol handler packages. Change this if you
+     * are using something other than the Sun JSSE.
+     */
+    public final static String DEFAULT_PROTOCOL_HANDLER_PACKAGES = 
+        "com.sun.net.ssl.internal.www.protocol";
+
+    public final static String PROTOCOL_HANDLER_PACKAGES =
+        "java.protocol.handler.pkgs";
+}
--- /dev/null
+++ b/org/apache/xmlrpc/secure/SecurityTool.java
@@ -0,0 +1,453 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.secure;
+
+import java.security.KeyStore;
+import java.security.Provider;
+import java.security.Security;
+
+/**
+ */
+public class SecurityTool
+    implements SecurityConstants
+{
+    /**
+     * Class name of the security provider to be
+     * used by the secure web server.
+     */
+    protected static String securityProviderClass;
+    
+    /**
+     * The security protocol to be used by the
+     * secure web server. Currently the options are
+     * SSL and TLS.
+     */
+    private static String securityProtocol;
+
+    /**
+     * Password used to access the key store.
+     */
+    private static String keyStorePassword;
+
+    /**
+     * Format to be used for the key store. With
+     * the Sun JSSE the standard "JKS" format is
+     * available along with the "PKCS12" format.
+     */
+    private static String keyStoreType;
+    
+    /**
+     * Path to the key store that will be used by
+     * the secure web server.
+     */
+    private static String keyStore;
+
+    /**
+     * Password used to access the key store.
+     */
+    private static String trustStorePassword;
+
+    /**
+     * Format to be used for the key store. With
+     * the Sun JSSE the standard "JKS" format is
+     * available along with the "PKCS12" format.
+     */
+    private static String trustStoreType;
+    
+    /**
+     * Path to the key store that will be used by
+     * the secure web server.
+     */
+    private static String trustStore;
+
+    /**
+     * The type of key manager to be used by the
+     * secure web server. With the Sun JSSE only
+     * type available is the X509  type which
+     * is implemented in the SunX509 classes.
+     */
+    private static String keyManagerType;
+
+    /**
+     * The protocol handler package to use for
+     * the secure web server. This allows the URL
+     * class to handle https streams.
+     */
+    private static String protocolHandlerPackages;
+
+    public static void setup() 
+        throws Exception
+    {
+        /*
+         * We want to dynamically register the SunJSSE provider
+         * because we don't want people to have to modify their
+         * JVM setups manually.
+         */
+        Security.addProvider((Provider)Class.forName(
+            SecurityTool.getSecurityProviderClass()).newInstance());
+        
+        /*
+         * Set the packages that will provide the URL stream
+         * handlers that can cope with TLS/SSL.
+         */
+        System.setProperty(PROTOCOL_HANDLER_PACKAGES,
+            SecurityTool.getProtocolHandlerPackages());
+
+        // Setup KeyStore
+
+        System.setProperty(KEY_STORE_TYPE,
+            SecurityTool.getKeyStoreType());
+        
+        System.setProperty(KEY_STORE,
+            SecurityTool.getKeyStore());
+        
+        System.setProperty(KEY_STORE_PASSWORD,
+            SecurityTool.getKeyStorePassword());
+
+        // Setup TrustStore
+        
+        System.setProperty(TRUST_STORE_TYPE,
+            SecurityTool.getTrustStoreType());
+        
+        System.setProperty(TRUST_STORE,
+            SecurityTool.getTrustStore());
+        
+        System.setProperty(TRUST_STORE_PASSWORD,
+            SecurityTool.getTrustStorePassword());
+    }
+
+    /**
+     * Set the protocol handler packages.
+     *
+     * @param String protocol handler package.
+     */
+    public static void setProtocolHandlerPackages(String x)
+    {
+        protocolHandlerPackages = x;
+    }        
+
+    /**
+     * Get the protocol handler packages.
+     *
+     * @param String protocol handler package.
+     */
+    public static String getProtocolHandlerPackages()
+    {
+        if (System.getProperty(PROTOCOL_HANDLER_PACKAGES) != null)
+        {
+            return System.getProperty(PROTOCOL_HANDLER_PACKAGES);
+        }
+        if (protocolHandlerPackages == null)
+        {
+            return DEFAULT_PROTOCOL_HANDLER_PACKAGES;
+        }
+        else
+        {
+            return protocolHandlerPackages;
+        }
+    }        
+
+    /**
+     * Set the security provider class.
+     *
+     * @param String name of security provider class.
+     */
+    public static void setSecurityProviderClass(String x)
+    {
+        securityProviderClass = x;
+    }        
+
+    /**
+     * Get the security provider class.
+     *
+     * @return String name of security provider class.
+     */
+    public static String getSecurityProviderClass()
+    {
+        if (System.getProperty(SECURITY_PROVIDER_CLASS) != null)
+        {
+            return System.getProperty(SECURITY_PROVIDER_CLASS);
+        }
+        if (securityProviderClass == null)
+        {
+            return DEFAULT_SECURITY_PROVIDER_CLASS;
+        }
+        else
+        {
+            return securityProviderClass;
+        }
+    }
+
+    /**
+     * Set the key store password.
+     *
+     * @param String key store password.
+     */
+    public static void setKeyStorePassword(String x)
+    {
+        keyStorePassword = x;
+    }
+
+    /**
+     * Set the security protocol.
+     *
+     * @param String security protocol.
+     */
+    public static void setSecurityProtocol(String x)
+    {
+        securityProtocol = x;
+    }
+
+    /**
+     * Get the security protocol.
+     *
+     * @return String security protocol.
+     */
+    public static String getSecurityProtocol()
+    {
+        if (System.getProperty(SECURITY_PROTOCOL) != null)
+        {
+            return System.getProperty(SECURITY_PROTOCOL);
+        }
+        if (securityProtocol== null)
+        {
+            return DEFAULT_SECURITY_PROTOCOL;
+        }
+        else
+        {
+            return securityProtocol;
+        }
+    }
+
+    /**
+     * Set the key store location.
+     *
+     * @param String key store location.
+     */
+    public static void setKeyStore(String x)
+    {
+        keyStore = x;
+    }        
+
+    /**
+     * Get the key store location.
+     *
+     * @return String key store location.
+     */
+    public static String getKeyStore()
+    {
+        if (System.getProperty(KEY_STORE) != null)
+        {
+            return System.getProperty(KEY_STORE);
+        }
+        if (keyStore == null)
+        {
+            return DEFAULT_KEY_STORE;
+        }
+        else
+        {
+            return keyStore;
+        }
+    }        
+
+    /**
+     * Set the key store format.
+     *
+     * @param String key store format.
+     */
+    public static void setKeyStoreType(String x)
+    {
+        keyStoreType = x;
+    }        
+
+    /**
+     * Get the key store format.
+     *
+     * @return String key store format.
+     */
+    public static String getKeyStoreType()
+    {
+        if (System.getProperty(KEY_STORE_TYPE) != null)
+        {
+            return System.getProperty(KEY_STORE_TYPE);
+        }
+        if (keyStoreType == null)
+        {
+            /*
+             * If the keystore type hasn't been specified
+             * then let the system determine the default
+             * type.
+             */
+            return KeyStore.getDefaultType();
+        }
+        else
+        {
+            return keyStoreType;
+        }
+    }        
+
+    /**
+     * Get the key store password.
+     *
+     * @return String key store password.
+     */
+    public static String getKeyStorePassword()
+    {
+        if (System.getProperty(KEY_STORE_PASSWORD) != null)
+        {
+            return System.getProperty(KEY_STORE_PASSWORD);
+        }
+        if (keyStorePassword == null)
+        {
+            return DEFAULT_KEY_STORE_PASSWORD;
+        }
+        else
+        {
+            return keyStorePassword;
+        }
+    }
+
+    /**
+     * Set the key store location.
+     *
+     * @param String key store location.
+     */
+    public static void setTrustStore(String x)
+    {
+        trustStore = x;
+    }        
+
+    /**
+     * Get the key store location.
+     *
+     * @return String key store location.
+     */
+    public static String getTrustStore()
+    {
+        if (System.getProperty(TRUST_STORE) != null)
+        {
+            return System.getProperty(TRUST_STORE);
+        }
+        if (trustStore == null)
+        {
+            return DEFAULT_TRUST_STORE;
+        }
+        else
+        {
+            return trustStore;
+        }
+    }        
+
+    /**
+     * Set the key store format.
+     *
+     * @param String key store format.
+     */
+    public static void setTrustStoreType(String x)
+    {
+        trustStoreType = x;
+    }        
+
+    /**
+     * Get the key store format.
+     *
+     * @return String key store format.
+     */
+    public static String getTrustStoreType()
+    {
+        if (System.getProperty(TRUST_STORE_TYPE) != null)
+        {
+            return System.getProperty(TRUST_STORE_TYPE);
+        }
+        if (trustStoreType == null)
+        {
+            /*
+             * If the keystore type hasn't been specified
+             * then let the system determine the default
+             * type.
+             */
+            return KeyStore.getDefaultType();
+        }
+        else
+        {
+            return trustStoreType;
+        }
+    }        
+
+    /**
+     * Set the trust store password.
+     *
+     * @param String  trust store password.
+     */
+    public static void setTrustStorePassword(String x)
+    {
+        trustStorePassword = x;
+    }        
+
+    /**
+     * Get the trust store password.
+     *
+     * @return String trust store password.
+     */
+    public static String getTrustStorePassword()
+    {
+        if (System.getProperty(TRUST_STORE_PASSWORD) != null)
+        {
+            return System.getProperty(TRUST_STORE_PASSWORD);
+        }
+        if (trustStorePassword == null)
+        {
+            return DEFAULT_TRUST_STORE_PASSWORD;
+        }
+        else
+        {
+            return trustStorePassword;
+        }
+    }
+
+    /**
+     * Set the key manager type.
+     *
+     * @param String key manager type.
+     */
+    public static void setKeyManagerType(String x)
+    {
+        keyManagerType = x;
+    }        
+
+    /**
+     * Get the key manager type.
+     *
+     * @return String key manager type.
+     */
+    public static String getKeyManagerType()
+    {
+        if (System.getProperty(KEY_MANAGER_TYPE) != null)
+        {
+            return System.getProperty(KEY_MANAGER_TYPE);
+        }
+        if (keyManagerType == null)
+        {
+            return DEFAULT_KEY_MANAGER_TYPE;
+        }
+        else
+        {
+            return keyManagerType;
+        }
+    }        
+}
--- /dev/null
+++ b/org/apache/xmlrpc/secure/sunssl/SunSSLTransportFactory.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.secure.sunssl;
+
+import java.net.URL;
+import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.X509Certificate;
+import java.util.Properties;
+
+import org.apache.xmlrpc.DefaultXmlRpcTransport;
+import org.apache.xmlrpc.XmlRpcTransport;
+import org.apache.xmlrpc.XmlRpcTransportFactory;
+import org.apache.xmlrpc.secure.SecurityTool;
+
+import com.sun.net.ssl.HostnameVerifier;
+import com.sun.net.ssl.HttpsURLConnection;
+import com.sun.net.ssl.SSLContext;
+import com.sun.net.ssl.X509TrustManager;
+
+/**
+ * Interface from XML-RPC to the HTTPS transport based on the
+ * @see javax.net.ssl.httpsURLConnection class.
+ *
+ * @author <a href="mailto:lmeader@ghsinc.com">Larry Meader</a>
+ * @author <a href="mailto:cjackson@ghsinc.com">Chris Jackson</a> 
+ * @author <a href="mailto:andrew@kungfoocoder.org">Andrew Evers</a>
+ * @version $Id: SunSSLTransportFactory.java 233919 2005-04-22 10:26:17Z hgomez $
+ * @since 1.2
+ */
+public class SunSSLTransportFactory implements XmlRpcTransportFactory
+{
+    protected URL url;
+    protected String auth;
+
+    public static final String TRANSPORT_TRUSTMANAGER = "hostnameverifier";
+    public static final String TRANSPORT_HOSTNAMEVERIFIER = "trustmanager";
+
+    // The openTrustManager trusts all certificates
+    private static X509TrustManager openTrustManager = new X509TrustManager()
+    {
+        public boolean isClientTrusted(X509Certificate[] chain)
+        {
+            return true;
+        }
+ 
+        public boolean isServerTrusted(X509Certificate[] chain)
+        {
+            return true;
+        }
+ 
+        public X509Certificate[] getAcceptedIssuers() 
+        {
+            return null;
+        }
+    };
+
+    // The openHostnameVerifier trusts all hostnames
+    private static HostnameVerifier openHostnameVerifier = new HostnameVerifier() 
+    {
+        public boolean verify(String hostname, String session) 
+        {
+            return true;
+        }
+    };
+
+    public static Properties getProperties()
+    {
+        Properties properties = new Properties();
+
+        properties.setProperty(XmlRpcTransportFactory.TRANSPORT_URL, "(java.net.URL) - URL to connect to");
+        properties.setProperty(XmlRpcTransportFactory.TRANSPORT_AUTH, "(java.lang.String) - HTTP Basic Authentication string (encoded).");
+        properties.setProperty(TRANSPORT_TRUSTMANAGER, "(com.sun.net.ssl.X509TrustManager) - X.509 Trust Manager to use");
+        properties.setProperty(TRANSPORT_HOSTNAMEVERIFIER, "(com.sun.net.ssl.HostnameVerifier) - Hostname verifier to use");
+
+        return properties;
+    }
+
+    public SunSSLTransportFactory(Properties properties)
+    throws GeneralSecurityException
+    {
+        X509TrustManager trustManager;
+        HostnameVerifier hostnameVerifier;
+        SSLContext sslContext;
+
+        Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
+
+        url = (URL) properties.get(XmlRpcTransportFactory.TRANSPORT_URL);
+        auth = properties.getProperty(XmlRpcTransportFactory.TRANSPORT_AUTH);
+
+        trustManager = (X509TrustManager) properties.get(TRANSPORT_TRUSTMANAGER);
+        if (trustManager == null)
+        {
+            trustManager = openTrustManager;
+        }
+
+        hostnameVerifier = (HostnameVerifier) properties.get(TRANSPORT_HOSTNAMEVERIFIER);
+        if (hostnameVerifier == null)
+        {
+            hostnameVerifier = openHostnameVerifier;
+        }  
+
+        sslContext = SSLContext.getInstance(SecurityTool.getSecurityProtocol());
+        X509TrustManager[] tmArray = new X509TrustManager[] { trustManager };
+        sslContext.init(null, tmArray, new SecureRandom());
+
+        // Set the default SocketFactory and HostnameVerifier
+        // for javax.net.ssl.HttpsURLConnection
+        if (sslContext != null) 
+        {
+            HttpsURLConnection.setDefaultSSLSocketFactory(
+                sslContext.getSocketFactory());
+        }
+        HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
+    }
+
+    public XmlRpcTransport createTransport()
+    {
+       return new DefaultXmlRpcTransport(url, auth);
+    }
+
+    public void setProperty(String propertyName, Object value)
+    {
+        if (TRANSPORT_AUTH.equals(propertyName))
+        {
+          auth = (String) value;
+        }
+        else if (TRANSPORT_URL.equals(propertyName))
+        {
+          url = (URL) value;
+        }
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/util/DateTool.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.util;
+
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.TimeZone;
+
+/**
+ * Wraps a <code>DateFormat</code> instance to provide thread safety.
+ *
+ * @author <a href="mailto:hannes@apache.org">Hannes Wallnoefer</a>
+ * @author Daniel L. Rall
+ */
+public class DateTool
+{
+    protected static final String FORMAT = "yyyyMMdd'T'HH:mm:ss";
+
+    private DateFormat df;
+
+    /**
+     * Uses the <code>DateFormat</code> string
+     * <code>yyyyMMdd'T'HH:mm:ss</code>.
+     *
+     * @see #FORMAT
+     */
+    public DateTool()
+    {
+        df = new SimpleDateFormat(FORMAT);
+    }
+
+    /**
+     * @param d The date to format.
+     * @return The formatted date.
+     */
+    public synchronized String format(Date d)
+    {
+        return df.format(d);
+    }
+
+    public synchronized void setTimeZone(TimeZone z) {
+        if (z != null) df.setTimeZone(z);
+    }
+
+    /**
+     * @param s The text to parse a date from.
+     * @return The parsed date.
+     * @exception ParseException If the date could not be parsed.
+     */
+    public synchronized Date parse(String s)
+        throws ParseException
+    {
+        return df.parse(s);
+    }
+}
--- /dev/null
+++ b/org/apache/xmlrpc/util/HttpUtil.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 1999,2005 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.xmlrpc.util;
+
+import org.apache.commons.codec.binary.Base64;
+import org.apache.commons.codec.EncoderException;
+
+/**
+ * Provides utility functions useful in HTTP communications
+ *
+ * @author <a href="mailto:rhoegg@isisnetworks.net">Ryan Hoegg</a>
+ */
+public class HttpUtil
+{
+    private static final Base64 base64;
+    
+    static {
+        base64 = new Base64();
+    }
+    
+    private HttpUtil()
+    {
+        // private because currently we only offer static methods.
+    }
+    
+    public static String encodeBasicAuthentication(String user, String password)
+    {
+        String auth;
+        if (user == null || password == null)
+        {
+            auth = null;
+        }
+        else
+        {
+            try
+            {
+                Object bytes = (user + ':' + password).getBytes();
+                auth = new String((byte[]) base64.encode(bytes)).trim();
+            }
+            catch (EncoderException e)
+            {
+                // EncoderException is never thrown in the body of
+                // Base64.encode(byte[]) in Commons Codec 1.1.
+                throw new RuntimeException("Possibly incompatible version of '"
+                                           + Base64.class.getName() +
+                                           "' used: " + e);
+            }
+        }
+        return auth;
+    }
+}
--- /dev/null
+++ b/org/xml/sax/AttributeList.java
@@ -0,0 +1,166 @@
+// SAX Attribute List Interface.
+// No warranty; no copyright -- use this as you will.
+// $Id: AttributeList.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+/**
+  * Interface for an element's attribute specifications.
+  *
+  * <p>The SAX parser implements this interface and passes an instance
+  * to the SAX application as the second argument of each startElement
+  * event.</p>
+  *
+  * <p>The instance provided will return valid results only during the
+  * scope of the startElement invocation (to save it for future
+  * use, the application must make a copy: the AttributeListImpl
+  * helper class provides a convenient constructor for doing so).</p>
+  *
+  * <p>An AttributeList includes only attributes that have been
+  * specified or defaulted: #IMPLIED attributes will not be included.</p>
+  *
+  * <p>There are two ways for the SAX application to obtain information
+  * from the AttributeList.  First, it can iterate through the entire
+  * list:</p>
+  *
+  * <pre>
+  * public void startElement (String name, AttributeList atts) {
+  *   for (int i = 0; i < atts.getLength(); i++) {
+  *     String name = atts.getName(i);
+  *     String type = atts.getType(i);
+  *     String value = atts.getValue(i);
+  *     [...]
+  *   }
+  * }
+  * </pre>
+  *
+  * <p>(Note that the result of getLength() will be zero if there
+  * are no attributes.)
+  *
+  * <p>As an alternative, the application can request the value or
+  * type of specific attributes:</p>
+  *
+  * <pre>
+  * public void startElement (String name, AttributeList atts) {
+  *   String identifier = atts.getValue("id");
+  *   String label = atts.getValue("label");
+  *   [...]
+  * }
+  * </pre>
+  *
+  * <p>The AttributeListImpl helper class provides a convenience 
+  * implementation for use by parser or application writers.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.DocumentHandler#startElement 
+  * @see org.xml.sax.helpers.AttributeListImpl
+  */
+public interface AttributeList {
+
+  /**
+    * Return the number of attributes in this list.
+    *
+    * <p>The SAX parser may provide attributes in any
+    * arbitrary order, regardless of the order in which they were
+    * declared or specified.  The number of attributes may be
+    * zero.</p>
+    *
+    * @return The number of attributes in the list.  
+    */
+  public abstract int getLength ();
+
+
+  /**
+    * Return the name of an attribute in this list (by position).
+    *
+    * <p>The names must be unique: the SAX parser shall not include the
+    * same attribute twice.  Attributes without values (those declared
+    * #IMPLIED without a value specified in the start tag) will be
+    * omitted from the list.</p>
+    *
+    * <p>If the attribute name has a namespace prefix, the prefix
+    * will still be attached.</p>
+    *
+    * @param i The index of the attribute in the list (starting at 0).
+    * @return The name of the indexed attribute, or null
+    *         if the index is out of range.
+    * @see #getLength 
+    */
+  public abstract String getName (int i);
+
+
+  /**
+    * Return the type of an attribute in the list (by position).
+    *
+    * <p>The attribute type is one of the strings "CDATA", "ID",
+    * "IDREF", "IDREFS", "NMTOKEN", "NMTOKENS", "ENTITY", "ENTITIES",
+    * or "NOTATION" (always in upper case).</p>
+    *
+    * <p>If the parser has not read a declaration for the attribute,
+    * or if the parser does not report attribute types, then it must
+    * return the value "CDATA" as stated in the XML 1.0 Recommentation
+    * (clause 3.3.3, "Attribute-Value Normalization").</p>
+    *
+    * <p>For an enumerated attribute that is not a notation, the
+    * parser will report the type as "NMTOKEN".</p>
+    *
+    * @param i The index of the attribute in the list (starting at 0).
+    * @return The attribute type as a string, or
+    *         null if the index is out of range.
+    * @see #getLength 
+    * @see #getType(java.lang.String)
+    */
+  public abstract String getType (int i);
+
+
+  /**
+    * Return the value of an attribute in the list (by position).
+    *
+    * <p>If the attribute value is a list of tokens (IDREFS,
+    * ENTITIES, or NMTOKENS), the tokens will be concatenated
+    * into a single string separated by whitespace.</p>
+    *
+    * @param i The index of the attribute in the list (starting at 0).
+    * @return The attribute value as a string, or
+    *         null if the index is out of range.
+    * @see #getLength
+    * @see #getValue(java.lang.String)
+    */
+  public abstract String getValue (int i);
+
+
+  /**
+    * Return the type of an attribute in the list (by name).
+    *
+    * <p>The return value is the same as the return value for
+    * getType(int).</p>
+    *
+    * <p>If the attribute name has a namespace prefix in the document,
+    * the application must include the prefix here.</p>
+    *
+    * @param name The name of the attribute.
+    * @return The attribute type as a string, or null if no
+    *         such attribute exists.
+    * @see #getType(int)
+    */
+  public abstract String getType (String name);
+
+
+  /**
+    * Return the value of an attribute in the list (by name).
+    *
+    * <p>The return value is the same as the return value for
+    * getValue(int).</p>
+    *
+    * <p>If the attribute name has a namespace prefix in the document,
+    * the application must include the prefix here.</p>
+    *
+    * @param i The index of the attribute in the list.
+    * @return The attribute value as a string, or null if
+    *         no such attribute exists.
+    * @see #getValue(int)
+    */
+  public abstract String getValue (String name);
+
+}
--- /dev/null
+++ b/org/xml/sax/DTDHandler.java
@@ -0,0 +1,95 @@
+// SAX DTD handler.
+// No warranty; no copyright -- use this as you will.
+// $Id: DTDHandler.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+/**
+  * Receive notification of basic DTD-related events.
+  *
+  * <p>If a SAX application needs information about notations and
+  * unparsed entities, then the application implements this 
+  * interface and registers an instance with the SAX parser using 
+  * the parser's setDTDHandler method.  The parser uses the 
+  * instance to report notation and unparsed entity declarations to 
+  * the application.</p>
+  *
+  * <p>The SAX parser may report these events in any order, regardless
+  * of the order in which the notations and unparsed entities were
+  * declared; however, all DTD events must be reported after the
+  * document handler's startDocument event, and before the first
+  * startElement event.</p>
+  *
+  * <p>It is up to the application to store the information for 
+  * future use (perhaps in a hash table or object tree).
+  * If the application encounters attributes of type "NOTATION",
+  * "ENTITY", or "ENTITIES", it can use the information that it
+  * obtained through this interface to find the entity and/or
+  * notation corresponding with the attribute value.</p>
+  *
+  * <p>The HandlerBase class provides a default implementation
+  * of this interface, which simply ignores the events.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.Parser#setDTDHandler
+  * @see org.xml.sax.HandlerBase 
+  */
+public interface DTDHandler {
+
+
+  /**
+    * Receive notification of a notation declaration event.
+    *
+    * <p>It is up to the application to record the notation for later
+    * reference, if necessary.</p>
+    *
+    * <p>If a system identifier is present, and it is a URL, the SAX
+    * parser must resolve it fully before passing it to the
+    * application.</p>
+    *
+    * @param name The notation name.
+    * @param publicId The notation's public identifier, or null if
+    *        none was given.
+    * @param systemId The notation's system identifier, or null if
+    *        none was given.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see #unparsedEntityDecl
+    * @see org.xml.sax.AttributeList
+    */
+  public abstract void notationDecl (String name,
+				     String publicId,
+				     String systemId)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of an unparsed entity declaration event.
+    *
+    * <p>Note that the notation name corresponds to a notation
+    * reported by the notationDecl() event.  It is up to the
+    * application to record the entity for later reference, if
+    * necessary.</p>
+    *
+    * <p>If the system identifier is a URL, the parser must resolve it
+    * fully before passing it to the application.</p>
+    *
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @param name The unparsed entity's name.
+    * @param publicId The entity's public identifier, or null if none
+    *        was given.
+    * @param systemId The entity's system identifier (it must always
+    *        have one).
+    * @param notation name The name of the associated notation.
+    * @see #notationDecl
+    * @see org.xml.sax.AttributeList
+    */
+  public abstract void unparsedEntityDecl (String name,
+					   String publicId,
+					   String systemId,
+					   String notationName)
+    throws SAXException;
+
+}
--- /dev/null
+++ b/org/xml/sax/DocumentHandler.java
@@ -0,0 +1,219 @@
+// SAX document handler.
+// No warranty; no copyright -- use this as you will.
+// $Id: DocumentHandler.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+/**
+  * Receive notification of general document events.
+  *
+  * <p>This is the main interface that most SAX applications
+  * implement: if the application needs to be informed of basic parsing 
+  * events, it implements this interface and registers an instance with 
+  * the SAX parser using the setDocumentHandler method.  The parser 
+  * uses the instance to report basic document-related events like
+  * the start and end of elements and character data.</p>
+  *
+  * <p>The order of events in this interface is very important, and
+  * mirrors the order of information in the document itself.  For
+  * example, all of an element's content (character data, processing
+  * instructions, and/or subelements) will appear, in order, between
+  * the startElement event and the corresponding endElement event.</p>
+  *
+  * <p>Application writers who do not want to implement the entire
+  * interface can derive a class from HandlerBase, which implements
+  * the default functionality; parser writers can instantiate
+  * HandlerBase to obtain a default handler.  The application can find
+  * the location of any document event using the Locator interface
+  * supplied by the Parser through the setDocumentLocator method.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.Parser#setDocumentHandler
+  * @see org.xml.sax.Locator
+  * @see org.xml.sax.HandlerBase
+  */
+public interface DocumentHandler {
+
+
+  /**
+    * Receive an object for locating the origin of SAX document events.
+    *
+    * <p>SAX parsers are strongly encouraged (though not absolutely
+    * required) to supply a locator: if it does so, it must supply
+    * the locator to the application by invoking this method before
+    * invoking any of the other methods in the DocumentHandler
+    * interface.</p>
+    *
+    * <p>The locator allows the application to determine the end
+    * position of any document-related event, even if the parser is
+    * not reporting an error.  Typically, the application will
+    * use this information for reporting its own errors (such as
+    * character content that does not match an application's
+    * business rules).  The information returned by the locator
+    * is probably not sufficient for use with a search engine.</p>
+    *
+    * <p>Note that the locator will return correct information only
+    * during the invocation of the events in this interface.  The
+    * application should not attempt to use it at any other time.</p>
+    *
+    * @param locator An object that can return the location of
+    *                any SAX document event.
+    * @see org.xml.sax.Locator
+    */
+  public abstract void setDocumentLocator (Locator locator);
+
+
+  /**
+    * Receive notification of the beginning of a document.
+    *
+    * <p>The SAX parser will invoke this method only once, before any
+    * other methods in this interface or in DTDHandler (except for
+    * setDocumentLocator).</p>
+    *
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    */
+  public abstract void startDocument ()
+    throws SAXException;
+
+
+  /**
+    * Receive notification of the end of a document.
+    *
+    * <p>The SAX parser will invoke this method only once, and it will
+    * be the last method invoked during the parse.  The parser shall
+    * not invoke this method until it has either abandoned parsing
+    * (because of an unrecoverable error) or reached the end of
+    * input.</p>
+    *
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    */
+  public abstract void endDocument ()
+    throws SAXException;
+
+
+  /**
+    * Receive notification of the beginning of an element.
+    *
+    * <p>The Parser will invoke this method at the beginning of every
+    * element in the XML document; there will be a corresponding
+    * endElement() event for every startElement() event (even when the
+    * element is empty). All of the element's content will be
+    * reported, in order, before the corresponding endElement()
+    * event.</p>
+    *
+    * <p>If the element name has a namespace prefix, the prefix will
+    * still be attached.  Note that the attribute list provided will
+    * contain only attributes with explicit values (specified or
+    * defaulted): #IMPLIED attributes will be omitted.</p>
+    *
+    * @param name The element type name.
+    * @param atts The attributes attached to the element, if any.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see #endElement
+    * @see org.xml.sax.AttributeList 
+    */
+  public abstract void startElement (String name, AttributeList atts)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of the end of an element.
+    *
+    * <p>The SAX parser will invoke this method at the end of every
+    * element in the XML document; there will be a corresponding
+    * startElement() event for every endElement() event (even when the
+    * element is empty).</p>
+    *
+    * <p>If the element name has a namespace prefix, the prefix will
+    * still be attached to the name.</p>
+    *
+    * @param name The element type name
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    */
+  public abstract void endElement (String name)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of character data.
+    *
+    * <p>The Parser will call this method to report each chunk of
+    * character data.  SAX parsers may return all contiguous character
+    * data in a single chunk, or they may split it into several
+    * chunks; however, all of the characters in any single event
+    * must come from the same external entity, so that the Locator
+    * provides useful information.</p>
+    *
+    * <p>The application must not attempt to read from the array
+    * outside of the specified range.</p>
+    *
+    * <p>Note that some parsers will report whitespace using the
+    * ignorableWhitespace() method rather than this one (validating
+    * parsers must do so).</p>
+    *
+    * @param ch The characters from the XML document.
+    * @param start The start position in the array.
+    * @param length The number of characters to read from the array.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see #ignorableWhitespace 
+    * @see org.xml.sax.Locator
+    */
+  public abstract void characters (char ch[], int start, int length)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of ignorable whitespace in element content.
+    *
+    * <p>Validating Parsers must use this method to report each chunk
+    * of ignorable whitespace (see the W3C XML 1.0 recommendation,
+    * section 2.10): non-validating parsers may also use this method
+    * if they are capable of parsing and using content models.</p>
+    *
+    * <p>SAX parsers may return all contiguous whitespace in a single
+    * chunk, or they may split it into several chunks; however, all of
+    * the characters in any single event must come from the same
+    * external entity, so that the Locator provides useful
+    * information.</p>
+    *
+    * <p>The application must not attempt to read from the array
+    * outside of the specified range.</p>
+    *
+    * @param ch The characters from the XML document.
+    * @param start The start position in the array.
+    * @param length The number of characters to read from the array.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see #characters
+    */
+  public abstract void ignorableWhitespace (char ch[], int start, int length)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of a processing instruction.
+    *
+    * <p>The Parser will invoke this method once for each processing
+    * instruction found: note that processing instructions may occur
+    * before or after the main document element.</p>
+    *
+    * <p>A SAX parser should never report an XML declaration (XML 1.0,
+    * section 2.8) or a text declaration (XML 1.0, section 4.3.1)
+    * using this method.</p>
+    *
+    * @param target The processing instruction target.
+    * @param data The processing instruction data, or null if
+    *        none was supplied.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    */
+  public abstract void processingInstruction (String target, String data)
+    throws SAXException;
+
+}
--- /dev/null
+++ b/org/xml/sax/EntityResolver.java
@@ -0,0 +1,105 @@
+// SAX entity resolver.
+// No warranty; no copyright -- use this as you will.
+// $Id: EntityResolver.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+import java.io.IOException;
+
+
+/**
+  * Basic interface for resolving entities.
+  *
+  * <p>If a SAX application needs to implement customized handling
+  * for external entities, it must implement this interface and
+  * register an instance with the SAX parser using the parser's
+  * setEntityResolver method.</p>
+  *
+  * <p>The parser will then allow the application to intercept any
+  * external entities (including the external DTD subset and external
+  * parameter entities, if any) before including them.</p>
+  *
+  * <p>Many SAX applications will not need to implement this interface,
+  * but it will be especially useful for applications that build
+  * XML documents from databases or other specialised input sources,
+  * or for applications that use URI types other than URLs.</p>
+  *
+  * <p>The following resolver would provide the application
+  * with a special character stream for the entity with the system
+  * identifier "http://www.myhost.com/today":</p>
+  *
+  * <pre>
+  * import org.xml.sax.EntityResolver;
+  * import org.xml.sax.InputSource;
+  *
+  * public class MyResolver implements EntityResolver {
+  *   public InputSource resolveEntity (String publicId, String systemId)
+  *   {
+  *     if (systemId.equals("http://www.myhost.com/today")) {
+  *              // return a special input source
+  *       MyReader reader = new MyReader();
+  *       return new InputSource(reader);
+  *     } else {
+  *              // use the default behaviour
+  *       return null;
+  *     }
+  *   }
+  * }
+  * </pre>
+  *
+  * <p>The application can also use this interface to redirect system
+  * identifiers to local URIs or to look up replacements in a catalog
+  * (possibly by using the public identifier).</p>
+  *
+  * <p>The HandlerBase class implements the default behaviour for
+  * this interface, which is simply always to return null (to request
+  * that the parser use the default system identifier).</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.Parser#setEntityResolver
+  * @see org.xml.sax.InputSource
+  * @see org.xml.sax.HandlerBase 
+  */
+public interface EntityResolver {
+
+
+  /**
+    * Allow the application to resolve external entities.
+    *
+    * <p>The Parser will call this method before opening any external
+    * entity except the top-level document entity (including the
+    * external DTD subset, external entities referenced within the
+    * DTD, and external entities referenced within the document
+    * element): the application may request that the parser resolve
+    * the entity itself, that it use an alternative URI, or that it
+    * use an entirely different input source.</p>
+    *
+    * <p>Application writers can use this method to redirect external
+    * system identifiers to secure and/or local URIs, to look up
+    * public identifiers in a catalogue, or to read an entity from a
+    * database or other input source (including, for example, a dialog
+    * box).</p>
+    *
+    * <p>If the system identifier is a URL, the SAX parser must
+    * resolve it fully before reporting it to the application.</p>
+    *
+    * @param publicId The public identifier of the external entity
+    *        being referenced, or null if none was supplied.
+    * @param systemId The system identifier of the external entity
+    *        being referenced.
+    * @return An InputSource object describing the new input source,
+    *         or null to request that the parser open a regular
+    *         URI connection to the system identifier.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException A Java-specific IO exception,
+    *            possibly the result of creating a new InputStream
+    *            or Reader for the InputSource.
+    * @see org.xml.sax.InputSource
+    */
+  public abstract InputSource resolveEntity (String publicId,
+					     String systemId)
+    throws SAXException, IOException;
+
+}
--- /dev/null
+++ b/org/xml/sax/ErrorHandler.java
@@ -0,0 +1,110 @@
+// SAX error handler.
+// No warranty; no copyright -- use this as you will.
+// $Id: ErrorHandler.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+
+/**
+  * Basic interface for SAX error handlers.
+  *
+  * <p>If a SAX application needs to implement customized error
+  * handling, it must implement this interface and then register an
+  * instance with the SAX parser using the parser's setErrorHandler
+  * method.  The parser will then report all errors and warnings
+  * through this interface.</p>
+  *
+  * <p> The parser shall use this interface instead of throwing an
+  * exception: it is up to the application whether to throw an
+  * exception for different types of errors and warnings.  Note,
+  * however, that there is no requirement that the parser continue to
+  * provide useful information after a call to fatalError (in other
+  * words, a SAX driver class could catch an exception and report a
+  * fatalError).</p>
+  *
+  * <p>The HandlerBase class provides a default implementation of this
+  * interface, ignoring warnings and recoverable errors and throwing a
+  * SAXParseException for fatal errors.  An application may extend
+  * that class rather than implementing the complete interface
+  * itself.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.Parser#setErrorHandler
+  * @see org.xml.sax.SAXParseException 
+  * @see org.xml.sax.HandlerBase
+  */
+public interface ErrorHandler {
+
+
+  /**
+    * Receive notification of a warning.
+    *
+    * <p>SAX parsers will use this method to report conditions that
+    * are not errors or fatal errors as defined by the XML 1.0
+    * recommendation.  The default behaviour is to take no action.</p>
+    *
+    * <p>The SAX parser must continue to provide normal parsing events
+    * after invoking this method: it should still be possible for the
+    * application to process the document through to the end.</p>
+    *
+    * @param exception The warning information encapsulated in a
+    *                  SAX parse exception.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.SAXParseException 
+    */
+  public abstract void warning (SAXParseException exception)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of a recoverable error.
+    *
+    * <p>This corresponds to the definition of "error" in section 1.2
+    * of the W3C XML 1.0 Recommendation.  For example, a validating
+    * parser would use this callback to report the violation of a
+    * validity constraint.  The default behaviour is to take no
+    * action.</p>
+    *
+    * <p>The SAX parser must continue to provide normal parsing events
+    * after invoking this method: it should still be possible for the
+    * application to process the document through to the end.  If the
+    * application cannot do so, then the parser should report a fatal
+    * error even if the XML 1.0 recommendation does not require it to
+    * do so.</p>
+    *
+    * @param exception The error information encapsulated in a
+    *                  SAX parse exception.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.SAXParseException 
+    */
+  public abstract void error (SAXParseException exception)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of a non-recoverable error.
+    *
+    * <p>This corresponds to the definition of "fatal error" in
+    * section 1.2 of the W3C XML 1.0 Recommendation.  For example, a
+    * parser would use this callback to report the violation of a
+    * well-formedness constraint.</p>
+    *
+    * <p>The application must assume that the document is unusable
+    * after the parser has invoked this method, and should continue
+    * (if at all) only for the sake of collecting addition error
+    * messages: in fact, SAX parsers are free to stop reporting any
+    * other events once this method has been invoked.</p>
+    *
+    * @param exception The error information encapsulated in a
+    *                  SAX parse exception.  
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.SAXParseException
+    */
+  public abstract void fatalError (SAXParseException exception)
+    throws SAXException;
+
+}
--- /dev/null
+++ b/org/xml/sax/HandlerBase.java
@@ -0,0 +1,352 @@
+// SAX default handler base class.
+// No warranty; no copyright -- use this as you will.
+// $Id: HandlerBase.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+/**
+  * Default base class for handlers.
+  *
+  * <p>This class implements the default behaviour for four SAX
+  * interfaces: EntityResolver, DTDHandler, DocumentHandler,
+  * and ErrorHandler.</p>
+  *
+  * <p>Application writers can extend this class when they need to
+  * implement only part of an interface; parser writers can
+  * instantiate this class to provide default handlers when the
+  * application has not supplied its own.</p>
+  *
+  * <p>Note that the use of this class is optional.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.EntityResolver
+  * @see org.xml.sax.DTDHandler
+  * @see org.xml.sax.DocumentHandler
+  * @see org.xml.sax.ErrorHandler
+  */
+public class HandlerBase
+  implements EntityResolver, DTDHandler,
+	     DocumentHandler, ErrorHandler
+{
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Default implementation of the EntityResolver interface.
+  //////////////////////////////////////////////////////////////////////
+
+  /**
+    * Resolve an external entity.
+    *
+    * <p>Always return null, so that the parser will use the system
+    * identifier provided in the XML document.  This method implements
+    * the SAX default behaviour: application writers can override it
+    * in a subclass to do special translations such as catalog lookups
+    * or URI redirection.</p>
+    *
+    * @param publicId The public identifer, or null if none is
+    *                 available.
+    * @param systemId The system identifier provided in the XML 
+    *                 document.
+    * @return The new input source, or null to require the
+    *         default behaviour.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.EntityResolver#resolveEntity
+    */
+  public InputSource resolveEntity (String publicId, String systemId)
+    throws SAXException
+  {
+    return null;
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Default implementation of DTDHandler interface.
+  //////////////////////////////////////////////////////////////////////
+
+
+  /**
+    * Receive notification of a notation declaration.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass if they wish to keep track of the notations
+    * declared in a document.</p>
+    *
+    * @param name The notation name.
+    * @param publicId The notation public identifier, or null if not
+    *                 available.
+    * @param systemId The notation system identifier.
+    * @see org.xml.sax.DTDHandler#notationDecl
+    */
+  public void notationDecl (String name, String publicId, String systemId)
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of an unparsed entity declaration.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to keep track of the unparsed entities
+    * declared in a document.</p>
+    *
+    * @param name The entity name.
+    * @param publicId The entity public identifier, or null if not
+    *                 available.
+    * @param systemId The entity system identifier.
+    * @param notationName The name of the associated notation.
+    * @see org.xml.sax.DTDHandler#unparsedEntityDecl
+    */
+  public void unparsedEntityDecl (String name, String publicId,
+				  String systemId, String notationName)
+  {
+    // no op
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Default implementation of DocumentHandler interface.
+  //////////////////////////////////////////////////////////////////////
+
+
+  /**
+    * Receive a Locator object for document events.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass if they wish to store the locator for use
+    * with other document events.</p>
+    *
+    * @param locator A locator for all SAX document events.
+    * @see org.xml.sax.DocumentHandler#setDocumentLocator
+    * @see org.xml.sax.Locator
+    */
+  public void setDocumentLocator (Locator locator)
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of the beginning of the document.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions at the beginning
+    * of a document (such as allocating the root node of a tree or
+    * creating an output file).</p>
+    *
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.DocumentHandler#startDocument
+    */
+  public void startDocument ()
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of the end of the document.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions at the beginning
+    * of a document (such as finalising a tree or closing an output
+    * file).</p>
+    *
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.DocumentHandler#endDocument
+    */
+  public void endDocument ()
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of the start of an element.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions at the start of
+    * each element (such as allocating a new tree node or writing
+    * output to a file).</p>
+    *
+    * @param name The element type name.
+    * @param attributes The specified or defaulted attributes.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.DocumentHandler#startElement
+    */
+  public void startElement (String name, AttributeList attributes)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of the end of an element.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions at the end of
+    * each element (such as finalising a tree node or writing
+    * output to a file).</p>
+    *
+    * @param name The element type name.
+    * @param attributes The specified or defaulted attributes.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.DocumentHandler#endElement
+    */
+  public void endElement (String name)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of character data inside an element.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method to take specific actions for each chunk of character data
+    * (such as adding the data to a node or buffer, or printing it to
+    * a file).</p>
+    *
+    * @param ch The characters.
+    * @param start The start position in the character array.
+    * @param length The number of characters to use from the
+    *               character array.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.DocumentHandler#characters
+    */
+  public void characters (char ch[], int start, int length)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of ignorable whitespace in element content.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method to take specific actions for each chunk of ignorable
+    * whitespace (such as adding data to a node or buffer, or printing
+    * it to a file).</p>
+    *
+    * @param ch The whitespace characters.
+    * @param start The start position in the character array.
+    * @param length The number of characters to use from the
+    *               character array.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.DocumentHandler#ignorableWhitespace
+    */
+  public void ignorableWhitespace (char ch[], int start, int length)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of a processing instruction.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions for each
+    * processing instruction, such as setting status variables or
+    * invoking other methods.</p>
+    *
+    * @param target The processing instruction target.
+    * @param data The processing instruction data, or null if
+    *             none is supplied.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.DocumentHandler#processingInstruction
+    */
+  public void processingInstruction (String target, String data)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Default implementation of the ErrorHandler interface.
+  //////////////////////////////////////////////////////////////////////
+
+
+  /**
+    * Receive notification of a parser warning.
+    *
+    * <p>The default implementation does nothing.  Application writers
+    * may override this method in a subclass to take specific actions
+    * for each warning, such as inserting the message in a log file or
+    * printing it to the console.</p>
+    *
+    * @param e The warning information encoded as an exception.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.ErrorHandler#warning
+    * @see org.xml.sax.SAXParseException
+    */
+  public void warning (SAXParseException e)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of a recoverable parser error.
+    *
+    * <p>The default implementation does nothing.  Application writers
+    * may override this method in a subclass to take specific actions
+    * for each error, such as inserting the message in a log file or
+    * printing it to the console.</p>
+    *
+    * @param e The warning information encoded as an exception.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.ErrorHandler#warning
+    * @see org.xml.sax.SAXParseException
+    */
+  public void error (SAXParseException e)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Report a fatal XML parsing error.
+    *
+    * <p>The default implementation throws a SAXParseException.
+    * Application writers may override this method in a subclass if
+    * they need to take specific actions for each fatal error (such as
+    * collecting all of the errors into a single report): in any case,
+    * the application must stop all regular processing when this
+    * method is invoked, since the document is no longer reliable, and
+    * the parser may no longer report parsing events.</p>
+    *
+    * @param e The error information encoded as an exception.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see org.xml.sax.ErrorHandler#fatalError
+    * @see org.xml.sax.SAXParseException
+    */
+  public void fatalError (SAXParseException e)
+    throws SAXException
+  {
+    throw e;
+  }
+
+}
--- /dev/null
+++ b/org/xml/sax/InputSource.java
@@ -0,0 +1,312 @@
+// SAX input source.
+// No warranty; no copyright -- use this as you will.
+// $Id: InputSource.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+import java.io.Reader;
+import java.io.InputStream;
+
+/**
+  * A single input source for an XML entity.
+  *
+  * <p>This class allows a SAX application to encapsulate information
+  * about an input source in a single object, which may include
+  * a public identifier, a system identifier, a byte stream (possibly
+  * with a specified encoding), and/or a character stream.</p>
+  *
+  * <p>There are two places that the application will deliver this
+  * input source to the parser: as the argument to the Parser.parse
+  * method, or as the return value of the EntityResolver.resolveEntity
+  * method.</p>
+  *
+  * <p>The SAX parser will use the InputSource object to determine how
+  * to read XML input.  If there is a character stream available, the
+  * parser will read that stream directly; if not, the parser will use
+  * a byte stream, if available; if neither a character stream nor a
+  * byte stream is available, the parser will attempt to open a URI
+  * connection to the resource identified by the system
+  * identifier.</p>
+  *
+  * <p>An InputSource object belongs to the application: the SAX parser
+  * shall never modify it in any way (it may modify a copy if 
+  * necessary).</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.Parser#parse
+  * @see org.xml.sax.EntityResolver#resolveEntity
+  * @see java.io.InputStream
+  * @see java.io.Reader
+  */
+public class InputSource {
+
+  /**
+    * Zero-argument default constructor.
+    *
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setCharacterStream
+    * @see #setEncoding
+    */
+  public InputSource ()
+  {
+  }
+
+
+  /**
+    * Create a new input source with a system identifier.
+    *
+    * <p>Applications may use setPublicId to include a 
+    * public identifier as well, or setEncoding to specify
+    * the character encoding, if known.</p>
+    *
+    * <p>If the system identifier is a URL, it must be full resolved.</p>
+    *
+    * @param systemId The system identifier (URI).
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setEncoding
+    * @see #setCharacterStream
+    */
+  public InputSource (String systemId)
+  {
+    setSystemId(systemId);
+  }
+
+
+  /**
+    * Create a new input source with a byte stream.
+    *
+    * <p>Application writers may use setSystemId to provide a base 
+    * for resolving relative URIs, setPublicId to include a 
+    * public identifier, and/or setEncoding to specify the object's
+    * character encoding.</p>
+    *
+    * @param byteStream The raw byte stream containing the document.
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setEncoding
+    * @see #setByteStream
+    * @see #setCharacterStream
+    */
+  public InputSource (InputStream byteStream)
+  {
+    setByteStream(byteStream);
+  }
+
+
+  /**
+    * Create a new input source with a character stream.
+    *
+    * <p>Application writers may use setSystemId() to provide a base 
+    * for resolving relative URIs, and setPublicId to include a 
+    * public identifier.</p>
+    *
+    * <p>The character stream shall not include a byte order mark.</p>
+    *
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setCharacterStream
+    */
+  public InputSource (Reader characterStream)
+  {
+    setCharacterStream(characterStream);
+  }
+
+
+  /**
+    * Set the public identifier for this input source.
+    *
+    * <p>The public identifier is always optional: if the application
+    * writer includes one, it will be provided as part of the
+    * location information.</p>
+    *
+    * @param publicId The public identifier as a string.
+    * @see #getPublicId
+    * @see org.xml.sax.Locator#getPublicId
+    * @see org.xml.sax.SAXParseException#getPublicId
+    */
+  public void setPublicId (String publicId)
+  {
+    this.publicId = publicId;
+  }
+
+
+  /**
+    * Get the public identifier for this input source.
+    *
+    * @return The public identifier, or null if none was supplied.
+    * @see #setPublicId
+    */
+  public String getPublicId ()
+  {
+    return publicId;
+  }
+
+
+  /**
+    * Set the system identifier for this input source.
+    *
+    * <p>The system identifier is optional if there is a byte stream
+    * or a character stream, but it is still useful to provide one,
+    * since the application can use it to resolve relative URIs
+    * and can include it in error messages and warnings (the parser
+    * will attempt to open a connection to the URI only if
+    * there is no byte stream or character stream specified).</p>
+    *
+    * <p>If the application knows the character encoding of the
+    * object pointed to by the system identifier, it can register
+    * the encoding using the setEncoding method.</p>
+    *
+    * <p>If the system ID is a URL, it must be fully resolved.</p>
+    *
+    * @param systemId The system identifier as a string.
+    * @see #setEncoding
+    * @see #getSystemId
+    * @see org.xml.sax.Locator#getSystemId
+    * @see org.xml.sax.SAXParseException#getSystemId
+    */
+  public void setSystemId (String systemId)
+  {
+    this.systemId = systemId;
+  }
+
+
+  /**
+    * Get the system identifier for this input source.
+    *
+    * <p>The getEncoding method will return the character encoding
+    * of the object pointed to, or null if unknown.</p>
+    *
+    * <p>If the system ID is a URL, it will be fully resolved.</p>
+    *
+    * @return The system identifier.
+    * @see #setSystemId
+    * @see #getEncoding
+    */
+  public String getSystemId ()
+  {
+    return systemId;
+  }
+
+
+  /**
+    * Set the byte stream for this input source.
+    *
+    * <p>The SAX parser will ignore this if there is also a character
+    * stream specified, but it will use a byte stream in preference
+    * to opening a URI connection itself.</p>
+    *
+    * <p>If the application knows the character encoding of the
+    * byte stream, it should set it with the setEncoding method.</p>
+    *
+    * @param byteStream A byte stream containing an XML document or
+    *        other entity.
+    * @see #setEncoding
+    * @see #getByteStream
+    * @see #getEncoding
+    * @see java.io.InputStream
+    */
+  public void setByteStream (InputStream byteStream)
+  {
+    this.byteStream = byteStream;
+  }
+
+
+  /**
+    * Get the byte stream for this input source.
+    *
+    * <p>The getEncoding method will return the character
+    * encoding for this byte stream, or null if unknown.</p>
+    *
+    * @return The byte stream, or null if none was supplied.
+    * @see #getEncoding
+    * @see #setByteStream
+    */
+  public InputStream getByteStream ()
+  {
+    return byteStream;
+  }
+
+
+  /** 
+    * Set the character encoding, if known.
+    *
+    * <p>The encoding must be a string acceptable for an
+    * XML encoding declaration (see section 4.3.3 of the XML 1.0
+    * recommendation).</p>
+    *
+    * <p>This method has no effect when the application provides a
+    * character stream.</p>
+    *
+    * @param encoding A string describing the character encoding.
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #getEncoding
+    */
+  public void setEncoding (String encoding)
+  {
+    this.encoding = encoding;
+  }
+
+
+  /**
+    * Get the character encoding for a byte stream or URI.
+    *
+    * @return The encoding, or null if none was supplied.
+    * @see #setByteStream
+    * @see #getSystemId
+    * @see #getByteStream
+    */
+  public String getEncoding ()
+  {
+    return encoding;
+  }
+
+
+  /**
+    * Set the character stream for this input source.
+    *
+    * <p>If there is a character stream specified, the SAX parser
+    * will ignore any byte stream and will not attempt to open
+    * a URI connection to the system identifier.</p>
+    *
+    * @param characterStream The character stream containing the
+    *        XML document or other entity.
+    * @see #getCharacterStream
+    * @see java.io.Reader
+    */
+  public void setCharacterStream (Reader characterStream)
+  {
+    this.characterStream = characterStream;
+  }
+
+
+  /**
+    * Get the character stream for this input source.
+    *
+    * @return The character stream, or null if none was supplied.
+    * @see #setCharacterStream
+    */
+  public Reader getCharacterStream ()
+  {
+    return characterStream;
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Internal state.
+  //////////////////////////////////////////////////////////////////////
+
+  private String publicId;
+  private String systemId;
+  private InputStream byteStream;
+  private String encoding;
+  private Reader characterStream;
+
+}
--- /dev/null
+++ b/org/xml/sax/Locator.java
@@ -0,0 +1,80 @@
+// SAX locator interface for document events.
+// No warranty; no copyright -- use this as you will.
+// $Id: Locator.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+
+/**
+  * Interface for associating a SAX event with a document location.
+  *
+  * <p>If a SAX parser provides location information to the SAX
+  * application, it does so by implementing this interface and then
+  * passing an instance to the application using the document
+  * handler's setDocumentLocator method.  The application can use the
+  * object to obtain the location of any other document handler event
+  * in the XML source document.</p>
+  *
+  * <p>Note that the results returned by the object will be valid only
+  * during the scope of each document handler method: the application
+  * will receive unpredictable results if it attempts to use the
+  * locator at any other time.</p>
+  *
+  * <p>SAX parsers are not required to supply a locator, but they are
+  * very strong encouraged to do so.  If the parser supplies a
+  * locator, it must do so before reporting any other document events.
+  * If no locator has been set by the time the application receives
+  * the startDocument event, the application should assume that a
+  * locator is not available.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.DocumentHandler#setDocumentLocator 
+  */
+public interface Locator {
+
+
+  /**
+    * Return the public identifier for the current document event.
+    * <p>This will be the public identifier
+    * @return A string containing the public identifier, or
+    *         null if none is available.
+    * @see #getSystemId
+    */
+  public abstract String getPublicId ();
+
+
+  /**
+    * Return the system identifier for the current document event.
+    *
+    * <p>If the system identifier is a URL, the parser must resolve it
+    * fully before passing it to the application.</p>
+    *
+    * @return A string containing the system identifier, or null
+    *         if none is available.
+    * @see #getPublicId
+    */
+  public abstract String getSystemId ();
+
+
+  /**
+    * Return the line number where the current document event ends.
+    * Note that this is the line position of the first character
+    * after the text associated with the document event.
+    * @return The line number, or -1 if none is available.
+    * @see #getColumnNumber
+    */
+  public abstract int getLineNumber ();
+
+
+  /**
+    * Return the column number where the current document event ends.
+    * Note that this is the column number of the first
+    * character after the text associated with the document
+    * event.  The first column in a line is position 1.
+    * @return The column number, or -1 if none is available.
+    * @see #getLineNumber
+    */
+  public abstract int getColumnNumber ();
+
+}
--- /dev/null
+++ b/org/xml/sax/Parser.java
@@ -0,0 +1,190 @@
+// SAX parser interface.
+// No warranty; no copyright -- use this as you will.
+// $Id: Parser.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+import java.io.IOException;
+import java.util.Locale;
+
+
+/**
+  * Basic interface for SAX (Simple API for XML) parsers.
+  *
+  * <p>All SAX parsers must implement this basic interface: it allows
+  * applications to register handlers for different types of events
+  * and to initiate a parse from a URI, or a character stream.</p>
+  *
+  * <p>All SAX parsers must also implement a zero-argument constructor
+  * (though other constructors are also allowed).</p>
+  *
+  * <p>SAX parsers are reusable but not re-entrant: the application
+  * may reuse a parser object (possibly with a different input source)
+  * once the first parse has completed successfully, but it may not
+  * invoke the parse() methods recursively within a parse.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.EntityResolver
+  * @see org.xml.sax.DTDHandler
+  * @see org.xml.sax.DocumentHandler
+  * @see org.xml.sax.ErrorHandler
+  * @see org.xml.sax.HandlerBase
+  * @see org.xml.sax.InputSource
+  */
+public interface Parser 
+{
+
+  /**
+    * Allow an application to request a locale for errors and warnings.
+    *
+    * <p>SAX parsers are not required to provide localisation for errors
+    * and warnings; if they cannot support the requested locale,
+    * however, they must throw a SAX exception.  Applications may
+    * not request a locale change in the middle of a parse.</p>
+    *
+    * @param locale A Java Locale object.
+    * @exception org.xml.sax.SAXException Throws an exception
+    *            (using the previous or default locale) if the 
+    *            requested locale is not supported.
+    * @see org.xml.sax.SAXException
+    * @see org.xml.sax.SAXParseException
+    */
+  public abstract void setLocale (Locale locale)
+    throws SAXException;
+
+
+  /**
+    * Allow an application to register a custom entity resolver.
+    *
+    * <p>If the application does not register an entity resolver, the
+    * SAX parser will resolve system identifiers and open connections
+    * to entities itself (this is the default behaviour implemented in
+    * HandlerBase).</p>
+    *
+    * <p>Applications may register a new or different entity resolver
+    * in the middle of a parse, and the SAX parser must begin using
+    * the new resolver immediately.</p>
+    *
+    * @param resolver The object for resolving entities.
+    * @see EntityResolver
+    * @see HandlerBase
+    */
+  public abstract void setEntityResolver (EntityResolver resolver);
+
+
+  /**
+    * Allow an application to register a DTD event handler.
+    *
+    * <p>If the application does not register a DTD handler, all DTD
+    * events reported by the SAX parser will be silently
+    * ignored (this is the default behaviour implemented by
+    * HandlerBase).</p>
+    *
+    * <p>Applications may register a new or different
+    * handler in the middle of a parse, and the SAX parser must
+    * begin using the new handler immediately.</p>
+    *
+    * @param handler The DTD handler.
+    * @see DTDHandler
+    * @see HandlerBase
+    */
+  public abstract void setDTDHandler (DTDHandler handler);
+
+
+  /**
+    * Allow an application to register a document event handler.
+    *
+    * <p>If the application does not register a document handler, all
+    * document events reported by the SAX parser will be silently
+    * ignored (this is the default behaviour implemented by
+    * HandlerBase).</p>
+    *
+    * <p>Applications may register a new or different handler in the
+    * middle of a parse, and the SAX parser must begin using the new
+    * handler immediately.</p>
+    *
+    * @param handler The document handler.
+    * @see DocumentHandler
+    * @see HandlerBase
+    */
+  public abstract void setDocumentHandler (DocumentHandler handler);
+
+
+  /**
+    * Allow an application to register an error event handler.
+    *
+    * <p>If the application does not register an error event handler,
+    * all error events reported by the SAX parser will be silently
+    * ignored, except for fatalError, which will throw a SAXException
+    * (this is the default behaviour implemented by HandlerBase).</p>
+    *
+    * <p>Applications may register a new or different handler in the
+    * middle of a parse, and the SAX parser must begin using the new
+    * handler immediately.</p>
+    *
+    * @param handler The error handler.
+    * @see ErrorHandler
+    * @see SAXException
+    * @see HandlerBase
+    */
+  public abstract void setErrorHandler (ErrorHandler handler);
+
+
+  /**
+    * Parse an XML document.
+    *
+    * <p>The application can use this method to instruct the SAX parser
+    * to begin parsing an XML document from any valid input
+    * source (a character stream, a byte stream, or a URI).</p>
+    *
+    * <p>Applications may not invoke this method while a parse is in
+    * progress (they should create a new Parser instead for each
+    * additional XML document).  Once a parse is complete, an
+    * application may reuse the same Parser object, possibly with a
+    * different input source.</p>
+    *
+    * @param source The input source for the top-level of the
+    *        XML document.
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException An IO exception from the parser,
+    *            possibly from a byte stream or character stream
+    *            supplied by the application.
+    * @see org.xml.sax.InputSource
+    * @see #parse(java.lang.String)
+    * @see #setEntityResolver
+    * @see #setDTDHandler
+    * @see #setDocumentHandler
+    * @see #setErrorHandler
+    */
+  public abstract void parse (InputSource source)
+    throws SAXException, IOException;
+
+
+  /**
+    * Parse an XML document from a system identifier (URI).
+    *
+    * <p>This method is a shortcut for the common case of reading a
+    * document from a system identifier.  It is the exact
+    * equivalent of the following:</p>
+    *
+    * <pre>
+    * parse(new InputSource(systemId));
+    * </pre>
+    *
+    * <p>If the system identifier is a URL, it must be fully resolved
+    * by the application before it is passed to the parser.</p>
+    *
+    * @param systemId The system identifier (URI).
+    * @exception org.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException An IO exception from the parser,
+    *            possibly from a byte stream or character stream
+    *            supplied by the application.
+    * @see #parse(org.xml.sax.InputSource)
+    */
+  public abstract void parse (String systemId)
+    throws SAXException, IOException;
+
+}
--- /dev/null
+++ b/org/xml/sax/SAXException.java
@@ -0,0 +1,129 @@
+// SAX exception class.
+// No warranty; no copyright -- use this as you will.
+// $Id: SAXException.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+/**
+  * Encapsulate a general SAX error or warning.
+  *
+  * <p>This class can contain basic error or warning information from
+  * either the XML parser or the application: a parser writer or
+  * application writer can subclass it to provide additional
+  * functionality.  SAX handlers may throw this exception or
+  * any exception subclassed from it.</p>
+  *
+  * <p>If the application needs to pass through other types of
+  * exceptions, it must wrap those exceptions in a SAXException
+  * or an exception derived from a SAXException.</p>
+  *
+  * <p>If the parser or application needs to include information about a
+  * specific location in an XML document, it should use the
+  * SAXParseException subclass.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.SAXParseException
+  */
+public class SAXException extends Exception {
+
+
+  /**
+    * Create a new SAXException.
+    *
+    * @param message The error or warning message.
+    * @see org.xml.sax.Parser#setLocale
+    */
+  public SAXException (String message) {
+    super();
+    this.message = message;
+    this.exception = null;
+  }
+
+
+  /**
+    * Create a new SAXException wrapping an existing exception.
+    *
+    * <p>The existing exception will be embedded in the new
+    * one, and its message will become the default message for
+    * the SAXException.</p>
+    *
+    * @param e The exception to be wrapped in a SAXException.
+    */
+  public SAXException (Exception e)
+  {
+    super();
+    this.message = null;
+    this.exception = e;
+  }
+
+
+  /**
+    * Create a new SAXException from an existing exception.
+    *
+    * <p>The existing exception will be embedded in the new
+    * one, but the new exception will have its own message.</p>
+    *
+    * @param message The detail message.
+    * @param e The exception to be wrapped in a SAXException.
+    * @see org.xml.sax.Parser#setLocale
+    */
+  public SAXException (String message, Exception e)
+  {
+    super();
+    this.message = message;
+    this.exception = e;
+  }
+
+
+  /**
+    * Return a detail message for this exception.
+    *
+    * <p>If there is a embedded exception, and if the SAXException
+    * has no detail message of its own, this method will return
+    * the detail message from the embedded exception.</p>
+    *
+    * @return The error or warning message.
+    * @see org.xml.sax.Parser#setLocale
+    */
+  public String getMessage ()
+  {
+    if (message == null && exception != null) {
+      return exception.getMessage();
+    } else {
+      return this.message;
+    }
+  }
+
+
+  /**
+    * Return the embedded exception, if any.
+    *
+    * @return The embedded exception, or null if there is none.
+    */
+  public Exception getException ()
+  {
+    return exception;
+  }
+
+
+  /**
+    * Convert this exception to a string.
+    *
+    * @return A string version of this exception.
+    */
+  public String toString ()
+  {
+    return getMessage();
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Internal state.
+  //////////////////////////////////////////////////////////////////////
+
+  private String message;
+  private Exception exception;
+
+}
--- /dev/null
+++ b/org/xml/sax/SAXParseException.java
@@ -0,0 +1,210 @@
+// SAX exception class.
+// No warranty; no copyright -- use this as you will.
+// $Id: SAXParseException.java 233605 2001-11-06 18:33:40Z hannes $
+
+package org.xml.sax;
+
+/**
+  * Encapsulate an XML parse error or warning.
+  *
+  * <p>This exception will include information for locating the error
+  * in the original XML document.  Note that although the application
+  * will receive a SAXParseException as the argument to the handlers
+  * in the ErrorHandler interface, the application is not actually
+  * required to throw the exception; instead, it can simply read the
+  * information in it and take a different action.</p>
+  *
+  * <p>Since this exception is a subclass of SAXException, it
+  * inherits the ability to wrap another exception.</p>
+  *
+  * @author David Megginson (ak117@freenet.carleton.ca)
+  * @version 1.0
+  * @see org.xml.sax.SAXException
+  * @see org.xml.sax.Locator
+  * @see org.xml.sax.ErrorHandler
+  */
+public class SAXParseException extends SAXException {
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Constructors.
+  //////////////////////////////////////////////////////////////////////
+
+  /**
+    * Create a new SAXParseException from a message and a Locator.
+    *
+    * <p>This constructor is especially useful when an application is
+    * creating its own exception from within a DocumentHandler
+    * callback.</p>
+    *
+    * @param message The error or warning message.
+    * @param locator The locator object for the error or warning.
+    * @see org.xml.sax.Locator
+    * @see org.xml.sax.Parser#setLocale 
+    */
+  public SAXParseException (String message, Locator locator) {
+    super(message);
+    this.publicId = locator.getPublicId();
+    this.systemId = locator.getSystemId();
+    this.lineNumber = locator.getLineNumber();
+    this.columnNumber = locator.getColumnNumber();
+  }
+
+
+  /**
+    * Wrap an existing exception in a SAXParseException.
+    *
+    * <p>This constructor is especially useful when an application is
+    * creating its own exception from within a DocumentHandler
+    * callback, and needs to wrap an existing exception that is not a
+    * subclass of SAXException.</p>
+    *
+    * @param message The error or warning message, or null to
+    *                use the message from the embedded exception.
+    * @param locator The locator object for the error or warning.
+    * @param e Any exception
+    * @see org.xml.sax.Locator
+    * @see org.xml.sax.Parser#setLocale
+    */
+  public SAXParseException (String message, Locator locator,
+			    Exception e) {
+    super(message, e);
+    this.publicId = locator.getPublicId();
+    this.systemId = locator.getSystemId();
+    this.lineNumber = locator.getLineNumber();
+    this.columnNumber = locator.getColumnNumber();
+  }
+
+
+  /**
+    * Create a new SAXParseException.
+    *
+    * <p>This constructor is most useful for parser writers.</p>
+    *
+    * <p>If the system identifier is a URL, the parser must resolve it
+    * fully before creating the exception.</p>
+    *
+    * @param message The error or warning message.
+    * @param publicId The public identifer of the entity that generated
+    *                 the error or warning.
+    * @param systemId The system identifer of the entity that generated
+    *                 the error or warning.
+    * @param lineNumber The line number of the end of the text that
+    *                   caused the error or warning.
+    * @param columnNumber The column number of the end of the text that
+    *                     cause the error or warning.
+    * @see org.xml.sax.Parser#setLocale
+    */
+  public SAXParseException (String message, String publicId, String systemId,
+			    int lineNumber, int columnNumber)
+  {
+    super(message);
+    this.publicId = publicId;
+    this.systemId = systemId;
+    this.lineNumber = lineNumber;
+    this.columnNumber = columnNumber;
+  }
+
+
+  /**
+    * Create a new SAXParseException with an embedded exception.
+    *
+    * <p>This constructor is most useful for parser writers who
+    * need to wrap an exception that is not a subclass of
+    * SAXException.</p>
+    *
+    * <p>If the system identifier is a URL, the parser must resolve it
+    * fully before creating the exception.</p>
+    *
+    * @param message The error or warning message, or null to use
+    *                the message from the embedded exception.
+    * @param publicId The public identifer of the entity that generated
+    *                 the error or warning.
+    * @param systemId The system identifer of the entity that generated
+    *                 the error or warning.
+    * @param lineNumber The line number of the end of the text that
+    *                   caused the error or warning.
+    * @param columnNumber The column number of the end of the text that
+    *                     cause the error or warning.
+    * @param e Another exception to embed in this one.
+    * @see org.xml.sax.Parser#setLocale
+    */
+  public SAXParseException (String message, String publicId, String systemId,
+			    int lineNumber, int columnNumber, Exception e)
+  {
+    super(message, e);
+    this.publicId = publicId;
+    this.systemId = systemId;
+    this.lineNumber = lineNumber;
+    this.columnNumber = columnNumber;
+  }
+
+
+  /**
+    * Get the public identifier of the entity where the exception occurred.
+    *
+    * @return A string containing the public identifier, or null
+    *         if none is available.
+    * @see org.xml.sax.Locator#getPublicId
+    */
+  public String getPublicId ()
+  {
+    return this.publicId;
+  }
+
+
+  /**
+    * Get the system identifier of the entity where the exception occurred.
+    *
+    * <p>If the system identifier is a URL, it will be resolved
+    * fully.</p>
+    *
+    * @return A string containing the system identifier, or null
+    *         if none is available.
+    * @see org.xml.sax.Locator#getSystemId
+    */
+  public String getSystemId ()
+  {
+    return this.systemId;
+  }
+
+
+  /**
+    * The line number of the end of the text where the exception occurred.
+    *
+    * @return An integer representing the line number, or -1
+    *         if none is available.
+    * @see org.xml.sax.Locator#getLineNumber
+    */
+  public int getLineNumber ()
+  {
+    return this.lineNumber;
+  }
+
+
+  /**
+    * The column number of the end of the text where the exception occurred.
+    *
+    * <p>The first column in a line is position 1.</p>
+    *
+    * @return An integer representing the column number, or -1
+    *         if none is available.
+    * @see org.xml.sax.Locator#getColumnNumber
+    */
+  public int getColumnNumber ()
+  {
+    return this.columnNumber;
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Internal state.
+  //////////////////////////////////////////////////////////////////////
+
+  private String publicId;
+  private String systemId;
+  private int lineNumber;
+  private int columnNumber;
+
+}
--- /dev/null
+++ b/uk/co/wilson/xml/MinML.java
@@ -0,0 +1,768 @@
+// Copyright (c) 2000, 2001 The Wilson Partnership.
+// All Rights Reserved.
+// @(#)MinML.java, 1.7, 18th November 2001
+// Author: John Wilson - tug@wilson.co.uk
+
+package uk.co.wilson.xml;
+
+/*
+Copyright (c) 2000, 2001 John Wilson (tug@wilson.co.uk).
+All rights reserved.
+Redistribution and use in source and binary forms,
+with or without modification, are permitted provided
+that the following conditions are met:
+
+Redistributions of source code must retain the above
+copyright notice, this list of conditions and the
+following disclaimer.
+
+Redistributions in binary form must reproduce the
+above copyright notice, this list of conditions and
+the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+
+All advertising materials mentioning features or use
+of this software must display the following acknowledgement:
+
+This product includes software developed by John Wilson.
+The name of John Wilson may not be used to endorse or promote
+products derived from this software without specific prior
+written permission.
+
+THIS SOFTWARE IS PROVIDED BY JOHN WILSON ``AS IS'' AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JOHN WILSON
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+OF THE POSSIBILITY OF SUCH DAMAGE
+*/
+
+import java.io.InputStream;
+import java.io.Reader;
+import java.io.Writer;
+import java.io.InputStreamReader;
+import java.io.IOException;
+
+import java.net.URL;
+
+import java.util.Locale;
+import java.util.Vector;
+import java.util.Stack;
+import java.util.EmptyStackException;
+
+import uk.org.xml.sax.Parser;
+import uk.org.xml.sax.DocumentHandler;
+
+import org.xml.sax.EntityResolver;
+import org.xml.sax.DTDHandler;
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.Locator;
+import org.xml.sax.InputSource;
+import org.xml.sax.AttributeList;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+public class MinML implements Parser, Locator, DocumentHandler, ErrorHandler {
+  public static final int endStartName = 0;
+  public static final int emitStartElement = 1;
+  public static final int emitEndElement = 2;
+  public static final int possiblyEmitCharacters = 3;
+  public static final int emitCharacters = 4;
+  public static final int emitCharactersSave = 5;
+  public static final int saveAttributeName = 6;
+  public static final int saveAttributeValue = 7;
+  public static final int startComment = 8;
+  public static final int endComment = 9;
+  public static final int incLevel = 10;
+  public static final int decLevel = 11;
+  public static final int startCDATA = 12;
+  public static final int endCDATA = 13;
+  public static final int processCharRef = 14;
+  public static final int writeCdata = 15;
+  public static final int exitParser = 16;
+  public static final int parseError = 17;
+  public static final int discardAndChange = 18;
+  public static final int discardSaveAndChange = 19;
+  public static final int saveAndChange = 20;
+  public static final int change = 21;
+
+  public static final int inSkipping = 0;
+  public static final int inSTag = 1;
+  public static final int inPossiblyAttribute = 2;
+  public static final int inNextAttribute = 3;
+  public static final int inAttribute = 4;
+  public static final int inAttribute1 = 5;
+  public static final int inAttributeValue = 6;
+  public static final int inAttributeQuoteValue = 7;
+  public static final int inAttributeQuotesValue = 8;
+  public static final int inETag = 9;
+  public static final int inETag1 = 10;
+  public static final int inMTTag = 11;
+  public static final int inTag = 12;
+  public static final int inTag1 = 13;
+  public static final int inPI = 14;
+  public static final int inPI1 = 15;
+  public static final int inPossiblySkipping = 16;
+  public static final int inCharData = 17;
+  public static final int inCDATA = 18;
+  public static final int inCDATA1 = 19;
+  public static final int inComment =20;
+  public static final int inDTD = 21;
+
+  public MinML(final int initialBufferSize, final int bufferIncrement) {
+    this.initialBufferSize = initialBufferSize;
+    this.bufferIncrement = bufferIncrement;
+  }
+
+  public MinML() {
+    this(256, 128);
+  }
+
+  public void parse(final Reader in) throws SAXException, IOException {
+  final Vector attributeNames = new Vector();
+  final Vector attributeValues = new Vector();
+
+  final AttributeList attrs = new AttributeList() {
+    public int getLength() {
+      return attributeNames.size();
+    }
+
+    public String getName(final int i) {
+      return (String)attributeNames.elementAt(i);
+    }
+
+    public String getType(final int i) {
+      return "CDATA";
+    }
+
+    public String getValue(final int i) {
+      return (String)attributeValues.elementAt(i);
+    }
+
+    public String getType(final String name) {
+      return "CDATA";
+    }
+
+    public String getValue(final String name) {
+    final int index = attributeNames.indexOf(name);
+
+      return (index == -1) ? null : (String)attributeValues.elementAt(index);
+    }
+  };
+
+  final MinMLBuffer buffer = new MinMLBuffer(in);
+  int currentChar = 0, charCount = 0;
+  int level = 0;
+  int mixedContentLevel = -1;
+  String elementName = null;
+  String state = operands[inSkipping];
+
+    this.lineNumber = 1;
+    this.columnNumber = 0;
+
+    try {
+      while(true) {
+        charCount++;
+
+        //
+        // this is to try and make the loop a bit faster
+        // currentChar = buffer.read(); is simpler but is a bit slower.
+        //
+        currentChar = (buffer.nextIn == buffer.lastIn) ? buffer.read() : buffer.chars[buffer.nextIn++];
+
+        final int transition;
+
+        if (currentChar > ']') {
+          transition = state.charAt(14);
+        } else {
+        final int charClass = charClasses[currentChar + 1];
+
+          if (charClass == -1) fatalError("Document contains illegal control character with value " + currentChar, this.lineNumber, this.columnNumber);
+
+          if (charClass == 12) {
+            if (currentChar == '\r') {
+              currentChar = '\n';
+              charCount = -1;
+            }
+
+            if (currentChar == '\n') {
+              if (charCount == 0) continue;  // preceeded by '\r' so ignore
+
+              if (charCount != -1) charCount = 0;
+
+              this.lineNumber++;
+              this.columnNumber = 0;
+            }
+          }
+
+          transition = state.charAt(charClass);
+       }
+
+        this.columnNumber++;
+
+        final String operand = operands[transition >>> 8];
+
+        switch (transition & 0XFF) {
+          case endStartName:
+          // end of start element name
+            elementName = buffer.getString();
+            if (currentChar != '>' && currentChar != '/') break;  // change state to operand
+            // drop through to emit start element (we have no attributes)
+
+          case emitStartElement:
+          // emit start element
+
+          final Writer newWriter = this.extDocumentHandler.startElement(elementName, attrs,
+                                                                        (this.tags.empty()) ?
+                                                                          this.extDocumentHandler.startDocument(buffer)
+                                                                        :
+                                                                          buffer.getWriter());
+
+            buffer.pushWriter(newWriter);
+            this.tags.push(elementName);
+
+            attributeValues.removeAllElements();
+            attributeNames.removeAllElements();
+
+            if (mixedContentLevel != -1) mixedContentLevel++;
+
+            if (currentChar != '/') break;  // change state to operand
+
+            // <element/> drop through
+
+          case emitEndElement:
+          // emit end element
+
+            try {
+            final String begin = (String)this.tags.pop();
+
+              buffer.popWriter();
+              elementName = buffer.getString();
+
+              if (currentChar != '/' && !elementName.equals(begin)) {
+               fatalError("end tag </" + elementName + "> does not match begin tag <" + begin + ">",
+                           this.lineNumber, this.columnNumber);
+              } else {
+                this.documentHandler.endElement(begin);
+
+                if (this.tags.empty()) {
+                  this.documentHandler.endDocument();
+                  return;
+                }
+              }
+            }
+            catch (final EmptyStackException e) {
+              fatalError("end tag at begining of document", this.lineNumber, this.columnNumber);
+            }
+
+            if (mixedContentLevel != -1) --mixedContentLevel;
+
+            break;  // change state to operand
+
+          case emitCharacters:
+          // emit characters
+
+            buffer.flush();
+            break;  // change state to operand
+
+          case emitCharactersSave:
+          // emit characters and save current character
+
+            if (mixedContentLevel == -1) mixedContentLevel = 0;
+
+            buffer.flush();
+
+            buffer.saveChar((char)currentChar);
+
+            break;  // change state to operand
+
+          case possiblyEmitCharacters:
+          // write any skipped whitespace if in mixed content
+
+            if (mixedContentLevel != -1) buffer.flush();
+            break;  // change state to operand
+
+          case saveAttributeName:
+          // save attribute name
+
+            attributeNames.addElement(buffer.getString());
+            break;  // change state to operand
+
+          case saveAttributeValue:
+          // save attribute value
+
+            attributeValues.addElement(buffer.getString());
+            break;  // change state to operand
+
+          case startComment:
+          // change state if we have found "<!--"
+
+            if (buffer.read() != '-') continue; // not "<!--"
+
+            break;  // change state to operand
+
+          case endComment:
+          // change state if we find "-->"
+
+            if ((currentChar = buffer.read()) == '-') {
+              // deal with the case where we might have "------->"
+              while ((currentChar = buffer.read()) == '-');
+
+              if (currentChar == '>') break;  // end of comment, change state to operand
+            }
+
+            continue;   // not end of comment, don't change state
+
+          case incLevel:
+
+            level++;
+
+            break;
+
+          case decLevel:
+
+            if (level == 0) break; // outer level <> change state
+
+            level--;
+
+            continue; // in nested <>, don't change state
+
+          case startCDATA:
+          // change state if we have found "<![CDATA["
+
+            if (buffer.read() != 'C') continue;   // don't change state
+            if (buffer.read() != 'D') continue;   // don't change state
+            if (buffer.read() != 'A') continue;   // don't change state
+            if (buffer.read() != 'T') continue;   // don't change state
+            if (buffer.read() != 'A') continue;   // don't change state
+            if (buffer.read() != '[') continue;   // don't change state
+            break;  // change state to operand
+
+          case endCDATA:
+          // change state if we find "]]>"
+
+            if ((currentChar = buffer.read()) == ']') {
+              // deal with the case where we might have "]]]]]]]>"
+              while ((currentChar = buffer.read()) == ']') buffer.write(']');
+
+              if (currentChar == '>') break;  // end of CDATA section, change state to operand
+
+              buffer.write(']');
+            }
+
+            buffer.write(']');
+            buffer.write(currentChar);
+            continue;   // not end of CDATA section, don't change state
+
+          case processCharRef:
+          // process character entity
+
+            int crefState = 0;
+
+            currentChar = buffer.read();
+
+            while (true) {
+              if ("#amp;&pos;'quot;\"gt;>lt;<".charAt(crefState) == currentChar) {
+                crefState++;
+
+                if (currentChar == ';') {
+                  buffer.write("#amp;&pos;'quot;\"gt;>lt;<".charAt(crefState));
+                  break;
+
+                } else if (currentChar == '#') {
+                final int radix;
+
+                  currentChar = buffer.read();
+
+                  if (currentChar == 'x') {
+                    radix = 16;
+                    currentChar = buffer.read();
+                  } else {
+                    radix = 10;
+                  }
+
+                  int charRef = Character.digit((char)currentChar, radix);
+
+                  while (true) {
+                    currentChar = buffer.read();
+
+                    final int digit = Character.digit((char)currentChar, radix);
+
+                    if (digit == -1) break;
+
+                    charRef = (char)((charRef * radix) + digit);
+                  }
+
+                  if (currentChar == ';' && charRef != -1) {
+                    buffer.write(charRef);
+                    break;
+                  }
+
+                  fatalError("invalid Character Entitiy", this.lineNumber, this.columnNumber);
+                } else {
+                  currentChar = buffer.read();
+                }
+              } else {
+                crefState = ("\u0001\u000b\u0006\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff" +
+//                               #     a     m     p     ;     &     p     o     s     ;     '
+//                               0     1     2     3     4     5     6     7     8     9     a
+                             "\u0011\u00ff\u00ff\u00ff\u00ff\u00ff\u0015\u00ff\u00ff\u00ff" +
+//                               q     u     o     t     ;     "     g     t     ;     >
+//                               b     b     d     e     f     10    11    12    13    14
+                             "\u00ff\u00ff\u00ff").charAt(crefState);
+//                               l     t     ;
+//                               15    16    17
+
+                if (crefState == 255) fatalError("invalid Character Entitiy", this.lineNumber, this.columnNumber);
+              }
+            }
+
+            break;
+
+          case parseError:
+          // report fatal error
+
+            fatalError(operand, this.lineNumber, this.columnNumber);
+            // drop through to exit parser
+
+          case exitParser:
+          // exit parser
+
+            return;
+
+          case writeCdata:
+          // write character data
+          // this will also write any skipped whitespace
+
+            buffer.write(currentChar);
+            break;  // change state to operand
+
+          case discardAndChange:
+          // throw saved characters away and change state
+
+            buffer.reset();
+            break;  // change state to operand
+
+          case discardSaveAndChange:
+          // throw saved characters away, save character and change state
+
+            buffer.reset();
+            // drop through to save character and change state
+
+          case saveAndChange:
+          // save character and change state
+
+            buffer.saveChar((char)currentChar);
+            break;  // change state to operand
+
+          case change:
+          // change state to operand
+
+            break;  // change state to operand
+        }
+
+        state = operand;
+      }
+    }
+    catch (final IOException e) {
+      this.errorHandler.fatalError(new SAXParseException(e.toString(), null, null, this.lineNumber, this.columnNumber, e));
+    }
+    finally {
+      this.errorHandler = this;
+      this.documentHandler = this.extDocumentHandler = this;
+      this.tags.removeAllElements();
+    }
+  }
+
+  public void parse(final InputSource source) throws SAXException, IOException {
+    if (source.getCharacterStream() != null)
+      parse(source.getCharacterStream());
+    else if (source.getByteStream() != null)
+      parse(new InputStreamReader(source.getByteStream()));
+    else
+     parse(new InputStreamReader(new URL(source.getSystemId()).openStream()));
+  }
+
+  public void parse(final String systemId) throws SAXException, IOException {
+    parse(new InputSource(systemId));
+  }
+
+  public void setLocale(final Locale locale) throws SAXException {
+    throw new SAXException("Not supported");
+  }
+
+  public void setEntityResolver(final EntityResolver resolver) {
+    // not supported
+  }
+
+  public void setDTDHandler(final DTDHandler handler) {
+    // not supported
+  }
+
+  public void setDocumentHandler(final org.xml.sax.DocumentHandler handler) {
+   this.documentHandler = (handler == null) ? this : handler;
+   this.extDocumentHandler = this;
+  }
+
+  public void setDocumentHandler(final DocumentHandler handler) {
+   this.documentHandler = this.extDocumentHandler = (handler == null) ? this : handler;
+   this.documentHandler.setDocumentLocator(this);
+  }
+
+  public void setErrorHandler(final ErrorHandler handler) {
+   this.errorHandler = (handler == null) ? this : handler;
+  }
+
+  public void setDocumentLocator(final Locator locator) {
+  }
+
+  public void startDocument() throws SAXException {
+  }
+
+  public Writer startDocument(final Writer writer) throws SAXException {
+    this.documentHandler.startDocument();
+    return writer;
+  }
+
+  public void endDocument() throws SAXException {
+  }
+
+  public void startElement(final String name, final AttributeList attributes) throws SAXException {
+  }
+
+  public Writer startElement(final String name, final AttributeList attributes, final Writer writer)
+        throws SAXException
+  {
+    this.documentHandler.startElement(name, attributes);
+    return writer;
+  }
+
+  public void endElement(final String name) throws SAXException {
+  }
+
+  public void characters(final char ch[], final int start, final int length) throws SAXException {
+  }
+
+  public void ignorableWhitespace(final char ch[], final int start, final int length) throws SAXException {
+  }
+
+  public void processingInstruction(final String target, final String data) throws SAXException {
+  }
+
+  public void warning(final SAXParseException e) throws SAXException {
+  }
+
+  public void error(final SAXParseException e) throws SAXException {
+  }
+
+  public void fatalError(final SAXParseException e) throws SAXException {
+    throw e;
+  }
+
+  public String getPublicId() {
+    return "";
+  }
+
+
+  public String getSystemId() {
+    return "";
+  }
+
+  public int getLineNumber () {
+    return this.lineNumber;
+  }
+
+  public int getColumnNumber () {
+    return this.columnNumber;
+  }
+
+  private void fatalError(final String msg, final int lineNumber, final int columnNumber) throws SAXException {
+    this.errorHandler.fatalError(new SAXParseException(msg, null, null, lineNumber, columnNumber));
+  }
+
+  private class MinMLBuffer extends Writer {
+    public MinMLBuffer(final Reader in) {
+      this.in = in;
+    }
+
+    public void close() throws IOException {
+      flush();
+    }
+
+    public void flush() throws IOException {
+      try {
+        _flush();
+        if (writer != this) writer.flush();
+      }
+      finally {
+        flushed = true;
+      }
+    }
+
+    public void write(final int c) throws IOException {
+      written = true;
+      chars[count++] = (char)c;
+    }
+
+    public void write(final char[] cbuf, final int off, final int len) throws IOException {
+      written = true;
+      System.arraycopy(cbuf, off, chars, count, len);
+      count += len;
+    }
+
+    public void saveChar(final char c) {
+      written = false;
+      chars[count++] = c;
+    }
+
+    public void pushWriter(final Writer writer) {
+      MinML.this.tags.push(this.writer);
+
+      this.writer = (writer == null) ? this : writer;
+
+      flushed = written = false;
+    }
+
+    public Writer getWriter() {
+      return writer;
+    }
+
+    public void popWriter() throws IOException {
+      try {
+        if (!flushed && writer != this) writer.flush();
+      }
+      finally {
+        writer = (Writer)MinML.this.tags.pop();
+        flushed = written = false;
+      }
+    }
+
+    public String getString() {
+    final String result = new String(chars, 0, count);
+
+      count = 0;
+      return result;
+    }
+
+    public void reset() {
+      count = 0;
+    }
+
+    public int read() throws IOException {
+      if (nextIn == lastIn) {
+        if (count != 0) {
+          if (written) {
+            _flush();
+          } else if (count >= (chars.length - MinML.this.bufferIncrement)) {
+          final char[] newChars = new char[chars.length + MinML.this.bufferIncrement];
+
+            System.arraycopy(chars, 0, newChars, 0, count);
+            chars = newChars;
+          }
+        }
+
+        final int numRead = in.read(chars, count, chars.length - count);
+
+        if (numRead == -1) return -1;
+
+        nextIn = count;
+        lastIn = count + numRead;
+      }
+
+      return chars[nextIn++];
+    }
+
+    private void _flush() throws IOException {
+      if (count != 0) {
+        try {
+          if (writer == this) {
+            try {
+              MinML.this.documentHandler.characters(chars, 0, count);
+            }
+            catch (final SAXException e) {
+              throw new IOException(e.toString());
+            }
+          } else {
+            writer.write(chars, 0, count);
+          }
+        }
+        finally {
+          count = 0;
+        }
+      }
+    }
+
+    private int nextIn = 0, lastIn = 0;
+    private char[] chars = new char[MinML.this.initialBufferSize];
+    private final Reader in;
+    private int count = 0;
+    private Writer writer = this;
+    private boolean flushed = false;
+    private boolean written = false;
+  }
+
+  private DocumentHandler extDocumentHandler = this;
+  private org.xml.sax.DocumentHandler documentHandler = this;
+  private ErrorHandler errorHandler = this;
+  private final Stack tags = new Stack();
+  private int lineNumber = 1;
+  private int columnNumber = 0;
+  private final int initialBufferSize;
+  private final int bufferIncrement;
+
+  private static final byte[] charClasses = {
+  //  EOF
+      13,
+  //                                      \t  \n          \r
+      -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 12, -1, -1, 12, -1, -1,
+  //
+      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  //  SP   !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
+      12,  8,  7, 14, 14, 14,  3,  6, 14, 14, 14, 14, 14, 11, 14,  2,
+  //   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  0,  5,  1,  4,
+  //
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+  //                                               [   \   ]
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  9, 14, 10
+  };
+
+  private static final String[] operands = {
+    "\u0d15\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u0015\u0010\u1611",
+    "\u1711\u1000\u0b00\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0114\u0200\u1811\u0114",
+    "\u1711\u1001\u0b01\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0215\u1811\u0414",
+    "\u1711\u1001\u0b01\u1711\u1911\u1911\u1911\u1911\u1911\u1911\u1911\u1911\u0315\u1811\u0414",
+    "\u1911\u1911\u1911\u1911\u1911\u0606\u1911\u1911\u1911\u1911\u1911\u0414\u0515\u1811\u0414",
+    "\u1911\u1911\u1911\u1911\u1911\u0606\u1911\u1911\u1911\u1911\u1911\u1911\u0515\u1811\u1911",
+    "\u1a11\u1a11\u1a11\u1a11\u1a11\u1a11\u0715\u0815\u1a11\u1a11\u1a11\u1a11\u0615\u1811\u1a11",
+    "\u0714\u0714\u0714\u070e\u0714\u0714\u0307\u0714\u0714\u0714\u0714\u0714\u0714\u1811\u0714",
+    "\u0814\u0814\u0814\u080e\u0814\u0814\u0814\u0307\u0814\u0814\u0814\u0814\u0814\u1811\u0814",
+    "\u1711\u1002\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0914\u0915\u1811\u0914",
+    "\u1b11\u1b11\u0904\u1b11\u1b11\u1b11\u1b11\u1b11\u1215\u1b11\u1b11\u1b11\u1b11\u1811\u0105",
+    "\u1711\u1012\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1811\u1711",
+    "\u1711\u1c11\u0912\u1711\u0e12\u1711\u1711\u1711\u1212\u1711\u1711\u1711\u1711\u1811\u0113",
+    "\u1711\u1c11\u0912\u1711\u0e12\u1711\u1711\u1711\u1212\u1711\u1711\u1711\u1711\u1811\u0113",
+    "\u0e15\u0e15\u0e15\u0e15\u0f15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u1811\u0e15",
+    "\u0e15\u0015\u0e15\u0e15\u0f15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u1811\u0e15",
+    "\u0c03\u110f\u110f\u110e\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u1014\u1811\u110f",
+    "\u0a15\u110f\u110f\u110e\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u1811\u110f",
+    "\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u130c\u1d11\u1408\u1d11\u1811\u1515",
+    "\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u110d\u130f\u130f\u1811\u130f",
+    "\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u0009\u1415\u1811\u1415",
+    "\u150a\u000b\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1811\u1515",
+    "expected Element",
+    "unexpected character in tag",
+    "unexpected end of file found",
+    "attribute name not followed by '='",
+    "invalid attribute value",
+    "expecting end tag",
+    "empty tag",
+    "unexpected character after <!"
+  };
+}
--- /dev/null
+++ b/uk/org/xml/sax/DocumentHandler.java
@@ -0,0 +1,11 @@
+package uk.org.xml.sax;
+
+import java.io.Writer;
+import org.xml.sax.SAXException;
+import org.xml.sax.AttributeList;
+
+public interface DocumentHandler extends org.xml.sax.DocumentHandler {
+  Writer startDocument(final Writer writer) throws SAXException;
+  Writer startElement(final String name, final AttributeList attributes, final Writer writer)
+        throws SAXException;
+}
--- /dev/null
+++ b/uk/org/xml/sax/Parser.java
@@ -0,0 +1,5 @@
+package uk.org.xml.sax;
+
+public interface Parser extends org.xml.sax.Parser {
+  void setDocumentHandler(DocumentHandler handler);
+}
\ No newline at end of file
